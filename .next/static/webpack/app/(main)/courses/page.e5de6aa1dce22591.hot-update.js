"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(main)/courses/page",{

/***/ "(app-pages-browser)/./src/lib/contentstack.ts":
/*!*********************************!*\
  !*** ./src/lib/contentstack.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTENT_TYPES: function() { return /* binding */ CONTENT_TYPES; },\n/* harmony export */   Stack: function() { return /* binding */ Stack; },\n/* harmony export */   getAllBanners: function() { return /* binding */ getAllBanners; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllCourses: function() { return /* binding */ getAllCourses; },\n/* harmony export */   getAllHeaders: function() { return /* binding */ getAllHeaders; },\n/* harmony export */   getAllOnboardingSteps: function() { return /* binding */ getAllOnboardingSteps; },\n/* harmony export */   getAllTestimonials: function() { return /* binding */ getAllTestimonials; },\n/* harmony export */   getAuthBranding: function() { return /* binding */ getAuthBranding; },\n/* harmony export */   getCourseByLessonUid: function() { return /* binding */ getCourseByLessonUid; },\n/* harmony export */   getCourseBySlug: function() { return /* binding */ getCourseBySlug; },\n/* harmony export */   getCourseByUid: function() { return /* binding */ getCourseByUid; },\n/* harmony export */   getEntries: function() { return /* binding */ getEntries; },\n/* harmony export */   getEntry: function() { return /* binding */ getEntry; },\n/* harmony export */   getEntryByUrl: function() { return /* binding */ getEntryByUrl; },\n/* harmony export */   getFAQ: function() { return /* binding */ getFAQ; },\n/* harmony export */   getFooter: function() { return /* binding */ getFooter; },\n/* harmony export */   getHeader: function() { return /* binding */ getHeader; },\n/* harmony export */   getLessonBySlug: function() { return /* binding */ getLessonBySlug; },\n/* harmony export */   getLessonByUid: function() { return /* binding */ getLessonByUid; },\n/* harmony export */   getModuleByUid: function() { return /* binding */ getModuleByUid; },\n/* harmony export */   getNewsletter: function() { return /* binding */ getNewsletter; },\n/* harmony export */   getPage: function() { return /* binding */ getPage; },\n/* harmony export */   getPageByUrl: function() { return /* binding */ getPageByUrl; }\n/* harmony export */ });\n/* harmony import */ var contentstack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! contentstack */ \"(app-pages-browser)/./node_modules/contentstack/dist/web/contentstack.js\");\n/* harmony import */ var contentstack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(contentstack__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Contentstack SDK Configuration\nconst Stack = contentstack__WEBPACK_IMPORTED_MODULE_0___default().Stack({\n    api_key: process.env.NEXT_PUBLIC_CONTENTSTACK_API_KEY || \"blt2b872601d3c5423f\" || 0,\n    delivery_token: process.env.NEXT_PUBLIC_CONTENTSTACK_DELIVERY_TOKEN || \"csab2298d637dc5b151fd67edc\" || 0,\n    environment: process.env.NEXT_PUBLIC_CONTENTSTACK_ENVIRONMENT || \"dev\" || 0,\n    branch: process.env.NEXT_PUBLIC_CONTENTSTACK_BRANCH || \"main\" || 0\n});\n// Content Type UIDs - Match your Contentstack setup\nconst CONTENT_TYPES = {\n    PAGE: \"modular_section\",\n    BANNER: \"banner\",\n    HEADER: \"header\",\n    FOOTER: \"footer\",\n    NEWSLETTER: \"newsletter\",\n    ICON: \"icon\",\n    FAQ: \"faq\",\n    FAQ_QUESTION: \"faq_question\",\n    TESTIMONIAL: \"testimonial\",\n    AUTHOR: \"author\",\n    COURSE: \"courses\",\n    MODULE: \"module\",\n    LESSON: \"lesson\",\n    CATEGORY: \"categories_block\",\n    CATEGORY_BLOCK: \"category_block\",\n    INSTRUCTOR: \"instructor\",\n    ONBOARDING: \"onboarding_block\",\n    AUTH_BRANDING: \"auth_branding\"\n};\n// ============================================\n// Generic Fetch Helpers\n// ============================================\n/**\n * Get current locale from localStorage (client-side) or default\n */ function getCurrentLocale() {\n    if (true) {\n        return localStorage.getItem(\"selectedLanguage\") || \"en-us\";\n    }\n    return \"en-us\";\n}\n/**\n * Default fallback locale when content is not available in selected locale\n */ const FALLBACK_LOCALE = \"en-us\";\n/**\n * Fetch single entry by content type and UID\n */ async function getEntry(contentType, entryUid) {\n    let referenceFields = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], locale = arguments.length > 3 ? arguments[3] : void 0;\n    try {\n        const query = Stack.ContentType(contentType).Entry(entryUid);\n        // Set locale if provided\n        const targetLocale = locale || getCurrentLocale();\n        query.language(targetLocale);\n        referenceFields.forEach((field)=>{\n            query.includeReference(field);\n        });\n        const result = await query.toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching entry: \".concat(contentType, \"/\").concat(entryUid), error);\n        return null;\n    }\n}\n/**\n * Fetch entries by content type with options\n */ async function getEntries(contentType) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const query = Stack.ContentType(contentType).Query();\n        // Set locale if provided\n        const targetLocale = options.locale || getCurrentLocale();\n        query.language(targetLocale);\n        if (options.referenceFields) {\n            options.referenceFields.forEach((field)=>{\n                query.includeReference(field);\n            });\n        }\n        if (options.limit) query.limit(options.limit);\n        if (options.skip) query.skip(options.skip);\n        if (options.orderBy) {\n            if (options.orderDirection === \"desc\") {\n                query.descending(options.orderBy);\n            } else {\n                query.ascending(options.orderBy);\n            }\n        }\n        if (options.where) {\n            Object.entries(options.where).forEach((param)=>{\n                let [key, value] = param;\n                query.where(key, value);\n            });\n        }\n        const result = await query.toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching entries: \".concat(contentType), error);\n        return [];\n    }\n}\n/**\n * Fetch entry by URL\n */ async function getEntryByUrl(contentType, url) {\n    let referenceFields = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    try {\n        var _result_;\n        const query = Stack.ContentType(contentType).Query().where(\"url\", url);\n        referenceFields.forEach((field)=>{\n            query.includeReference(field);\n        });\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching entry by URL: \".concat(contentType, \"/\").concat(url), error);\n        return null;\n    }\n}\n// ============================================\n// Page (Modular Section) Fetch Functions\n// ============================================\n/**\n * Fetch Page entry by title with all nested references\n * This is the main function for fetching page content\n * Supports locale for fetching localized content\n */ async function getPage(title, locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"title\", title).includeReference([\n            \"header\",\n            \"header.icon\",\n            \"section.hero_block.hero_banner\",\n            \"section.carousel_block.banner\",\n            \"section.category_block.icon\",\n            \"section.category_block.category\",\n            \"section.feature_block.features\",\n            \"section.workflow_block.stage\",\n            \"section.testimonial_block.testimonial\",\n            \"section.testimonial_block.testimonial.author\"\n        ]);\n        // Set locale for content fetching\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let pageEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // Fallback to en-us if no page found in selected locale\n        if (!pageEntry && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            console.log('[CMS] Page \"'.concat(title, '\" not found in ').concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"title\", title).includeReference([\n                \"header\",\n                \"header.icon\",\n                \"section.hero_block.hero_banner\",\n                \"section.carousel_block.banner\",\n                \"section.category_block.icon\",\n                \"section.category_block.category\",\n                \"section.feature_block.features\",\n                \"section.workflow_block.stage\",\n                \"section.testimonial_block.testimonial\",\n                \"section.testimonial_block.testimonial.author\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            pageEntry = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        // Debug logging\n        if (pageEntry) {\n            var _pageEntry_section;\n            console.log('[CMS] Page \"'.concat(title, '\" loaded with ').concat(((_pageEntry_section = pageEntry.section) === null || _pageEntry_section === void 0 ? void 0 : _pageEntry_section.length) || 0, \" sections\"));\n        }\n        return pageEntry;\n    } catch (error) {\n        console.error(\"Error fetching page: \".concat(title), error);\n        return null;\n    }\n}\n/**\n * Fetch Page entry by URL\n */ async function getPageByUrl(url) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"url\", url).includeReference([\n            \"header\",\n            \"header.icon\",\n            \"section.carousel_block.banner\",\n            \"section.category_block.icon\",\n            \"section.category_block.category\",\n            \"section.feature_block.features\",\n            \"section.workflow_block.stage\",\n            \"section.testimonial_block.testimonial\",\n            \"section.testimonial_block.testimonial.author\"\n        ]);\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching page by URL: \".concat(url), error);\n        return null;\n    }\n}\n// ============================================\n// Category Fetch Functions\n// ============================================\n/**\n * Fetch all Category entries\n */ async function getAllCategories() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.CATEGORY).Query().toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching categories\", error);\n        return [];\n    }\n}\n// ============================================\n// Header Fetch Functions\n// ============================================\n/**\n * Fetch Header entry by title\n * Header is always fetched in English since it contains non-translatable UI config\n * @param title - \"Landing Header\" or \"App Header\"\n */ async function getHeader(title) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.HEADER).Query().where(\"title\", title).includeReference(\"icon\");\n        // Always fetch header in English (contains UI configuration, not translated content)\n        query.language(\"en-us\");\n        const result = await query.toJSON().find();\n        const header = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        if (header) {\n            var _header_accessibility_language;\n            console.log('[CMS] Header \"'.concat(title, '\" loaded with ').concat(((_header_accessibility_language = header.accessibility_language) === null || _header_accessibility_language === void 0 ? void 0 : _header_accessibility_language.length) || 0, \" languages\"));\n        }\n        return header;\n    } catch (error) {\n        console.error(\"Error fetching header: \".concat(title), error);\n        return null;\n    }\n}\n/**\n * Fetch all Headers\n */ async function getAllHeaders() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.HEADER).Query().includeReference(\"icon\").toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching all headers\", error);\n        return [];\n    }\n}\n// ============================================\n// Footer & Newsletter Fetch Functions\n// ============================================\n/**\n * Fetch Footer entry (singleton)\n * Supports locale for fetching localized content\n */ async function getFooter(locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        const query = Stack.ContentType(CONTENT_TYPES.FOOTER).Query().includeReference(\"icon\");\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let footer = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // Fallback to en-us if not found\n        if (!footer && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.FOOTER).Query().includeReference(\"icon\");\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            footer = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        return footer;\n    } catch (error) {\n        console.error(\"Error fetching footer\", error);\n        return null;\n    }\n}\n/**\n * Fetch Newsletter entry (singleton)\n * Supports locale for fetching localized content\n */ async function getNewsletter(locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        const query = Stack.ContentType(CONTENT_TYPES.NEWSLETTER).Query().includeReference(\"icon\");\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let newsletter = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // Fallback to en-us if not found\n        if (!newsletter && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.NEWSLETTER).Query().includeReference(\"icon\");\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            newsletter = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        return newsletter;\n    } catch (error) {\n        console.error(\"Error fetching newsletter\", error);\n        return null;\n    }\n}\n// ============================================\n// FAQ Fetch Functions\n// ============================================\n/**\n * Fetch FAQ entry (singleton) with nested references\n */ async function getFAQ() {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.FAQ).Query().includeReference([\n            \"icon\",\n            \"faq_question\"\n        ]);\n        const result = await query.toJSON().find();\n        const faqEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        if (faqEntry) {\n            console.log(\"FAQ Entry fetched:\", {\n                title: faqEntry.section_title,\n                hasIcon: !!faqEntry.icon,\n                faqQuestionType: Array.isArray(faqEntry.faq_question) ? \"array\" : \"object\"\n            });\n        }\n        return faqEntry;\n    } catch (error) {\n        console.error(\"Error fetching FAQ\", error);\n        return null;\n    }\n}\n// ============================================\n// Banner Fetch Functions\n// ============================================\n/**\n * Fetch all Banner entries\n */ async function getAllBanners() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.BANNER).Query().toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching banners\", error);\n        return [];\n    }\n}\n// ============================================\n// Testimonial Fetch Functions\n// ============================================\n/**\n * Fetch all Testimonial entries with author reference\n */ async function getAllTestimonials() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.TESTIMONIAL).Query().includeReference(\"author\").toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching testimonials\", error);\n        return [];\n    }\n}\n// ============================================\n// Course Fetch Functions\n// ============================================\n/**\n * Fetch all courses with author reference\n * Falls back to English if no content found in selected locale\n */ async function getAllCourses(locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        // First try with selected locale\n        const query = Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n            \"author\",\n            \"modules\"\n        ]);\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let courses = result[0] || [];\n        // If no courses found and we're not already using fallback, try fallback locale\n        if (courses.length === 0 && targetLocale !== FALLBACK_LOCALE) {\n            console.log(\"[CMS] No courses found in \".concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n                \"author\",\n                \"modules\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            courses = fallbackResult[0] || [];\n        }\n        // Resolve author references for all courses\n        const resolvedCourses = await Promise.all(courses.map((course)=>resolveAuthorReferences(course)));\n        return resolvedCourses;\n    } catch (error) {\n        console.error(\"Error fetching courses\", error);\n        return [];\n    }\n}\n/**\n * Fetch author by UID - always fetches from default locale since authors are not localized\n */ async function getAuthorByUid(uid) {\n    try {\n        const query = Stack.ContentType(CONTENT_TYPES.AUTHOR).Entry(uid);\n        // Always fetch authors in fallback locale since author data (name, bio) is non-localizable\n        query.language(FALLBACK_LOCALE);\n        const result = await query.toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching author by UID: \".concat(uid), error);\n        return null;\n    }\n}\n/**\n * Helper to resolve author references that may not be fully populated\n * When fetching localized content, references to non-localized entries may not resolve\n * This function always fetches author data from the fallback locale to ensure consistency\n */ async function resolveAuthorReferences(course) {\n    if (!course.author) return course;\n    const authors = Array.isArray(course.author) ? course.author : [\n        course.author\n    ];\n    const resolvedAuthors = [];\n    for (const author of authors){\n        // Always fetch the full author data from fallback locale to ensure we have all fields\n        // This is because author data (name, bio, social links) is marked as non-localizable\n        // but when fetching course in a different locale, the reference may not resolve properly\n        if (author.uid) {\n            // Always fetch fresh to ensure we get complete data\n            const fullAuthor = await getAuthorByUid(author.uid);\n            if (fullAuthor) {\n                resolvedAuthors.push(fullAuthor);\n            } else if (author.title) {\n                // Fallback: if fetch fails but we have partial data, use it\n                resolvedAuthors.push(author);\n            }\n        } else if (author.title) {\n            // No UID but has title - use as is\n            resolvedAuthors.push(author);\n        }\n    }\n    course.author = resolvedAuthors.length > 0 ? resolvedAuthors : undefined;\n    return course;\n}\n/**\n * Fetch a single course by slug with all nested references\n * Falls back to English if no content found in selected locale\n */ async function getCourseBySlug(slug, locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        // First try with selected locale\n        const query = Stack.ContentType(CONTENT_TYPES.COURSE).Query().where(\"slug\", slug).includeReference([\n            \"author\",\n            \"modules\",\n            \"modules.lessons\"\n        ]);\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let course = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // If no course found and we're not already using fallback, try fallback locale\n        if (!course && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            console.log(\"[CMS] Course not found in \".concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Query().where(\"slug\", slug).includeReference([\n                \"author\",\n                \"modules\",\n                \"modules.lessons\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            course = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        // Ensure author references are fully resolved\n        if (course) {\n            course = await resolveAuthorReferences(course);\n            console.log('[CMS] Course \"'.concat(course.title, '\" loaded with ').concat(Array.isArray(course.modules) ? course.modules.length : course.modules ? 1 : 0, \" modules\"));\n        }\n        return course;\n    } catch (error) {\n        console.error(\"Error fetching course by slug: \".concat(slug), error);\n        return null;\n    }\n}\n/**\n * Fetch a single course by UID with all nested references\n * Falls back to English if no content found in selected locale\n */ async function getCourseByUid(uid, locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        let course = null;\n        // First try with selected locale\n        try {\n            const query = Stack.ContentType(CONTENT_TYPES.COURSE).Entry(uid).includeReference([\n                \"author\",\n                \"modules\",\n                \"modules.lessons\"\n            ]);\n            query.language(targetLocale);\n            const result = await query.toJSON().fetch();\n            course = result;\n        } catch (localeError) {\n            // If locale fetch fails and we're not already using fallback, try fallback\n            if (targetLocale !== FALLBACK_LOCALE) {\n                console.log(\"[CMS] Course UID \".concat(uid, \" not found in \").concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n                const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Entry(uid).includeReference([\n                    \"author\",\n                    \"modules\",\n                    \"modules.lessons\"\n                ]);\n                fallbackQuery.language(FALLBACK_LOCALE);\n                const fallbackResult = await fallbackQuery.toJSON().fetch();\n                course = fallbackResult;\n            } else {\n                throw localeError;\n            }\n        }\n        // Ensure author references are fully resolved\n        if (course) {\n            course = await resolveAuthorReferences(course);\n        }\n        return course;\n    } catch (error) {\n        console.error(\"Error fetching course by UID: \".concat(uid), error);\n        return null;\n    }\n}\n// ============================================\n// Module Fetch Functions\n// ============================================\n/**\n * Fetch a single module by UID with lessons\n */ async function getModuleByUid(uid) {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.MODULE).Entry(uid).includeReference([\n            \"lessons\"\n        ]).toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching module by UID: \".concat(uid), error);\n        return null;\n    }\n}\n// ============================================\n// Lesson Fetch Functions\n// ============================================\n/**\n * Fetch a single lesson by UID\n */ async function getLessonByUid(uid) {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.LESSON).Entry(uid).toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching lesson by UID: \".concat(uid), error);\n        return null;\n    }\n}\n/**\n * Fetch a single lesson by slug\n */ async function getLessonBySlug(slug) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.LESSON).Query().where(\"slug\", slug);\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching lesson by slug: \".concat(slug), error);\n        return null;\n    }\n}\n/**\n * Fetch course data for a given lesson (to get course context)\n * Returns the course that contains this lesson\n */ async function getCourseByLessonUid(lessonUid) {\n    try {\n        // First, find which module contains this lesson\n        const modulesResult = await Stack.ContentType(CONTENT_TYPES.MODULE).Query().includeReference([\n            \"lessons\"\n        ]).toJSON().find();\n        const modules = modulesResult[0] || [];\n        let targetModuleUid = null;\n        for (const module of modules){\n            const lessons = Array.isArray(module.lessons) ? module.lessons : module.lessons ? [\n                module.lessons\n            ] : [];\n            if (lessons.some((lesson)=>lesson.uid === lessonUid)) {\n                targetModuleUid = module.uid;\n                break;\n            }\n        }\n        if (!targetModuleUid) return null;\n        // Now find the course that contains this module\n        const coursesResult = await Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n            \"author\",\n            \"modules\",\n            \"modules.lessons\"\n        ]).toJSON().find();\n        const courses = coursesResult[0] || [];\n        for (const course of courses){\n            const courseModules = Array.isArray(course.modules) ? course.modules : course.modules ? [\n                course.modules\n            ] : [];\n            if (courseModules.some((m)=>m.uid === targetModuleUid)) {\n                return course;\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching course by lesson UID: \".concat(lessonUid), error);\n        return null;\n    }\n}\n// ============================================\n// Onboarding Fetch Functions\n// ============================================\n/**\n * Fetch all onboarding steps\n * Returns steps sorted by current_step\n * Tries multiple content type names in case the exact name differs\n */ async function getAllOnboardingSteps() {\n    // Try different possible content type names\n    const possibleContentTypes = [\n        \"onboarding_block\",\n        \"onboarding\",\n        \"onboarding_step\",\n        \"onboarding_steps\",\n        \"modular_section\"\n    ];\n    for (const contentType of possibleContentTypes){\n        try {\n            const baseQuery = Stack.ContentType(contentType).Query();\n            // If it's modular_section, filter for onboarding entries\n            if (contentType === \"modular_section\") {\n                baseQuery.where(\"title\", \"Onboarding Step\");\n            } else {\n                // For onboarding-specific content types, include option references\n                baseQuery.includeReference(\"option\");\n            }\n            baseQuery.ascending(\"current_step\"); // Sort by step number\n            const result = await baseQuery.toJSON().find();\n            const entries = result[0] || [];\n            console.log(\"[CMS] Attempted \".concat(contentType, \": Found \").concat(entries.length, \" entries\"));\n            if (entries.length > 0) {\n                // Filter and transform entries\n                const onboardingEntries = entries.filter((entry)=>{\n                    var _entry_title;\n                    // Check if entry has onboarding-related fields\n                    return entry.current_step !== undefined || entry.label_text !== undefined || ((_entry_title = entry.title) === null || _entry_title === void 0 ? void 0 : _entry_title.toLowerCase().includes(\"onboarding\"));\n                }).map((entry)=>{\n                    var _entry_title_match, _entry_title;\n                    // Transform to OnboardingBlockEntry format\n                    return {\n                        uid: entry.uid || entry._id || \"\",\n                        title: entry.title,\n                        current_step: entry.current_step || parseInt(((_entry_title = entry.title) === null || _entry_title === void 0 ? void 0 : (_entry_title_match = _entry_title.match(/\\d+/)) === null || _entry_title_match === void 0 ? void 0 : _entry_title_match[0]) || \"1\"),\n                        total_steps: entry.total_steps || 5,\n                        label_text: entry.label_text || entry.title || \"\",\n                        display_type: entry.display_type || \"Card Grid\",\n                        option: entry.option || [],\n                        back_button_text: entry.back_button_text || \"Back\",\n                        next_button_text: entry.next_button_text || \"Continue\"\n                    };\n                });\n                if (onboardingEntries.length > 0) {\n                    console.log(\"[CMS] Successfully fetched \".concat(onboardingEntries.length, \" onboarding steps from \").concat(contentType));\n                    return onboardingEntries.sort((a, b)=>a.current_step - b.current_step);\n                }\n            }\n        } catch (error) {\n            // Log the error but continue trying other content types\n            console.log(\"[CMS] Content type \".concat(contentType, \" failed:\"), error.message || error);\n            continue;\n        }\n    }\n    // If no content type found, try searching modular_section for any onboarding-related entries\n    try {\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().includeReference([\n            \"section\"\n        ]);\n        const result = await query.toJSON().find();\n        const pages = result[0] || [];\n        // Look for pages with \"Onboarding\" in title\n        const onboardingPages = pages.filter((page)=>{\n            var _page_title;\n            return (_page_title = page.title) === null || _page_title === void 0 ? void 0 : _page_title.toLowerCase().includes(\"onboarding\");\n        });\n        if (onboardingPages.length > 0) {\n            console.log(\"[CMS] Found onboarding page(s), but need proper content type structure\");\n        }\n    } catch (error) {\n        console.error(\"Error searching for onboarding page:\", error);\n    }\n    console.warn(\"[CMS] No onboarding content type found. Please check:\");\n    console.warn(\"1. Content type name in Contentstack (might be different)\");\n    console.warn(\"2. Entries are published\");\n    console.warn(\"3. API keys and environment are correct\");\n    return [];\n}\n// ============================================\n// Auth Branding Fetch Functions\n// ============================================\n/**\n * Fetch Auth Branding entry by page type (login or signup)\n * Matches Contentstack schema: page_type is \"Sign In\" or \"Sign Up\"\n */ async function getAuthBranding(pageType) {\n    try {\n        // Convert lowercase to Contentstack format\n        const pageTypeValue = pageType === \"login\" ? \"Sign In\" : \"Sign Up\";\n        const query = Stack.ContentType(CONTENT_TYPES.AUTH_BRANDING).Query().where(\"page_type\", pageTypeValue).includeReference([\n            \"stats\"\n        ]); // stats is reference to icon content type\n        const result = await query.toJSON().find();\n        const entries = result[0] || [];\n        if (entries.length > 0) {\n            const entry = entries[0];\n            // Log for debugging\n            console.log(\"[CMS] Auth branding entry for \".concat(pageType, \":\"), {\n                headline: entry.headline,\n                subtitle: entry.subtitle,\n                branding_content: entry.branding_content,\n                stats: entry.stats,\n                statsType: Array.isArray(entry.stats) ? \"array\" : typeof entry.stats\n            });\n            return {\n                uid: entry.uid || entry._id || \"\",\n                title: entry.title || \"\",\n                page_type: entry.page_type || pageTypeValue,\n                headline: entry.headline,\n                subtitle: entry.subtitle,\n                branding_content: entry.branding_content,\n                stats: entry.stats,\n                background_image: entry.background_image\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching auth branding for \".concat(pageType, \":\"), error);\n        return null;\n    }\n}\n// Export the Stack for advanced usage\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGVudHN0YWNrLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQW1CeEMsaUNBQWlDO0FBQ2pDLE1BQU1DLFFBQVFELHlEQUFrQixDQUFDO0lBQy9CRSxTQUFTQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLGdDQUFnQyxJQUFJRixxQkFBZ0MsSUFBSTtJQUM3RkksZ0JBQWdCSixPQUFPQSxDQUFDQyxHQUFHLENBQUNJLHVDQUF1QyxJQUFJTCw0QkFBdUMsSUFBSTtJQUNsSE8sYUFBYVAsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDTyxvQ0FBb0MsSUFBSVIsS0FBb0MsSUFBSTtJQUN6R1UsUUFBUVYsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDVSwrQkFBK0IsSUFBSVgsTUFBK0IsSUFBSTtBQUM1RjtBQWlCQSxvREFBb0Q7QUFDN0MsTUFBTWEsZ0JBQWdCO0lBQzNCQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLGNBQWM7SUFDZEMsYUFBYTtJQUNiQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsZ0JBQWdCO0lBQ2hCQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsZUFBZTtBQUNqQixFQUFXO0FBRVgsK0NBQStDO0FBQy9DLHdCQUF3QjtBQUN4QiwrQ0FBK0M7QUFFL0M7O0NBRUMsR0FDRCxTQUFTQztJQUNQLElBQUksSUFBa0IsRUFBYTtRQUNqQyxPQUFPQyxhQUFhQyxPQUFPLENBQUMsdUJBQXVCO0lBQ3JEO0lBQ0EsT0FBTztBQUNUO0FBRUE7O0NBRUMsR0FDRCxNQUFNQyxrQkFBa0I7QUFFeEI7O0NBRUMsR0FDTSxlQUFlQyxTQUNwQkMsV0FBbUIsRUFDbkJDLFFBQWdCO1FBQ2hCQyxrQkFBQUEsaUVBQTRCLEVBQUUsRUFD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LEdBQUcsR0FBRztZQUN0QixNQUFNOEQsUUFBUTNFLE9BQU8sQ0FBQyxFQUFFO1lBRXhCLG9CQUFvQjtZQUNwQlosUUFBUXNCLEdBQUcsQ0FBQyxpQ0FBMEMsT0FBVHVGLFVBQVMsTUFBSTtnQkFDeERFLFVBQVV4QixNQUFNd0IsUUFBUTtnQkFDeEJDLFVBQVV6QixNQUFNeUIsUUFBUTtnQkFDeEJDLGtCQUFrQjFCLE1BQU0wQixnQkFBZ0I7Z0JBQ3hDQyxPQUFPM0IsTUFBTTJCLEtBQUs7Z0JBQ2xCQyxXQUFXekUsTUFBTUMsT0FBTyxDQUFDNEMsTUFBTTJCLEtBQUssSUFBSSxVQUFVLE9BQU8zQixNQUFNMkIsS0FBSztZQUN0RTtZQUVBLE9BQU87Z0JBQ0wxRCxLQUFLK0IsTUFBTS9CLEdBQUcsSUFBSStCLE1BQU1LLEdBQUcsSUFBSTtnQkFDL0J6RSxPQUFPb0UsTUFBTXBFLEtBQUssSUFBSTtnQkFDdEJpRyxXQUFXN0IsTUFBTTZCLFNBQVMsSUFBSU47Z0JBQzlCQyxVQUFVeEIsTUFBTXdCLFFBQVE7Z0JBQ3hCQyxVQUFVekIsTUFBTXlCLFFBQVE7Z0JBQ3hCQyxrQkFBa0IxQixNQUFNMEIsZ0JBQWdCO2dCQUN4Q0MsT0FBTzNCLE1BQU0yQixLQUFLO2dCQUNsQkcsa0JBQWtCOUIsTUFBTThCLGdCQUFnQjtZQUMxQztRQUNGO1FBRUEsT0FBTztJQUNULEVBQUUsT0FBT3RILE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG9DQUE2QyxPQUFUOEcsVUFBUyxNQUFJOUc7UUFDL0QsT0FBTztJQUNUO0FBQ0Y7QUFFQSxzQ0FBc0M7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jb250ZW50c3RhY2sudHM/YjA2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGVudHN0YWNrIGZyb20gJ2NvbnRlbnRzdGFjayc7XG5pbXBvcnQgeyBcbiAgSGVhZGVyRW50cnksIFxuICBGb290ZXJFbnRyeSwgXG4gIE5ld3NsZXR0ZXJFbnRyeSwgXG4gIEZBUUVudHJ5LFxuICBQYWdlRW50cnksXG4gIEJhbm5lckVudHJ5LFxuICBUZXN0aW1vbmlhbEVudHJ5LFxuICBIZXJvQmxvY2tFbnRyeSxcbiAgQ2F0ZWdvcnlFbnRyeSxcbiAgQ291cnNlRW50cnksXG4gIE1vZHVsZUVudHJ5LFxuICBMZXNzb25FbnRyeSxcbiAgT25ib2FyZGluZ0Jsb2NrRW50cnksXG4gIEF1dGhCcmFuZGluZ0VudHJ5LFxuICBBdXRob3JFbnRyeVxufSBmcm9tICdAL3R5cGVzL2NvbnRlbnRzdGFjayc7XG5cbi8vIENvbnRlbnRzdGFjayBTREsgQ29uZmlndXJhdGlvblxuY29uc3QgU3RhY2sgPSBDb250ZW50c3RhY2suU3RhY2soe1xuICBhcGlfa2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfQVBJX0tFWSB8fCBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfQVBJX0tFWSB8fCAnJyxcbiAgZGVsaXZlcnlfdG9rZW46IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19ERUxJVkVSWV9UT0tFTiB8fCBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfREVMSVZFUllfVE9LRU4gfHwgJycsXG4gIGVudmlyb25tZW50OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfRU5WSVJPTk1FTlQgfHwgcHJvY2Vzcy5lbnYuQ09OVEVOVFNUQUNLX0VOVklST05NRU5UIHx8ICdkZXYnLFxuICBicmFuY2g6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19CUkFOQ0ggfHwgcHJvY2Vzcy5lbnYuQ09OVEVOVFNUQUNLX0JSQU5DSCB8fCAnbWFpbicsXG59KTtcblxuLy8gVHlwZSBkZWZpbml0aW9ucyBmb3IgQ29udGVudHN0YWNrIGVudHJpZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudHN0YWNrRW50cnkge1xuICB1aWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudHN0YWNrQXNzZXQge1xuICB1aWQ6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG59XG5cbi8vIENvbnRlbnQgVHlwZSBVSURzIC0gTWF0Y2ggeW91ciBDb250ZW50c3RhY2sgc2V0dXBcbmV4cG9ydCBjb25zdCBDT05URU5UX1RZUEVTID0ge1xuICBQQUdFOiAnbW9kdWxhcl9zZWN0aW9uJywgIC8vIFBhZ2UgY29udGVudCB0eXBlIChtb2R1bGFyIHNlY3Rpb25zKVxuICBCQU5ORVI6ICdiYW5uZXInLFxuICBIRUFERVI6ICdoZWFkZXInLFxuICBGT09URVI6ICdmb290ZXInLFxuICBORVdTTEVUVEVSOiAnbmV3c2xldHRlcicsXG4gIElDT046ICdpY29uJyxcbiAgRkFROiAnZmFxJyxcbiAgRkFRX1FVRVNUSU9OOiAnZmFxX3F1ZXN0aW9uJyxcbiAgVEVTVElNT05JQUw6ICd0ZXN0aW1vbmlhbCcsXG4gIEFVVEhPUjogJ2F1dGhvcicsXG4gIENPVVJTRTogJ2NvdXJzZXMnLCAgLy8gQ291cnNlIGNvbnRlbnQgdHlwZVxuICBNT0RVTEU6ICdtb2R1bGUnLCAgIC8vIE1vZHVsZSBjb250ZW50IHR5cGVcbiAgTEVTU09OOiAnbGVzc29uJywgICAvLyBMZXNzb24gY29udGVudCB0eXBlXG4gIENBVEVHT1JZOiAnY2F0ZWdvcmllc19ibG9jaycsICAvLyBVcGRhdGVkIHRvIG1hdGNoIG5ldyBjb250ZW50IHR5cGVcbiAgQ0FURUdPUllfQkxPQ0s6ICdjYXRlZ29yeV9ibG9jaycsICAvLyBTaW5nbGV0b24gZm9yIHJlZmVyZW5jaW5nIGNhdGVnb3JpZXNcbiAgSU5TVFJVQ1RPUjogJ2luc3RydWN0b3InLFxuICBPTkJPQVJESU5HOiAnb25ib2FyZGluZ19ibG9jaycsICAvLyBPbmJvYXJkaW5nIHN0ZXBzIGNvbnRlbnQgdHlwZVxuICBBVVRIX0JSQU5ESU5HOiAnYXV0aF9icmFuZGluZycsICAvLyBBdXRoIGJyYW5kaW5nIGNvbnRlbnQgdHlwZSBmb3IgbG9naW4vc2lnbnVwIHBhZ2VzXG59IGFzIGNvbnN0O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gR2VuZXJpYyBGZXRjaCBIZWxwZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEdldCBjdXJyZW50IGxvY2FsZSBmcm9tIGxvY2FsU3RvcmFnZSAoY2xpZW50LXNpZGUpIG9yIGRlZmF1bHRcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudExvY2FsZSgpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NlbGVjdGVkTGFuZ3VhZ2UnKSB8fCAnZW4tdXMnO1xuICB9XG4gIHJldHVybiAnZW4tdXMnO1xufVxuXG4vKipcbiAqIERlZmF1bHQgZmFsbGJhY2sgbG9jYWxlIHdoZW4gY29udGVudCBpcyBub3QgYXZhaWxhYmxlIGluIHNlbGVjdGVkIGxvY2FsZVxuICovXG5jb25zdCBGQUxMQkFDS19MT0NBTEUgPSAnZW4tdXMnO1xuXG4vKipcbiAqIEZldGNoIHNpbmdsZSBlbnRyeSBieSBjb250ZW50IHR5cGUgYW5kIFVJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW50cnk8VCA9IENvbnRlbnRzdGFja0VudHJ5PihcbiAgY29udGVudFR5cGU6IHN0cmluZyxcbiAgZW50cnlVaWQ6IHN0cmluZyxcbiAgcmVmZXJlbmNlRmllbGRzOiBzdHJpbmdbXSA9IFtdLFxuICBsb2NhbGU/OiBzdHJpbmdcbik6IFByb21pc2U8VCB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKS5FbnRyeShlbnRyeVVpZCk7XG4gICAgXG4gICAgLy8gU2V0IGxvY2FsZSBpZiBwcm92aWRlZFxuICAgIGNvbnN0IHRhcmdldExvY2FsZSA9IGxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcbiAgICBcbiAgICByZWZlcmVuY2VGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIHF1ZXJ5LmluY2x1ZGVSZWZlcmVuY2UoZmllbGQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICByZXR1cm4gcmVzdWx0IGFzIFQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgZW50cnk6ICR7Y29udGVudFR5cGV9LyR7ZW50cnlVaWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggZW50cmllcyBieSBjb250ZW50IHR5cGUgd2l0aCBvcHRpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbnRyaWVzPFQgPSBDb250ZW50c3RhY2tFbnRyeT4oXG4gIGNvbnRlbnRUeXBlOiBzdHJpbmcsXG4gIG9wdGlvbnM6IHtcbiAgICByZWZlcmVuY2VGaWVsZHM/OiBzdHJpbmdbXTtcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICBza2lwPzogbnVtYmVyO1xuICAgIG9yZGVyQnk/OiBzdHJpbmc7XG4gICAgbG9jYWxlPzogc3RyaW5nO1xuICAgIG9yZGVyRGlyZWN0aW9uPzogJ2FzYycgfCAnZGVzYyc7XG4gICAgd2hlcmU/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB9ID0ge31cbik6IFByb21pc2U8VFtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZSkuUXVlcnkoKTtcbiAgICBcbiAgICAvLyBTZXQgbG9jYWxlIGlmIHByb3ZpZGVkXG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG4gICAgXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlRmllbGRzKSB7XG4gICAgICBvcHRpb25zLnJlZmVyZW5jZUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICBxdWVyeS5pbmNsdWRlUmVmZXJlbmNlKGZpZWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxpbWl0KSBxdWVyeS5saW1pdChvcHRpb25zLmxpbWl0KTtcbiAgICBpZiAob3B0aW9ucy5za2lwKSBxdWVyeS5za2lwKG9wdGlvbnMuc2tpcCk7XG5cbiAgICBpZiAob3B0aW9ucy5vcmRlckJ5KSB7XG4gICAgICBpZiAob3B0aW9ucy5vcmRlckRpcmVjdGlvbiA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgIHF1ZXJ5LmRlc2NlbmRpbmcob3B0aW9ucy5vcmRlckJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5LmFzY2VuZGluZyhvcHRpb25zLm9yZGVyQnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLndoZXJlKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLndoZXJlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgcXVlcnkud2hlcmUoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIFRbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBlbnRyaWVzOiAke2NvbnRlbnRUeXBlfWAsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBlbnRyeSBieSBVUkxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVudHJ5QnlVcmw8VCA9IENvbnRlbnRzdGFja0VudHJ5PihcbiAgY29udGVudFR5cGU6IHN0cmluZyxcbiAgdXJsOiBzdHJpbmcsXG4gIHJlZmVyZW5jZUZpZWxkczogc3RyaW5nW10gPSBbXVxuKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGUpLlF1ZXJ5KCkud2hlcmUoJ3VybCcsIHVybCk7XG4gICAgXG4gICAgcmVmZXJlbmNlRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICBxdWVyeS5pbmNsdWRlUmVmZXJlbmNlKGZpZWxkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdPy5bMF0gYXMgVCB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGVudHJ5IGJ5IFVSTDogJHtjb250ZW50VHlwZX0vJHt1cmx9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQYWdlIChNb2R1bGFyIFNlY3Rpb24pIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBQYWdlIGVudHJ5IGJ5IHRpdGxlIHdpdGggYWxsIG5lc3RlZCByZWZlcmVuY2VzXG4gKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIGZvciBmZXRjaGluZyBwYWdlIGNvbnRlbnRcbiAqIFN1cHBvcnRzIGxvY2FsZSBmb3IgZmV0Y2hpbmcgbG9jYWxpemVkIGNvbnRlbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBhZ2UodGl0bGU6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKTogUHJvbWlzZTxQYWdlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuUEFHRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAud2hlcmUoJ3RpdGxlJywgdGl0bGUpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICdoZWFkZXInLFxuICAgICAgICAnaGVhZGVyLmljb24nLFxuICAgICAgICAnc2VjdGlvbi5oZXJvX2Jsb2NrLmhlcm9fYmFubmVyJywgICAgICAgIC8vIEhlcm8gQmFubmVyIHJlZmVyZW5jZVxuICAgICAgICAnc2VjdGlvbi5jYXJvdXNlbF9ibG9jay5iYW5uZXInLCAgICAgICAgICAvLyBCYW5uZXIgcmVmZXJlbmNlcyBmb3IgY2Fyb3VzZWxcbiAgICAgICAgJ3NlY3Rpb24uY2F0ZWdvcnlfYmxvY2suaWNvbicsICAgICAgICAgICAgLy8gTGVnYWN5IGNhdGVnb3J5IGljb25zXG4gICAgICAgICdzZWN0aW9uLmNhdGVnb3J5X2Jsb2NrLmNhdGVnb3J5JywgICAgICAgIC8vIE5ldyBjYXRlZ29yeSByZWZlcmVuY2VzIChjYXRlZ29yaWVzX2Jsb2NrKVxuICAgICAgICAnc2VjdGlvbi5mZWF0dXJlX2Jsb2NrLmZlYXR1cmVzJywgICAgICAgICAvLyBGZWF0dXJlIGljb25zXG4gICAgICAgICdzZWN0aW9uLndvcmtmbG93X2Jsb2NrLnN0YWdlJywgICAgICAgICAgIC8vIFdvcmtmbG93IHN0YWdlIGljb25zXG4gICAgICAgICdzZWN0aW9uLnRlc3RpbW9uaWFsX2Jsb2NrLnRlc3RpbW9uaWFsJywgIC8vIFRlc3RpbW9uaWFsIGVudHJpZXNcbiAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwuYXV0aG9yJywgLy8gVGVzdGltb25pYWwgYXV0aG9yc1xuICAgICAgXSk7XG5cbiAgICAvLyBTZXQgbG9jYWxlIGZvciBjb250ZW50IGZldGNoaW5nXG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBsZXQgcGFnZUVudHJ5ID0gcmVzdWx0WzBdPy5bMF0gYXMgUGFnZUVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gZW4tdXMgaWYgbm8gcGFnZSBmb3VuZCBpbiBzZWxlY3RlZCBsb2NhbGVcbiAgICBpZiAoIXBhZ2VFbnRyeSAmJiB0YXJnZXRMb2NhbGUgIT09IEZBTExCQUNLX0xPQ0FMRSkge1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIFBhZ2UgXCIke3RpdGxlfVwiIG5vdCBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLlBBR0UpXG4gICAgICAgIC5RdWVyeSgpXG4gICAgICAgIC53aGVyZSgndGl0bGUnLCB0aXRsZSlcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAgICdoZWFkZXInLFxuICAgICAgICAgICdoZWFkZXIuaWNvbicsXG4gICAgICAgICAgJ3NlY3Rpb24uaGVyb19ibG9jay5oZXJvX2Jhbm5lcicsXG4gICAgICAgICAgJ3NlY3Rpb24uY2Fyb3VzZWxfYmxvY2suYmFubmVyJyxcbiAgICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5pY29uJyxcbiAgICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5jYXRlZ29yeScsXG4gICAgICAgICAgJ3NlY3Rpb24uZmVhdHVyZV9ibG9jay5mZWF0dXJlcycsXG4gICAgICAgICAgJ3NlY3Rpb24ud29ya2Zsb3dfYmxvY2suc3RhZ2UnLFxuICAgICAgICAgICdzZWN0aW9uLnRlc3RpbW9uaWFsX2Jsb2NrLnRlc3RpbW9uaWFsJyxcbiAgICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbC5hdXRob3InLFxuICAgICAgICBdKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIHBhZ2VFbnRyeSA9IGZhbGxiYWNrUmVzdWx0WzBdPy5bMF0gYXMgUGFnZUVudHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIERlYnVnIGxvZ2dpbmdcbiAgICBpZiAocGFnZUVudHJ5KSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gUGFnZSBcIiR7dGl0bGV9XCIgbG9hZGVkIHdpdGggJHtwYWdlRW50cnkuc2VjdGlvbj8ubGVuZ3RoIHx8IDB9IHNlY3Rpb25zYCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwYWdlRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcGFnZTogJHt0aXRsZX1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBQYWdlIGVudHJ5IGJ5IFVSTFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFnZUJ5VXJsKHVybDogc3RyaW5nKTogUHJvbWlzZTxQYWdlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLlBBR0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCd1cmwnLCB1cmwpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICdoZWFkZXInLFxuICAgICAgICAnaGVhZGVyLmljb24nLFxuICAgICAgICAnc2VjdGlvbi5jYXJvdXNlbF9ibG9jay5iYW5uZXInLFxuICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5pY29uJyxcbiAgICAgICAgJ3NlY3Rpb24uY2F0ZWdvcnlfYmxvY2suY2F0ZWdvcnknLCAgICAgICAgLy8gTmV3IGNhdGVnb3J5IHJlZmVyZW5jZXNcbiAgICAgICAgJ3NlY3Rpb24uZmVhdHVyZV9ibG9jay5mZWF0dXJlcycsXG4gICAgICAgICdzZWN0aW9uLndvcmtmbG93X2Jsb2NrLnN0YWdlJyxcbiAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwnLFxuICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbC5hdXRob3InLFxuICAgICAgXSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgcmV0dXJuIHJlc3VsdFswXT8uWzBdIGFzIFBhZ2VFbnRyeSB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHBhZ2UgYnkgVVJMOiAke3VybH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENhdGVnb3J5IEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhbGwgQ2F0ZWdvcnkgZW50cmllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsQ2F0ZWdvcmllcygpOiBQcm9taXNlPENhdGVnb3J5RW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ0FURUdPUlkpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIHJldHVybiAocmVzdWx0WzBdIHx8IFtdKSBhcyBDYXRlZ29yeUVudHJ5W107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2F0ZWdvcmllcycsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhlYWRlciBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggSGVhZGVyIGVudHJ5IGJ5IHRpdGxlXG4gKiBIZWFkZXIgaXMgYWx3YXlzIGZldGNoZWQgaW4gRW5nbGlzaCBzaW5jZSBpdCBjb250YWlucyBub24tdHJhbnNsYXRhYmxlIFVJIGNvbmZpZ1xuICogQHBhcmFtIHRpdGxlIC0gXCJMYW5kaW5nIEhlYWRlclwiIG9yIFwiQXBwIEhlYWRlclwiXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRIZWFkZXIodGl0bGU6IHN0cmluZyk6IFByb21pc2U8SGVhZGVyRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkhFQURFUilcbiAgICAgIC5RdWVyeSgpXG4gICAgICAud2hlcmUoJ3RpdGxlJywgdGl0bGUpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZSgnaWNvbicpO1xuXG4gICAgLy8gQWx3YXlzIGZldGNoIGhlYWRlciBpbiBFbmdsaXNoIChjb250YWlucyBVSSBjb25maWd1cmF0aW9uLCBub3QgdHJhbnNsYXRlZCBjb250ZW50KVxuICAgIHF1ZXJ5Lmxhbmd1YWdlKCdlbi11cycpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGNvbnN0IGhlYWRlciA9IHJlc3VsdFswXT8uWzBdIGFzIEhlYWRlckVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIEhlYWRlciBcIiR7dGl0bGV9XCIgbG9hZGVkIHdpdGggJHtoZWFkZXIuYWNjZXNzaWJpbGl0eV9sYW5ndWFnZT8ubGVuZ3RoIHx8IDB9IGxhbmd1YWdlc2ApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaGVhZGVyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGhlYWRlcjogJHt0aXRsZX1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBhbGwgSGVhZGVyc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsSGVhZGVycygpOiBQcm9taXNlPEhlYWRlckVudHJ5W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkhFQURFUilcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZSgnaWNvbicpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIEhlYWRlckVudHJ5W107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWxsIGhlYWRlcnMnLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBGb290ZXIgJiBOZXdzbGV0dGVyIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBGb290ZXIgZW50cnkgKHNpbmdsZXRvbilcbiAqIFN1cHBvcnRzIGxvY2FsZSBmb3IgZmV0Y2hpbmcgbG9jYWxpemVkIGNvbnRlbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZvb3Rlcihsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPEZvb3RlckVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRhcmdldExvY2FsZSA9IGxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgXG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkZPT1RFUilcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZSgnaWNvbicpO1xuICAgIFxuICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgbGV0IGZvb3RlciA9IHJlc3VsdFswXT8uWzBdIGFzIEZvb3RlckVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gZW4tdXMgaWYgbm90IGZvdW5kXG4gICAgaWYgKCFmb290ZXIgJiYgdGFyZ2V0TG9jYWxlICE9PSBGQUxMQkFDS19MT0NBTEUpIHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkZPT1RFUilcbiAgICAgICAgLlF1ZXJ5KClcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2ljb24nKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIGZvb3RlciA9IGZhbGxiYWNrUmVzdWx0WzBdPy5bMF0gYXMgRm9vdGVyRW50cnkgfHwgbnVsbDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZvb3RlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmb290ZXInLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBOZXdzbGV0dGVyIGVudHJ5IChzaW5nbGV0b24pXG4gKiBTdXBwb3J0cyBsb2NhbGUgZm9yIGZldGNoaW5nIGxvY2FsaXplZCBjb250ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROZXdzbGV0dGVyKGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8TmV3c2xldHRlckVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRhcmdldExvY2FsZSA9IGxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgXG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLk5FV1NMRVRURVIpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2ljb24nKTtcbiAgICBcbiAgICBxdWVyeS5sYW5ndWFnZSh0YXJnZXRMb2NhbGUpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGxldCBuZXdzbGV0dGVyID0gcmVzdWx0WzBdPy5bMF0gYXMgTmV3c2xldHRlckVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gZW4tdXMgaWYgbm90IGZvdW5kXG4gICAgaWYgKCFuZXdzbGV0dGVyICYmIHRhcmdldExvY2FsZSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICBjb25zdCBmYWxsYmFja1F1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5ORVdTTEVUVEVSKVxuICAgICAgICAuUXVlcnkoKVxuICAgICAgICAuaW5jbHVkZVJlZmVyZW5jZSgnaWNvbicpO1xuICAgICAgZmFsbGJhY2tRdWVyeS5sYW5ndWFnZShGQUxMQkFDS19MT0NBTEUpO1xuICAgICAgXG4gICAgICBjb25zdCBmYWxsYmFja1Jlc3VsdCA9IGF3YWl0IGZhbGxiYWNrUXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgICAgbmV3c2xldHRlciA9IGZhbGxiYWNrUmVzdWx0WzBdPy5bMF0gYXMgTmV3c2xldHRlckVudHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBuZXdzbGV0dGVyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG5ld3NsZXR0ZXInLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEZBUSBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggRkFRIGVudHJ5IChzaW5nbGV0b24pIHdpdGggbmVzdGVkIHJlZmVyZW5jZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZBUSgpOiBQcm9taXNlPEZBUUVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5GQVEpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydpY29uJywgJ2ZhcV9xdWVzdGlvbiddKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBjb25zdCBmYXFFbnRyeSA9IHJlc3VsdFswXT8uWzBdIGFzIEZBUUVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgaWYgKGZhcUVudHJ5KSB7XG4gICAgICBjb25zb2xlLmxvZygnRkFRIEVudHJ5IGZldGNoZWQ6Jywge1xuICAgICAgICB0aXRsZTogZmFxRW50cnkuc2VjdGlvbl90aXRsZSxcbiAgICAgICAgaGFzSWNvbjogISFmYXFFbnRyeS5pY29uLFxuICAgICAgICBmYXFRdWVzdGlvblR5cGU6IEFycmF5LmlzQXJyYXkoZmFxRW50cnkuZmFxX3F1ZXN0aW9uKSA/ICdhcnJheScgOiAnb2JqZWN0JyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFxRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgRkFRJywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBCYW5uZXIgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGFsbCBCYW5uZXIgZW50cmllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsQmFubmVycygpOiBQcm9taXNlPEJhbm5lckVudHJ5W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkJBTk5FUilcbiAgICAgIC5RdWVyeSgpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIEJhbm5lckVudHJ5W107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYmFubmVycycsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRlc3RpbW9uaWFsIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhbGwgVGVzdGltb25pYWwgZW50cmllcyB3aXRoIGF1dGhvciByZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFRlc3RpbW9uaWFscygpOiBQcm9taXNlPFRlc3RpbW9uaWFsRW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuVEVTVElNT05JQUwpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2F1dGhvcicpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIFRlc3RpbW9uaWFsRW50cnlbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0ZXN0aW1vbmlhbHMnLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDb3Vyc2UgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGFsbCBjb3Vyc2VzIHdpdGggYXV0aG9yIHJlZmVyZW5jZVxuICogRmFsbHMgYmFjayB0byBFbmdsaXNoIGlmIG5vIGNvbnRlbnQgZm91bmQgaW4gc2VsZWN0ZWQgbG9jYWxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxDb3Vyc2VzKGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8Q291cnNlRW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRhcmdldExvY2FsZSA9IGxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgXG4gICAgLy8gRmlyc3QgdHJ5IHdpdGggc2VsZWN0ZWQgbG9jYWxlXG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2F1dGhvcicsICdtb2R1bGVzJ10pO1xuICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGxldCBjb3Vyc2VzID0gKHJlc3VsdFswXSB8fCBbXSkgYXMgQ291cnNlRW50cnlbXTtcbiAgICBcbiAgICAvLyBJZiBubyBjb3Vyc2VzIGZvdW5kIGFuZCB3ZSdyZSBub3QgYWxyZWFkeSB1c2luZyBmYWxsYmFjaywgdHJ5IGZhbGxiYWNrIGxvY2FsZVxuICAgIGlmIChjb3Vyc2VzLmxlbmd0aCA9PT0gMCAmJiB0YXJnZXRMb2NhbGUgIT09IEZBTExCQUNLX0xPQ0FMRSkge1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIE5vIGNvdXJzZXMgZm91bmQgaW4gJHt0YXJnZXRMb2NhbGV9LCBmYWxsaW5nIGJhY2sgdG8gJHtGQUxMQkFDS19MT0NBTEV9YCk7XG4gICAgICBjb25zdCBmYWxsYmFja1F1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAgIC5RdWVyeSgpXG4gICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnYXV0aG9yJywgJ21vZHVsZXMnXSk7XG4gICAgICBmYWxsYmFja1F1ZXJ5Lmxhbmd1YWdlKEZBTExCQUNLX0xPQ0FMRSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmVzdWx0ID0gYXdhaXQgZmFsbGJhY2tRdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgICBjb3Vyc2VzID0gKGZhbGxiYWNrUmVzdWx0WzBdIHx8IFtdKSBhcyBDb3Vyc2VFbnRyeVtdO1xuICAgIH1cbiAgICBcbiAgICAvLyBSZXNvbHZlIGF1dGhvciByZWZlcmVuY2VzIGZvciBhbGwgY291cnNlc1xuICAgIGNvbnN0IHJlc29sdmVkQ291cnNlcyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgICAgY291cnNlcy5tYXAoY291cnNlID0+IHJlc29sdmVBdXRob3JSZWZlcmVuY2VzKGNvdXJzZSkpXG4gICAgKTtcbiAgICBcbiAgICByZXR1cm4gcmVzb2x2ZWRDb3Vyc2VzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvdXJzZXMnLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggYXV0aG9yIGJ5IFVJRCAtIGFsd2F5cyBmZXRjaGVzIGZyb20gZGVmYXVsdCBsb2NhbGUgc2luY2UgYXV0aG9ycyBhcmUgbm90IGxvY2FsaXplZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBdXRob3JCeVVpZCh1aWQ6IHN0cmluZyk6IFByb21pc2U8QXV0aG9yRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkFVVEhPUilcbiAgICAgIC5FbnRyeSh1aWQpO1xuICAgIC8vIEFsd2F5cyBmZXRjaCBhdXRob3JzIGluIGZhbGxiYWNrIGxvY2FsZSBzaW5jZSBhdXRob3IgZGF0YSAobmFtZSwgYmlvKSBpcyBub24tbG9jYWxpemFibGVcbiAgICBxdWVyeS5sYW5ndWFnZShGQUxMQkFDS19MT0NBTEUpO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZldGNoKCk7XG4gICAgcmV0dXJuIHJlc3VsdCBhcyBBdXRob3JFbnRyeTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBhdXRob3IgYnkgVUlEOiAke3VpZH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVzb2x2ZSBhdXRob3IgcmVmZXJlbmNlcyB0aGF0IG1heSBub3QgYmUgZnVsbHkgcG9wdWxhdGVkXG4gKiBXaGVuIGZldGNoaW5nIGxvY2FsaXplZCBjb250ZW50LCByZWZlcmVuY2VzIHRvIG5vbi1sb2NhbGl6ZWQgZW50cmllcyBtYXkgbm90IHJlc29sdmVcbiAqIFRoaXMgZnVuY3Rpb24gYWx3YXlzIGZldGNoZXMgYXV0aG9yIGRhdGEgZnJvbSB0aGUgZmFsbGJhY2sgbG9jYWxlIHRvIGVuc3VyZSBjb25zaXN0ZW5jeVxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQXV0aG9yUmVmZXJlbmNlcyhjb3Vyc2U6IENvdXJzZUVudHJ5KTogUHJvbWlzZTxDb3Vyc2VFbnRyeT4ge1xuICBpZiAoIWNvdXJzZS5hdXRob3IpIHJldHVybiBjb3Vyc2U7XG4gIFxuICBjb25zdCBhdXRob3JzID0gQXJyYXkuaXNBcnJheShjb3Vyc2UuYXV0aG9yKSA/IGNvdXJzZS5hdXRob3IgOiBbY291cnNlLmF1dGhvcl07XG4gIGNvbnN0IHJlc29sdmVkQXV0aG9yczogQXV0aG9yRW50cnlbXSA9IFtdO1xuICBcbiAgZm9yIChjb25zdCBhdXRob3Igb2YgYXV0aG9ycykge1xuICAgIC8vIEFsd2F5cyBmZXRjaCB0aGUgZnVsbCBhdXRob3IgZGF0YSBmcm9tIGZhbGxiYWNrIGxvY2FsZSB0byBlbnN1cmUgd2UgaGF2ZSBhbGwgZmllbGRzXG4gICAgLy8gVGhpcyBpcyBiZWNhdXNlIGF1dGhvciBkYXRhIChuYW1lLCBiaW8sIHNvY2lhbCBsaW5rcykgaXMgbWFya2VkIGFzIG5vbi1sb2NhbGl6YWJsZVxuICAgIC8vIGJ1dCB3aGVuIGZldGNoaW5nIGNvdXJzZSBpbiBhIGRpZmZlcmVudCBsb2NhbGUsIHRoZSByZWZlcmVuY2UgbWF5IG5vdCByZXNvbHZlIHByb3Blcmx5XG4gICAgaWYgKGF1dGhvci51aWQpIHtcbiAgICAgIC8vIEFsd2F5cyBmZXRjaCBmcmVzaCB0byBlbnN1cmUgd2UgZ2V0IGNvbXBsZXRlIGRhdGFcbiAgICAgIGNvbnN0IGZ1bGxBdXRob3IgPSBhd2FpdCBnZXRBdXRob3JCeVVpZChhdXRob3IudWlkKTtcbiAgICAgIGlmIChmdWxsQXV0aG9yKSB7XG4gICAgICAgIHJlc29sdmVkQXV0aG9ycy5wdXNoKGZ1bGxBdXRob3IpO1xuICAgICAgfSBlbHNlIGlmIChhdXRob3IudGl0bGUpIHtcbiAgICAgICAgLy8gRmFsbGJhY2s6IGlmIGZldGNoIGZhaWxzIGJ1dCB3ZSBoYXZlIHBhcnRpYWwgZGF0YSwgdXNlIGl0XG4gICAgICAgIHJlc29sdmVkQXV0aG9ycy5wdXNoKGF1dGhvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhdXRob3IudGl0bGUpIHtcbiAgICAgIC8vIE5vIFVJRCBidXQgaGFzIHRpdGxlIC0gdXNlIGFzIGlzXG4gICAgICByZXNvbHZlZEF1dGhvcnMucHVzaChhdXRob3IpO1xuICAgIH1cbiAgfVxuICBcbiAgY291cnNlLmF1dGhvciA9IHJlc29sdmVkQXV0aG9ycy5sZW5ndGggPiAwID8gcmVzb2x2ZWRBdXRob3JzIDogdW5kZWZpbmVkO1xuICByZXR1cm4gY291cnNlO1xufVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIGNvdXJzZSBieSBzbHVnIHdpdGggYWxsIG5lc3RlZCByZWZlcmVuY2VzXG4gKiBGYWxscyBiYWNrIHRvIEVuZ2xpc2ggaWYgbm8gY29udGVudCBmb3VuZCBpbiBzZWxlY3RlZCBsb2NhbGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdXJzZUJ5U2x1ZyhzbHVnOiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8Q291cnNlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBcbiAgICAvLyBGaXJzdCB0cnkgd2l0aCBzZWxlY3RlZCBsb2NhbGVcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ09VUlNFKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC53aGVyZSgnc2x1ZycsIHNsdWcpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICdhdXRob3InLFxuICAgICAgICAnbW9kdWxlcycsXG4gICAgICAgICdtb2R1bGVzLmxlc3NvbnMnXG4gICAgICBdKTtcbiAgICBxdWVyeS5sYW5ndWFnZSh0YXJnZXRMb2NhbGUpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGxldCBjb3Vyc2UgPSByZXN1bHRbMF0/LlswXSBhcyBDb3Vyc2VFbnRyeSB8fCBudWxsO1xuICAgIFxuICAgIC8vIElmIG5vIGNvdXJzZSBmb3VuZCBhbmQgd2UncmUgbm90IGFscmVhZHkgdXNpbmcgZmFsbGJhY2ssIHRyeSBmYWxsYmFjayBsb2NhbGVcbiAgICBpZiAoIWNvdXJzZSAmJiB0YXJnZXRMb2NhbGUgIT09IEZBTExCQUNLX0xPQ0FMRSkge1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIENvdXJzZSBub3QgZm91bmQgaW4gJHt0YXJnZXRMb2NhbGV9LCBmYWxsaW5nIGJhY2sgdG8gJHtGQUxMQkFDS19MT0NBTEV9YCk7XG4gICAgICBjb25zdCBmYWxsYmFja1F1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAgIC5RdWVyeSgpXG4gICAgICAgIC53aGVyZSgnc2x1ZycsIHNsdWcpXG4gICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgICAnYXV0aG9yJyxcbiAgICAgICAgICAnbW9kdWxlcycsXG4gICAgICAgICAgJ21vZHVsZXMubGVzc29ucydcbiAgICAgICAgXSk7XG4gICAgICBmYWxsYmFja1F1ZXJ5Lmxhbmd1YWdlKEZBTExCQUNLX0xPQ0FMRSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmVzdWx0ID0gYXdhaXQgZmFsbGJhY2tRdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgICBjb3Vyc2UgPSBmYWxsYmFja1Jlc3VsdFswXT8uWzBdIGFzIENvdXJzZUVudHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSBhdXRob3IgcmVmZXJlbmNlcyBhcmUgZnVsbHkgcmVzb2x2ZWRcbiAgICBpZiAoY291cnNlKSB7XG4gICAgICBjb3Vyc2UgPSBhd2FpdCByZXNvbHZlQXV0aG9yUmVmZXJlbmNlcyhjb3Vyc2UpO1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIENvdXJzZSBcIiR7Y291cnNlLnRpdGxlfVwiIGxvYWRlZCB3aXRoICR7QXJyYXkuaXNBcnJheShjb3Vyc2UubW9kdWxlcykgPyBjb3Vyc2UubW9kdWxlcy5sZW5ndGggOiBjb3Vyc2UubW9kdWxlcyA/IDEgOiAwfSBtb2R1bGVzYCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb3Vyc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgY291cnNlIGJ5IHNsdWc6ICR7c2x1Z31gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBhIHNpbmdsZSBjb3Vyc2UgYnkgVUlEIHdpdGggYWxsIG5lc3RlZCByZWZlcmVuY2VzXG4gKiBGYWxscyBiYWNrIHRvIEVuZ2xpc2ggaWYgbm8gY29udGVudCBmb3VuZCBpbiBzZWxlY3RlZCBsb2NhbGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldENvdXJzZUJ5VWlkKHVpZDogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPENvdXJzZUVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRhcmdldExvY2FsZSA9IGxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgbGV0IGNvdXJzZTogQ291cnNlRW50cnkgfCBudWxsID0gbnVsbDtcbiAgICBcbiAgICAvLyBGaXJzdCB0cnkgd2l0aCBzZWxlY3RlZCBsb2NhbGVcbiAgICB0cnkge1xuICAgICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgICAgLkVudHJ5KHVpZClcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAgICdhdXRob3InLFxuICAgICAgICAgICdtb2R1bGVzJyxcbiAgICAgICAgICAnbW9kdWxlcy5sZXNzb25zJ1xuICAgICAgICBdKTtcbiAgICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG4gICAgICBcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZldGNoKCk7XG4gICAgICBjb3Vyc2UgPSByZXN1bHQgYXMgQ291cnNlRW50cnk7XG4gICAgfSBjYXRjaCAobG9jYWxlRXJyb3IpIHtcbiAgICAgIC8vIElmIGxvY2FsZSBmZXRjaCBmYWlscyBhbmQgd2UncmUgbm90IGFscmVhZHkgdXNpbmcgZmFsbGJhY2ssIHRyeSBmYWxsYmFja1xuICAgICAgaWYgKHRhcmdldExvY2FsZSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBDb3Vyc2UgVUlEICR7dWlkfSBub3QgZm91bmQgaW4gJHt0YXJnZXRMb2NhbGV9LCBmYWxsaW5nIGJhY2sgdG8gJHtGQUxMQkFDS19MT0NBTEV9YCk7XG4gICAgICAgIGNvbnN0IGZhbGxiYWNrUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgICAgICAuRW50cnkodWlkKVxuICAgICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgICAgICdhdXRob3InLFxuICAgICAgICAgICAgJ21vZHVsZXMnLFxuICAgICAgICAgICAgJ21vZHVsZXMubGVzc29ucydcbiAgICAgICAgICBdKTtcbiAgICAgICAgZmFsbGJhY2tRdWVyeS5sYW5ndWFnZShGQUxMQkFDS19MT0NBTEUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZldGNoKCk7XG4gICAgICAgIGNvdXJzZSA9IGZhbGxiYWNrUmVzdWx0IGFzIENvdXJzZUVudHJ5O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbG9jYWxlRXJyb3I7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8vIEVuc3VyZSBhdXRob3IgcmVmZXJlbmNlcyBhcmUgZnVsbHkgcmVzb2x2ZWRcbiAgICBpZiAoY291cnNlKSB7XG4gICAgICBjb3Vyc2UgPSBhd2FpdCByZXNvbHZlQXV0aG9yUmVmZXJlbmNlcyhjb3Vyc2UpO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY291cnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNvdXJzZSBieSBVSUQ6ICR7dWlkfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTW9kdWxlIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhIHNpbmdsZSBtb2R1bGUgYnkgVUlEIHdpdGggbGVzc29uc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TW9kdWxlQnlVaWQodWlkOiBzdHJpbmcpOiBQcm9taXNlPE1vZHVsZUVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuTU9EVUxFKVxuICAgICAgLkVudHJ5KHVpZClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnbGVzc29ucyddKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmV0Y2goKTtcbiAgICByZXR1cm4gcmVzdWx0IGFzIE1vZHVsZUVudHJ5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIG1vZHVsZSBieSBVSUQ6ICR7dWlkfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gTGVzc29uIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhIHNpbmdsZSBsZXNzb24gYnkgVUlEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMZXNzb25CeVVpZCh1aWQ6IHN0cmluZyk6IFByb21pc2U8TGVzc29uRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5MRVNTT04pXG4gICAgICAuRW50cnkodWlkKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmV0Y2goKTtcbiAgICByZXR1cm4gcmVzdWx0IGFzIExlc3NvbkVudHJ5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGxlc3NvbiBieSBVSUQ6ICR7dWlkfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIGxlc3NvbiBieSBzbHVnXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMZXNzb25CeVNsdWcoc2x1Zzogc3RyaW5nKTogUHJvbWlzZTxMZXNzb25FbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuTEVTU09OKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC53aGVyZSgnc2x1ZycsIHNsdWcpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIHJldHVybiByZXN1bHRbMF0/LlswXSBhcyBMZXNzb25FbnRyeSB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGxlc3NvbiBieSBzbHVnOiAke3NsdWd9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggY291cnNlIGRhdGEgZm9yIGEgZ2l2ZW4gbGVzc29uICh0byBnZXQgY291cnNlIGNvbnRleHQpXG4gKiBSZXR1cm5zIHRoZSBjb3Vyc2UgdGhhdCBjb250YWlucyB0aGlzIGxlc3NvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlQnlMZXNzb25VaWQobGVzc29uVWlkOiBzdHJpbmcpOiBQcm9taXNlPENvdXJzZUVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIC8vIEZpcnN0LCBmaW5kIHdoaWNoIG1vZHVsZSBjb250YWlucyB0aGlzIGxlc3NvblxuICAgIGNvbnN0IG1vZHVsZXNSZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLk1PRFVMRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2xlc3NvbnMnXSlcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZpbmQoKTtcbiAgICBcbiAgICBjb25zdCBtb2R1bGVzID0gKG1vZHVsZXNSZXN1bHRbMF0gfHwgW10pIGFzIE1vZHVsZUVudHJ5W107XG4gICAgbGV0IHRhcmdldE1vZHVsZVVpZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgXG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgY29uc3QgbGVzc29ucyA9IEFycmF5LmlzQXJyYXkobW9kdWxlLmxlc3NvbnMpID8gbW9kdWxlLmxlc3NvbnMgOiBtb2R1bGUubGVzc29ucyA/IFttb2R1bGUubGVzc29uc10gOiBbXTtcbiAgICAgIGlmIChsZXNzb25zLnNvbWUobGVzc29uID0+IGxlc3Nvbi51aWQgPT09IGxlc3NvblVpZCkpIHtcbiAgICAgICAgdGFyZ2V0TW9kdWxlVWlkID0gbW9kdWxlLnVpZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICghdGFyZ2V0TW9kdWxlVWlkKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICAvLyBOb3cgZmluZCB0aGUgY291cnNlIHRoYXQgY29udGFpbnMgdGhpcyBtb2R1bGVcbiAgICBjb25zdCBjb3Vyc2VzUmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydhdXRob3InLCAnbW9kdWxlcycsICdtb2R1bGVzLmxlc3NvbnMnXSlcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZpbmQoKTtcbiAgICBcbiAgICBjb25zdCBjb3Vyc2VzID0gKGNvdXJzZXNSZXN1bHRbMF0gfHwgW10pIGFzIENvdXJzZUVudHJ5W107XG4gICAgXG4gICAgZm9yIChjb25zdCBjb3Vyc2Ugb2YgY291cnNlcykge1xuICAgICAgY29uc3QgY291cnNlTW9kdWxlcyA9IEFycmF5LmlzQXJyYXkoY291cnNlLm1vZHVsZXMpID8gY291cnNlLm1vZHVsZXMgOiBjb3Vyc2UubW9kdWxlcyA/IFtjb3Vyc2UubW9kdWxlc10gOiBbXTtcbiAgICAgIGlmIChjb3Vyc2VNb2R1bGVzLnNvbWUobSA9PiBtLnVpZCA9PT0gdGFyZ2V0TW9kdWxlVWlkKSkge1xuICAgICAgICByZXR1cm4gY291cnNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjb3Vyc2UgYnkgbGVzc29uIFVJRDogJHtsZXNzb25VaWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBPbmJvYXJkaW5nIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhbGwgb25ib2FyZGluZyBzdGVwc1xuICogUmV0dXJucyBzdGVwcyBzb3J0ZWQgYnkgY3VycmVudF9zdGVwXG4gKiBUcmllcyBtdWx0aXBsZSBjb250ZW50IHR5cGUgbmFtZXMgaW4gY2FzZSB0aGUgZXhhY3QgbmFtZSBkaWZmZXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxPbmJvYXJkaW5nU3RlcHMoKTogUHJvbWlzZTxPbmJvYXJkaW5nQmxvY2tFbnRyeVtdPiB7XG4gIC8vIFRyeSBkaWZmZXJlbnQgcG9zc2libGUgY29udGVudCB0eXBlIG5hbWVzXG4gIGNvbnN0IHBvc3NpYmxlQ29udGVudFR5cGVzID0gW1xuICAgICdvbmJvYXJkaW5nX2Jsb2NrJyxcbiAgICAnb25ib2FyZGluZycsXG4gICAgJ29uYm9hcmRpbmdfc3RlcCcsXG4gICAgJ29uYm9hcmRpbmdfc3RlcHMnLFxuICAgICdtb2R1bGFyX3NlY3Rpb24nLCAgLy8gTWF5YmUgc3RvcmVkIGFzIG1vZHVsYXIgc2VjdGlvbnMgd2l0aCBzcGVjaWZpYyBwYXR0ZXJuXG4gIF07XG5cbiAgZm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBwb3NzaWJsZUNvbnRlbnRUeXBlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBiYXNlUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZSkuUXVlcnkoKTtcbiAgICAgIFxuICAgICAgLy8gSWYgaXQncyBtb2R1bGFyX3NlY3Rpb24sIGZpbHRlciBmb3Igb25ib2FyZGluZyBlbnRyaWVzXG4gICAgICBpZiAoY29udGVudFR5cGUgPT09ICdtb2R1bGFyX3NlY3Rpb24nKSB7XG4gICAgICAgIGJhc2VRdWVyeS53aGVyZSgndGl0bGUnLCAnT25ib2FyZGluZyBTdGVwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb25ib2FyZGluZy1zcGVjaWZpYyBjb250ZW50IHR5cGVzLCBpbmNsdWRlIG9wdGlvbiByZWZlcmVuY2VzXG4gICAgICAgIGJhc2VRdWVyeS5pbmNsdWRlUmVmZXJlbmNlKCdvcHRpb24nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgYmFzZVF1ZXJ5LmFzY2VuZGluZygnY3VycmVudF9zdGVwJyk7ICAvLyBTb3J0IGJ5IHN0ZXAgbnVtYmVyXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhc2VRdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gKHJlc3VsdFswXSB8fCBbXSkgYXMgYW55W107XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBBdHRlbXB0ZWQgJHtjb250ZW50VHlwZX06IEZvdW5kICR7ZW50cmllcy5sZW5ndGh9IGVudHJpZXNgKTtcbiAgICAgIFxuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBGaWx0ZXIgYW5kIHRyYW5zZm9ybSBlbnRyaWVzXG4gICAgICAgIGNvbnN0IG9uYm9hcmRpbmdFbnRyaWVzOiBPbmJvYXJkaW5nQmxvY2tFbnRyeVtdID0gZW50cmllc1xuICAgICAgICAgIC5maWx0ZXIoKGVudHJ5OiBhbnkpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGhhcyBvbmJvYXJkaW5nLXJlbGF0ZWQgZmllbGRzXG4gICAgICAgICAgICByZXR1cm4gZW50cnkuY3VycmVudF9zdGVwICE9PSB1bmRlZmluZWQgfHwgXG4gICAgICAgICAgICAgICAgICAgZW50cnkubGFiZWxfdGV4dCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgZW50cnkudGl0bGU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ29uYm9hcmRpbmcnKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tYXAoKGVudHJ5OiBhbnkpID0+IHtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0byBPbmJvYXJkaW5nQmxvY2tFbnRyeSBmb3JtYXRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHVpZDogZW50cnkudWlkIHx8IGVudHJ5Ll9pZCB8fCAnJyxcbiAgICAgICAgICAgICAgdGl0bGU6IGVudHJ5LnRpdGxlLFxuICAgICAgICAgICAgICBjdXJyZW50X3N0ZXA6IGVudHJ5LmN1cnJlbnRfc3RlcCB8fCBwYXJzZUludChlbnRyeS50aXRsZT8ubWF0Y2goL1xcZCsvKT8uWzBdIHx8ICcxJyksXG4gICAgICAgICAgICAgIHRvdGFsX3N0ZXBzOiBlbnRyeS50b3RhbF9zdGVwcyB8fCA1LFxuICAgICAgICAgICAgICBsYWJlbF90ZXh0OiBlbnRyeS5sYWJlbF90ZXh0IHx8IGVudHJ5LnRpdGxlIHx8ICcnLFxuICAgICAgICAgICAgICBkaXNwbGF5X3R5cGU6IGVudHJ5LmRpc3BsYXlfdHlwZSB8fCAnQ2FyZCBHcmlkJyxcbiAgICAgICAgICAgICAgb3B0aW9uOiBlbnRyeS5vcHRpb24gfHwgW10sXG4gICAgICAgICAgICAgIGJhY2tfYnV0dG9uX3RleHQ6IGVudHJ5LmJhY2tfYnV0dG9uX3RleHQgfHwgJ0JhY2snLFxuICAgICAgICAgICAgICBuZXh0X2J1dHRvbl90ZXh0OiBlbnRyeS5uZXh0X2J1dHRvbl90ZXh0IHx8ICdDb250aW51ZScsXG4gICAgICAgICAgICB9IGFzIE9uYm9hcmRpbmdCbG9ja0VudHJ5O1xuICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKG9uYm9hcmRpbmdFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0NNU10gU3VjY2Vzc2Z1bGx5IGZldGNoZWQgJHtvbmJvYXJkaW5nRW50cmllcy5sZW5ndGh9IG9uYm9hcmRpbmcgc3RlcHMgZnJvbSAke2NvbnRlbnRUeXBlfWApO1xuICAgICAgICAgIHJldHVybiBvbmJvYXJkaW5nRW50cmllcy5zb3J0KChhLCBiKSA9PiBhLmN1cnJlbnRfc3RlcCAtIGIuY3VycmVudF9zdGVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIC8vIExvZyB0aGUgZXJyb3IgYnV0IGNvbnRpbnVlIHRyeWluZyBvdGhlciBjb250ZW50IHR5cGVzXG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gQ29udGVudCB0eXBlICR7Y29udGVudFR5cGV9IGZhaWxlZDpgLCBlcnJvci5tZXNzYWdlIHx8IGVycm9yKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIGNvbnRlbnQgdHlwZSBmb3VuZCwgdHJ5IHNlYXJjaGluZyBtb2R1bGFyX3NlY3Rpb24gZm9yIGFueSBvbmJvYXJkaW5nLXJlbGF0ZWQgZW50cmllc1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5QQUdFKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnc2VjdGlvbiddKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgY29uc3QgcGFnZXMgPSAocmVzdWx0WzBdIHx8IFtdKSBhcyBQYWdlRW50cnlbXTtcbiAgICBcbiAgICAvLyBMb29rIGZvciBwYWdlcyB3aXRoIFwiT25ib2FyZGluZ1wiIGluIHRpdGxlXG4gICAgY29uc3Qgb25ib2FyZGluZ1BhZ2VzID0gcGFnZXMuZmlsdGVyKHBhZ2UgPT4gXG4gICAgICBwYWdlLnRpdGxlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdvbmJvYXJkaW5nJylcbiAgICApO1xuICAgIFxuICAgIGlmIChvbmJvYXJkaW5nUGFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1tDTVNdIEZvdW5kIG9uYm9hcmRpbmcgcGFnZShzKSwgYnV0IG5lZWQgcHJvcGVyIGNvbnRlbnQgdHlwZSBzdHJ1Y3R1cmUnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIGZvciBvbmJvYXJkaW5nIHBhZ2U6JywgZXJyb3IpO1xuICB9XG5cbiAgY29uc29sZS53YXJuKCdbQ01TXSBObyBvbmJvYXJkaW5nIGNvbnRlbnQgdHlwZSBmb3VuZC4gUGxlYXNlIGNoZWNrOicpO1xuICBjb25zb2xlLndhcm4oJzEuIENvbnRlbnQgdHlwZSBuYW1lIGluIENvbnRlbnRzdGFjayAobWlnaHQgYmUgZGlmZmVyZW50KScpO1xuICBjb25zb2xlLndhcm4oJzIuIEVudHJpZXMgYXJlIHB1Ymxpc2hlZCcpO1xuICBjb25zb2xlLndhcm4oJzMuIEFQSSBrZXlzIGFuZCBlbnZpcm9ubWVudCBhcmUgY29ycmVjdCcpO1xuICByZXR1cm4gW107XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBBdXRoIEJyYW5kaW5nIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBBdXRoIEJyYW5kaW5nIGVudHJ5IGJ5IHBhZ2UgdHlwZSAobG9naW4gb3Igc2lnbnVwKVxuICogTWF0Y2hlcyBDb250ZW50c3RhY2sgc2NoZW1hOiBwYWdlX3R5cGUgaXMgXCJTaWduIEluXCIgb3IgXCJTaWduIFVwXCJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhCcmFuZGluZyhwYWdlVHlwZTogJ2xvZ2luJyB8ICdzaWdudXAnKTogUHJvbWlzZTxBdXRoQnJhbmRpbmdFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICAvLyBDb252ZXJ0IGxvd2VyY2FzZSB0byBDb250ZW50c3RhY2sgZm9ybWF0XG4gICAgY29uc3QgcGFnZVR5cGVWYWx1ZSA9IHBhZ2VUeXBlID09PSAnbG9naW4nID8gJ1NpZ24gSW4nIDogJ1NpZ24gVXAnO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5BVVRIX0JSQU5ESU5HKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC53aGVyZSgncGFnZV90eXBlJywgcGFnZVR5cGVWYWx1ZSlcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnc3RhdHMnXSk7ICAvLyBzdGF0cyBpcyByZWZlcmVuY2UgdG8gaWNvbiBjb250ZW50IHR5cGVcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBjb25zdCBlbnRyaWVzID0gKHJlc3VsdFswXSB8fCBbXSkgYXMgYW55W107XG4gICAgXG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgICAgXG4gICAgICAvLyBMb2cgZm9yIGRlYnVnZ2luZ1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIEF1dGggYnJhbmRpbmcgZW50cnkgZm9yICR7cGFnZVR5cGV9OmAsIHtcbiAgICAgICAgaGVhZGxpbmU6IGVudHJ5LmhlYWRsaW5lLFxuICAgICAgICBzdWJ0aXRsZTogZW50cnkuc3VidGl0bGUsXG4gICAgICAgIGJyYW5kaW5nX2NvbnRlbnQ6IGVudHJ5LmJyYW5kaW5nX2NvbnRlbnQsXG4gICAgICAgIHN0YXRzOiBlbnRyeS5zdGF0cyxcbiAgICAgICAgc3RhdHNUeXBlOiBBcnJheS5pc0FycmF5KGVudHJ5LnN0YXRzKSA/ICdhcnJheScgOiB0eXBlb2YgZW50cnkuc3RhdHMsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdWlkOiBlbnRyeS51aWQgfHwgZW50cnkuX2lkIHx8ICcnLFxuICAgICAgICB0aXRsZTogZW50cnkudGl0bGUgfHwgJycsXG4gICAgICAgIHBhZ2VfdHlwZTogZW50cnkucGFnZV90eXBlIHx8IHBhZ2VUeXBlVmFsdWUsXG4gICAgICAgIGhlYWRsaW5lOiBlbnRyeS5oZWFkbGluZSxcbiAgICAgICAgc3VidGl0bGU6IGVudHJ5LnN1YnRpdGxlLCAgLy8gRmllbGQgbmFtZSBpcyBcInN1YnRpdGxlXCIgbm90IFwiZGVzY3JpcHRpb25cIlxuICAgICAgICBicmFuZGluZ19jb250ZW50OiBlbnRyeS5icmFuZGluZ19jb250ZW50LCAgLy8gUmljaCB0ZXh0IGNvbnRlbnRcbiAgICAgICAgc3RhdHM6IGVudHJ5LnN0YXRzLCAgLy8gQ2FuIGJlIHNpbmdsZSBJY29uRW50cnkgb3IgYXJyYXkgb2YgSWNvbkVudHJ5IChzaG91bGQgYmUgZXhwYW5kZWQgYnkgaW5jbHVkZVJlZmVyZW5jZSlcbiAgICAgICAgYmFja2dyb3VuZF9pbWFnZTogZW50cnkuYmFja2dyb3VuZF9pbWFnZSxcbiAgICAgIH0gYXMgQXV0aEJyYW5kaW5nRW50cnk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGF1dGggYnJhbmRpbmcgZm9yICR7cGFnZVR5cGV9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIFN0YWNrIGZvciBhZHZhbmNlZCB1c2FnZVxuZXhwb3J0IHsgU3RhY2sgfTtcbiJdLCJuYW1lcyI6WyJDb250ZW50c3RhY2siLCJTdGFjayIsImFwaV9rZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQ09OVEVOVFNUQUNLX0FQSV9LRVkiLCJDT05URU5UU1RBQ0tfQVBJX0tFWSIsImRlbGl2ZXJ5X3Rva2VuIiwiTkVYVF9QVUJMSUNfQ09OVEVOVFNUQUNLX0RFTElWRVJZX1RPS0VOIiwiQ09OVEVOVFNUQUNLX0RFTElWRVJZX1RPS0VOIiwiZW52aXJvbm1lbnQiLCJORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfRU5WSVJPTk1FTlQiLCJDT05URU5UU1RBQ0tfRU5WSVJPTk1FTlQiLCJicmFuY2giLCJORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfQlJBTkNIIiwiQ09OVEVOVFNUQUNLX0JSQU5DSCIsIkNPTlRFTlRfVFlQRVMiLCJQQUdFIiwiQkFOTkVSIiwiSEVBREVSIiwiRk9PVEVSIiwiTkVXU0xFVFRFUiIsIklDT04iLCJGQVEiLCJGQVFfUVVFU1RJT04iLCJURVNUSU1PTklBTCIsIkFVVEhPUiIsIkNPVVJTRSIsIk1PRFVMRSIsIkxFU1NPTiIsIkNBVEVHT1JZIiwiQ0FURUdPUllfQkxPQ0siLCJJTlNUUlVDVE9SIiwiT05CT0FSRElORyIsIkFVVEhfQlJBTkRJTkciLCJnZXRDdXJyZW50TG9jYWxlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkZBTExCQUNLX0xPQ0FMRSIsImdldEVudHJ5IiwiY29udGVudFR5cGUiLCJlbnRyeVVpZCIsInJlZmVyZW5jZUZpZWxkcyIsImxvY2FsZSIsInF1ZXJ5IiwiQ29udGVudFR5cGUiLCJFbnRyeSIsInRhcmdldExvY2FsZSIsImxhbmd1YWdlIiwiZm9yRWFjaCIsImZpZWxkIiwiaW5jbHVkZVJlZmVyZW5jZSIsInJlc3VsdCIsInRvSlNPTiIsImZldGNoIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0RW50cmllcyIsIm9wdGlvbnMiLCJRdWVyeSIsImxpbWl0Iiwic2tpcCIsIm9yZGVyQnkiLCJvcmRlckRpcmVjdGlvbiIsImRlc2NlbmRpbmciLCJhc2NlbmRpbmciLCJ3aGVyZSIsIk9iamVjdCIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsImZpbmQiLCJnZXRFbnRyeUJ5VXJsIiwidXJsIiwiZ2V0UGFnZSIsInRpdGxlIiwicGFnZUVudHJ5IiwiZmFsbGJhY2tSZXN1bHQiLCJsb2ciLCJmYWxsYmFja1F1ZXJ5Iiwic2VjdGlvbiIsImxlbmd0aCIsImdldFBhZ2VCeVVybCIsImdldEFsbENhdGVnb3JpZXMiLCJnZXRIZWFkZXIiLCJoZWFkZXIiLCJhY2Nlc3NpYmlsaXR5X2xhbmd1YWdlIiwiZ2V0QWxsSGVhZGVycyIsImdldEZvb3RlciIsImZvb3RlciIsImdldE5ld3NsZXR0ZXIiLCJuZXdzbGV0dGVyIiwiZ2V0RkFRIiwiZmFxRW50cnkiLCJzZWN0aW9uX3RpdGxlIiwiaGFzSWNvbiIsImljb24iLCJmYXFRdWVzdGlvblR5cGUiLCJBcnJheSIsImlzQXJyYXkiLCJmYXFfcXVlc3Rpb24iLCJnZXRBbGxCYW5uZXJzIiwiZ2V0QWxsVGVzdGltb25pYWxzIiwiZ2V0QWxsQ291cnNlcyIsImNvdXJzZXMiLCJyZXNvbHZlZENvdXJzZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiY291cnNlIiwicmVzb2x2ZUF1dGhvclJlZmVyZW5jZXMiLCJnZXRBdXRob3JCeVVpZCIsInVpZCIsImF1dGhvciIsImF1dGhvcnMiLCJyZXNvbHZlZEF1dGhvcnMiLCJmdWxsQXV0aG9yIiwicHVzaCIsInVuZGVmaW5lZCIsImdldENvdXJzZUJ5U2x1ZyIsInNsdWciLCJtb2R1bGVzIiwiZ2V0Q291cnNlQnlVaWQiLCJsb2NhbGVFcnJvciIsImdldE1vZHVsZUJ5VWlkIiwiZ2V0TGVzc29uQnlVaWQiLCJnZXRMZXNzb25CeVNsdWciLCJnZXRDb3Vyc2VCeUxlc3NvblVpZCIsImxlc3NvblVpZCIsIm1vZHVsZXNSZXN1bHQiLCJ0YXJnZXRNb2R1bGVVaWQiLCJtb2R1bGUiLCJsZXNzb25zIiwic29tZSIsImxlc3NvbiIsImNvdXJzZXNSZXN1bHQiLCJjb3Vyc2VNb2R1bGVzIiwibSIsImdldEFsbE9uYm9hcmRpbmdTdGVwcyIsInBvc3NpYmxlQ29udGVudFR5cGVzIiwiYmFzZVF1ZXJ5Iiwib25ib2FyZGluZ0VudHJpZXMiLCJmaWx0ZXIiLCJlbnRyeSIsImN1cnJlbnRfc3RlcCIsImxhYmVsX3RleHQiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwiX2lkIiwicGFyc2VJbnQiLCJtYXRjaCIsInRvdGFsX3N0ZXBzIiwiZGlzcGxheV90eXBlIiwib3B0aW9uIiwiYmFja19idXR0b25fdGV4dCIsIm5leHRfYnV0dG9uX3RleHQiLCJzb3J0IiwiYSIsImIiLCJtZXNzYWdlIiwicGFnZXMiLCJvbmJvYXJkaW5nUGFnZXMiLCJwYWdlIiwid2FybiIsImdldEF1dGhCcmFuZGluZyIsInBhZ2VUeXBlIiwicGFnZVR5cGVWYWx1ZSIsImhlYWRsaW5lIiwic3VidGl0bGUiLCJicmFuZGluZ19jb250ZW50Iiwic3RhdHMiLCJzdGF0c1R5cGUiLCJwYWdlX3R5cGUiLCJiYWNrZ3JvdW5kX2ltYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contentstack.ts\n"));

/***/ })

});