"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(main)/courses/page",{

/***/ "(app-pages-browser)/./src/lib/contentstack.ts":
/*!*********************************!*\
  !*** ./src/lib/contentstack.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTENT_TYPES: function() { return /* binding */ CONTENT_TYPES; },\n/* harmony export */   Stack: function() { return /* binding */ Stack; },\n/* harmony export */   getAllBanners: function() { return /* binding */ getAllBanners; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllCourses: function() { return /* binding */ getAllCourses; },\n/* harmony export */   getAllHeaders: function() { return /* binding */ getAllHeaders; },\n/* harmony export */   getAllOnboardingSteps: function() { return /* binding */ getAllOnboardingSteps; },\n/* harmony export */   getAllTestimonials: function() { return /* binding */ getAllTestimonials; },\n/* harmony export */   getAuthBranding: function() { return /* binding */ getAuthBranding; },\n/* harmony export */   getCourseByLessonUid: function() { return /* binding */ getCourseByLessonUid; },\n/* harmony export */   getCourseBySlug: function() { return /* binding */ getCourseBySlug; },\n/* harmony export */   getCourseByUid: function() { return /* binding */ getCourseByUid; },\n/* harmony export */   getEntries: function() { return /* binding */ getEntries; },\n/* harmony export */   getEntry: function() { return /* binding */ getEntry; },\n/* harmony export */   getEntryByUrl: function() { return /* binding */ getEntryByUrl; },\n/* harmony export */   getFAQ: function() { return /* binding */ getFAQ; },\n/* harmony export */   getFooter: function() { return /* binding */ getFooter; },\n/* harmony export */   getHeader: function() { return /* binding */ getHeader; },\n/* harmony export */   getLessonBySlug: function() { return /* binding */ getLessonBySlug; },\n/* harmony export */   getLessonByUid: function() { return /* binding */ getLessonByUid; },\n/* harmony export */   getModuleByUid: function() { return /* binding */ getModuleByUid; },\n/* harmony export */   getNewsletter: function() { return /* binding */ getNewsletter; },\n/* harmony export */   getPage: function() { return /* binding */ getPage; },\n/* harmony export */   getPageByUrl: function() { return /* binding */ getPageByUrl; }\n/* harmony export */ });\n/* harmony import */ var contentstack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! contentstack */ \"(app-pages-browser)/./node_modules/contentstack/dist/web/contentstack.js\");\n/* harmony import */ var contentstack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(contentstack__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Contentstack SDK Configuration\nconst Stack = contentstack__WEBPACK_IMPORTED_MODULE_0___default().Stack({\n    api_key: process.env.NEXT_PUBLIC_CONTENTSTACK_API_KEY || \"blt2b872601d3c5423f\" || 0,\n    delivery_token: process.env.NEXT_PUBLIC_CONTENTSTACK_DELIVERY_TOKEN || \"csab2298d637dc5b151fd67edc\" || 0,\n    environment: process.env.NEXT_PUBLIC_CONTENTSTACK_ENVIRONMENT || \"dev\" || 0,\n    branch: process.env.NEXT_PUBLIC_CONTENTSTACK_BRANCH || \"main\" || 0\n});\n// Content Type UIDs - Match your Contentstack setup\nconst CONTENT_TYPES = {\n    PAGE: \"modular_section\",\n    BANNER: \"banner\",\n    HEADER: \"header\",\n    FOOTER: \"footer\",\n    NEWSLETTER: \"newsletter\",\n    ICON: \"icon\",\n    FAQ: \"faq\",\n    FAQ_QUESTION: \"faq_question\",\n    TESTIMONIAL: \"testimonial\",\n    AUTHOR: \"author\",\n    COURSE: \"courses\",\n    MODULE: \"module\",\n    LESSON: \"lesson\",\n    CATEGORY: \"categories_block\",\n    CATEGORY_BLOCK: \"category_block\",\n    INSTRUCTOR: \"instructor\",\n    ONBOARDING: \"onboarding_block\",\n    AUTH_BRANDING: \"auth_branding\"\n};\n// ============================================\n// Generic Fetch Helpers\n// ============================================\n/**\n * Get current locale from localStorage (client-side) or default\n */ function getCurrentLocale() {\n    if (true) {\n        return localStorage.getItem(\"selectedLanguage\") || \"en-us\";\n    }\n    return \"en-us\";\n}\n/**\n * Default fallback locale when content is not available in selected locale\n */ const FALLBACK_LOCALE = \"en-us\";\n/**\n * Fetch single entry by content type and UID\n */ async function getEntry(contentType, entryUid) {\n    let referenceFields = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], locale = arguments.length > 3 ? arguments[3] : void 0;\n    try {\n        const query = Stack.ContentType(contentType).Entry(entryUid);\n        // Set locale if provided\n        const targetLocale = locale || getCurrentLocale();\n        query.language(targetLocale);\n        referenceFields.forEach((field)=>{\n            query.includeReference(field);\n        });\n        const result = await query.toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching entry: \".concat(contentType, \"/\").concat(entryUid), error);\n        return null;\n    }\n}\n/**\n * Fetch entries by content type with options\n */ async function getEntries(contentType) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const query = Stack.ContentType(contentType).Query();\n        // Set locale if provided\n        const targetLocale = options.locale || getCurrentLocale();\n        query.language(targetLocale);\n        if (options.referenceFields) {\n            options.referenceFields.forEach((field)=>{\n                query.includeReference(field);\n            });\n        }\n        if (options.limit) query.limit(options.limit);\n        if (options.skip) query.skip(options.skip);\n        if (options.orderBy) {\n            if (options.orderDirection === \"desc\") {\n                query.descending(options.orderBy);\n            } else {\n                query.ascending(options.orderBy);\n            }\n        }\n        if (options.where) {\n            Object.entries(options.where).forEach((param)=>{\n                let [key, value] = param;\n                query.where(key, value);\n            });\n        }\n        const result = await query.toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching entries: \".concat(contentType), error);\n        return [];\n    }\n}\n/**\n * Fetch entry by URL\n */ async function getEntryByUrl(contentType, url) {\n    let referenceFields = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    try {\n        var _result_;\n        const query = Stack.ContentType(contentType).Query().where(\"url\", url);\n        referenceFields.forEach((field)=>{\n            query.includeReference(field);\n        });\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching entry by URL: \".concat(contentType, \"/\").concat(url), error);\n        return null;\n    }\n}\n// ============================================\n// Page (Modular Section) Fetch Functions\n// ============================================\n/**\n * Fetch Page entry by title with all nested references\n * This is the main function for fetching page content\n * Supports locale for fetching localized content\n */ async function getPage(title, locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"title\", title).includeReference([\n            \"header\",\n            \"header.icon\",\n            \"section.hero_block.hero_banner\",\n            \"section.carousel_block.banner\",\n            \"section.category_block.icon\",\n            \"section.category_block.category\",\n            \"section.feature_block.features\",\n            \"section.workflow_block.stage\",\n            \"section.testimonial_block.testimonial\",\n            \"section.testimonial_block.testimonial.author\"\n        ]);\n        // Set locale for content fetching\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let pageEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // Fallback to en-us if no page found in selected locale\n        if (!pageEntry && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            console.log('[CMS] Page \"'.concat(title, '\" not found in ').concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"title\", title).includeReference([\n                \"header\",\n                \"header.icon\",\n                \"section.hero_block.hero_banner\",\n                \"section.carousel_block.banner\",\n                \"section.category_block.icon\",\n                \"section.category_block.category\",\n                \"section.feature_block.features\",\n                \"section.workflow_block.stage\",\n                \"section.testimonial_block.testimonial\",\n                \"section.testimonial_block.testimonial.author\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            pageEntry = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        // Debug logging\n        if (pageEntry) {\n            var _pageEntry_section;\n            console.log('[CMS] Page \"'.concat(title, '\" loaded with ').concat(((_pageEntry_section = pageEntry.section) === null || _pageEntry_section === void 0 ? void 0 : _pageEntry_section.length) || 0, \" sections\"));\n        }\n        return pageEntry;\n    } catch (error) {\n        console.error(\"Error fetching page: \".concat(title), error);\n        return null;\n    }\n}\n/**\n * Fetch Page entry by URL\n */ async function getPageByUrl(url, locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        let pageEntry = null;\n        try {\n            var _result_;\n            const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"url\", url).includeReference([\n                \"header\",\n                \"header.icon\",\n                \"section.carousel_block.banner\",\n                \"section.category_block.icon\",\n                \"section.category_block.category\",\n                \"section.feature_block.features\",\n                \"section.workflow_block.stage\",\n                \"section.testimonial_block.testimonial\",\n                \"section.testimonial_block.testimonial.author\"\n            ]);\n            query.language(targetLocale);\n            const result = await query.toJSON().find();\n            pageEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        } catch (localeError) {\n            // Fallback to en-us if not found\n            if (targetLocale !== FALLBACK_LOCALE) {\n                var _fallbackResult_;\n                console.log(\"[CMS] Page URL \".concat(url, \" not found in \").concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n                const fallbackQuery = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"url\", url).includeReference([\n                    \"header\",\n                    \"header.icon\",\n                    \"section.carousel_block.banner\",\n                    \"section.category_block.icon\",\n                    \"section.category_block.category\",\n                    \"section.feature_block.features\",\n                    \"section.workflow_block.stage\",\n                    \"section.testimonial_block.testimonial\",\n                    \"section.testimonial_block.testimonial.author\"\n                ]);\n                fallbackQuery.language(FALLBACK_LOCALE);\n                const fallbackResult = await fallbackQuery.toJSON().find();\n                pageEntry = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n            } else {\n                throw localeError;\n            }\n        }\n        // If still no page entry, try fallback\n        if (!pageEntry && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_1;\n            console.log(\"[CMS] Page URL \".concat(url, \" not found in \").concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"url\", url).includeReference([\n                \"header\",\n                \"header.icon\",\n                \"section.carousel_block.banner\",\n                \"section.category_block.icon\",\n                \"section.category_block.category\",\n                \"section.feature_block.features\",\n                \"section.workflow_block.stage\",\n                \"section.testimonial_block.testimonial\",\n                \"section.testimonial_block.testimonial.author\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            pageEntry = ((_fallbackResult_1 = fallbackResult[0]) === null || _fallbackResult_1 === void 0 ? void 0 : _fallbackResult_1[0]) || null;\n        }\n        return pageEntry;\n    } catch (error) {\n        console.error(\"Error fetching page by URL: \".concat(url), error);\n        return null;\n    }\n}\n// ============================================\n// Category Fetch Functions\n// ============================================\n/**\n * Fetch all Category entries\n */ async function getAllCategories() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.CATEGORY).Query().toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching categories\", error);\n        return [];\n    }\n}\n// ============================================\n// Header Fetch Functions\n// ============================================\n/**\n * Fetch Header entry by title\n * Header is always fetched in English since it contains non-translatable UI config\n * @param title - \"Landing Header\" or \"App Header\"\n */ async function getHeader(title) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.HEADER).Query().where(\"title\", title).includeReference(\"icon\");\n        // Always fetch header in English (contains UI configuration, not translated content)\n        query.language(\"en-us\");\n        const result = await query.toJSON().find();\n        const header = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        if (header) {\n            var _header_accessibility_language;\n            console.log('[CMS] Header \"'.concat(title, '\" loaded with ').concat(((_header_accessibility_language = header.accessibility_language) === null || _header_accessibility_language === void 0 ? void 0 : _header_accessibility_language.length) || 0, \" languages\"));\n        }\n        return header;\n    } catch (error) {\n        console.error(\"Error fetching header: \".concat(title), error);\n        return null;\n    }\n}\n/**\n * Fetch all Headers\n */ async function getAllHeaders() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.HEADER).Query().includeReference(\"icon\").toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching all headers\", error);\n        return [];\n    }\n}\n// ============================================\n// Footer & Newsletter Fetch Functions\n// ============================================\n/**\n * Fetch Footer entry (singleton)\n * Supports locale for fetching localized content\n */ async function getFooter(locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        const query = Stack.ContentType(CONTENT_TYPES.FOOTER).Query().includeReference(\"icon\");\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let footer = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // Fallback to en-us if not found\n        if (!footer && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.FOOTER).Query().includeReference(\"icon\");\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            footer = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        return footer;\n    } catch (error) {\n        console.error(\"Error fetching footer\", error);\n        return null;\n    }\n}\n/**\n * Fetch Newsletter entry (singleton)\n * Supports locale for fetching localized content\n */ async function getNewsletter(locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        const query = Stack.ContentType(CONTENT_TYPES.NEWSLETTER).Query().includeReference(\"icon\");\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let newsletter = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // Fallback to en-us if not found\n        if (!newsletter && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.NEWSLETTER).Query().includeReference(\"icon\");\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            newsletter = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        return newsletter;\n    } catch (error) {\n        console.error(\"Error fetching newsletter\", error);\n        return null;\n    }\n}\n// ============================================\n// FAQ Fetch Functions\n// ============================================\n/**\n * Fetch FAQ entry (singleton) with nested references\n */ async function getFAQ() {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.FAQ).Query().includeReference([\n            \"icon\",\n            \"faq_question\"\n        ]);\n        const result = await query.toJSON().find();\n        const faqEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        if (faqEntry) {\n            console.log(\"FAQ Entry fetched:\", {\n                title: faqEntry.section_title,\n                hasIcon: !!faqEntry.icon,\n                faqQuestionType: Array.isArray(faqEntry.faq_question) ? \"array\" : \"object\"\n            });\n        }\n        return faqEntry;\n    } catch (error) {\n        console.error(\"Error fetching FAQ\", error);\n        return null;\n    }\n}\n// ============================================\n// Banner Fetch Functions\n// ============================================\n/**\n * Fetch all Banner entries\n */ async function getAllBanners() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.BANNER).Query().toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching banners\", error);\n        return [];\n    }\n}\n// ============================================\n// Testimonial Fetch Functions\n// ============================================\n/**\n * Fetch all Testimonial entries with author reference\n */ async function getAllTestimonials() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.TESTIMONIAL).Query().includeReference(\"author\").toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching testimonials\", error);\n        return [];\n    }\n}\n// ============================================\n// Course Fetch Functions\n// ============================================\n/**\n * Fetch all courses with author reference\n * Falls back to English if no content found in selected locale\n */ async function getAllCourses(locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        // First try with selected locale\n        const query = Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n            \"author\",\n            \"modules\"\n        ]);\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let courses = result[0] || [];\n        // If no courses found and we're not already using fallback, try fallback locale\n        if (courses.length === 0 && targetLocale !== FALLBACK_LOCALE) {\n            console.log(\"[CMS] No courses found in \".concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n                \"author\",\n                \"modules\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            courses = fallbackResult[0] || [];\n        }\n        // Resolve author references for all courses\n        const resolvedCourses = await Promise.all(courses.map((course)=>resolveAuthorReferences(course)));\n        return resolvedCourses;\n    } catch (error) {\n        console.error(\"Error fetching courses\", error);\n        return [];\n    }\n}\n/**\n * Fetch author by UID - always fetches from default locale since authors are not localized\n */ async function getAuthorByUid(uid) {\n    try {\n        const query = Stack.ContentType(CONTENT_TYPES.AUTHOR).Entry(uid);\n        // Always fetch authors in fallback locale since author data (name, bio) is non-localizable\n        query.language(FALLBACK_LOCALE);\n        const result = await query.toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching author by UID: \".concat(uid), error);\n        return null;\n    }\n}\n/**\n * Helper to resolve author references that may not be fully populated\n * When fetching localized content, references to non-localized entries may not resolve\n * This function always fetches author data from the fallback locale to ensure consistency\n */ async function resolveAuthorReferences(course) {\n    if (!course.author) return course;\n    const authors = Array.isArray(course.author) ? course.author : [\n        course.author\n    ];\n    const resolvedAuthors = [];\n    for (const author of authors){\n        // Always fetch the full author data from fallback locale to ensure we have all fields\n        // This is because author data (name, bio, social links) is marked as non-localizable\n        // but when fetching course in a different locale, the reference may not resolve properly\n        if (author.uid) {\n            // Always fetch fresh to ensure we get complete data\n            const fullAuthor = await getAuthorByUid(author.uid);\n            if (fullAuthor) {\n                resolvedAuthors.push(fullAuthor);\n            } else if (author.title) {\n                // Fallback: if fetch fails but we have partial data, use it\n                resolvedAuthors.push(author);\n            }\n        } else if (author.title) {\n            // No UID but has title - use as is\n            resolvedAuthors.push(author);\n        }\n    }\n    course.author = resolvedAuthors.length > 0 ? resolvedAuthors : undefined;\n    return course;\n}\n/**\n * Fetch a single course by slug with all nested references\n * Falls back to English if no content found in selected locale\n */ async function getCourseBySlug(slug, locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        // First try with selected locale\n        const query = Stack.ContentType(CONTENT_TYPES.COURSE).Query().where(\"slug\", slug).includeReference([\n            \"author\",\n            \"modules\",\n            \"modules.lessons\"\n        ]);\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let course = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // If no course found and we're not already using fallback, try fallback locale\n        if (!course && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            console.log(\"[CMS] Course not found in \".concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Query().where(\"slug\", slug).includeReference([\n                \"author\",\n                \"modules\",\n                \"modules.lessons\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            course = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        // Ensure author references are fully resolved\n        if (course) {\n            course = await resolveAuthorReferences(course);\n            console.log('[CMS] Course \"'.concat(course.title, '\" loaded with ').concat(Array.isArray(course.modules) ? course.modules.length : course.modules ? 1 : 0, \" modules\"));\n        }\n        return course;\n    } catch (error) {\n        console.error(\"Error fetching course by slug: \".concat(slug), error);\n        return null;\n    }\n}\n/**\n * Fetch a single course by UID with all nested references\n * Falls back to English if no content found in selected locale\n */ async function getCourseByUid(uid, locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        let course = null;\n        // First try with selected locale\n        try {\n            const query = Stack.ContentType(CONTENT_TYPES.COURSE).Entry(uid).includeReference([\n                \"author\",\n                \"modules\",\n                \"modules.lessons\"\n            ]);\n            query.language(targetLocale);\n            const result = await query.toJSON().fetch();\n            course = result;\n        } catch (localeError) {\n            // If locale fetch fails and we're not already using fallback, try fallback\n            if (targetLocale !== FALLBACK_LOCALE) {\n                console.log(\"[CMS] Course UID \".concat(uid, \" not found in \").concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n                const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Entry(uid).includeReference([\n                    \"author\",\n                    \"modules\",\n                    \"modules.lessons\"\n                ]);\n                fallbackQuery.language(FALLBACK_LOCALE);\n                const fallbackResult = await fallbackQuery.toJSON().fetch();\n                course = fallbackResult;\n            } else {\n                throw localeError;\n            }\n        }\n        // Ensure author references are fully resolved\n        if (course) {\n            course = await resolveAuthorReferences(course);\n        }\n        return course;\n    } catch (error) {\n        console.error(\"Error fetching course by UID: \".concat(uid), error);\n        return null;\n    }\n}\n// ============================================\n// Module Fetch Functions\n// ============================================\n/**\n * Fetch a single module by UID with lessons\n */ async function getModuleByUid(uid) {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.MODULE).Entry(uid).includeReference([\n            \"lessons\"\n        ]).toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching module by UID: \".concat(uid), error);\n        return null;\n    }\n}\n// ============================================\n// Lesson Fetch Functions\n// ============================================\n/**\n * Fetch a single lesson by UID\n */ async function getLessonByUid(uid, locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        const entry = Stack.ContentType(CONTENT_TYPES.LESSON).Entry(uid);\n        entry.language(targetLocale);\n        let result = await entry.toJSON().fetch();\n        // If not found, try fallback locale\n        if (!result && targetLocale !== FALLBACK_LOCALE) {\n            const fallbackEntry = Stack.ContentType(CONTENT_TYPES.LESSON).Entry(uid);\n            fallbackEntry.language(FALLBACK_LOCALE);\n            result = await fallbackEntry.toJSON().fetch();\n        }\n        return result;\n    } catch (error) {\n        // Try fallback locale on error\n        if ((locale || getCurrentLocale()) !== FALLBACK_LOCALE) {\n            try {\n                const fallbackEntry = Stack.ContentType(CONTENT_TYPES.LESSON).Entry(uid);\n                fallbackEntry.language(FALLBACK_LOCALE);\n                const result = await fallbackEntry.toJSON().fetch();\n                return result;\n            } catch (e) {\n            // Fallback also failed\n            }\n        }\n        console.error(\"Error fetching lesson by UID: \".concat(uid), error);\n        return null;\n    }\n}\n/**\n * Fetch a single lesson by slug\n */ async function getLessonBySlug(slug) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.LESSON).Query().where(\"slug\", slug);\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching lesson by slug: \".concat(slug), error);\n        return null;\n    }\n}\n/**\n * Fetch course data for a given lesson (to get course context)\n * Returns the course that contains this lesson\n */ async function getCourseByLessonUid(lessonUid) {\n    try {\n        // First, find which module contains this lesson\n        const modulesResult = await Stack.ContentType(CONTENT_TYPES.MODULE).Query().includeReference([\n            \"lessons\"\n        ]).toJSON().find();\n        const modules = modulesResult[0] || [];\n        let targetModuleUid = null;\n        for (const module of modules){\n            const lessons = Array.isArray(module.lessons) ? module.lessons : module.lessons ? [\n                module.lessons\n            ] : [];\n            if (lessons.some((lesson)=>lesson.uid === lessonUid)) {\n                targetModuleUid = module.uid;\n                break;\n            }\n        }\n        if (!targetModuleUid) return null;\n        // Now find the course that contains this module\n        const coursesResult = await Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n            \"author\",\n            \"modules\",\n            \"modules.lessons\"\n        ]).toJSON().find();\n        const courses = coursesResult[0] || [];\n        for (const course of courses){\n            const courseModules = Array.isArray(course.modules) ? course.modules : course.modules ? [\n                course.modules\n            ] : [];\n            if (courseModules.some((m)=>m.uid === targetModuleUid)) {\n                return course;\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching course by lesson UID: \".concat(lessonUid), error);\n        return null;\n    }\n}\n// ============================================\n// Onboarding Fetch Functions\n// ============================================\n/**\n * Fetch all onboarding steps\n * Returns steps sorted by current_step\n * Tries multiple content type names in case the exact name differs\n */ async function getAllOnboardingSteps() {\n    // Try different possible content type names\n    const possibleContentTypes = [\n        \"onboarding_block\",\n        \"onboarding\",\n        \"onboarding_step\",\n        \"onboarding_steps\",\n        \"modular_section\"\n    ];\n    for (const contentType of possibleContentTypes){\n        try {\n            const baseQuery = Stack.ContentType(contentType).Query();\n            // If it's modular_section, filter for onboarding entries\n            if (contentType === \"modular_section\") {\n                baseQuery.where(\"title\", \"Onboarding Step\");\n            } else {\n                // For onboarding-specific content types, include option references\n                baseQuery.includeReference(\"option\");\n            }\n            baseQuery.ascending(\"current_step\"); // Sort by step number\n            const result = await baseQuery.toJSON().find();\n            const entries = result[0] || [];\n            console.log(\"[CMS] Attempted \".concat(contentType, \": Found \").concat(entries.length, \" entries\"));\n            if (entries.length > 0) {\n                // Filter and transform entries\n                const onboardingEntries = entries.filter((entry)=>{\n                    var _entry_title;\n                    // Check if entry has onboarding-related fields\n                    return entry.current_step !== undefined || entry.label_text !== undefined || ((_entry_title = entry.title) === null || _entry_title === void 0 ? void 0 : _entry_title.toLowerCase().includes(\"onboarding\"));\n                }).map((entry)=>{\n                    var _entry_title_match, _entry_title;\n                    // Transform to OnboardingBlockEntry format\n                    return {\n                        uid: entry.uid || entry._id || \"\",\n                        title: entry.title,\n                        current_step: entry.current_step || parseInt(((_entry_title = entry.title) === null || _entry_title === void 0 ? void 0 : (_entry_title_match = _entry_title.match(/\\d+/)) === null || _entry_title_match === void 0 ? void 0 : _entry_title_match[0]) || \"1\"),\n                        total_steps: entry.total_steps || 5,\n                        label_text: entry.label_text || entry.title || \"\",\n                        display_type: entry.display_type || \"Card Grid\",\n                        option: entry.option || [],\n                        back_button_text: entry.back_button_text || \"Back\",\n                        next_button_text: entry.next_button_text || \"Continue\"\n                    };\n                });\n                if (onboardingEntries.length > 0) {\n                    console.log(\"[CMS] Successfully fetched \".concat(onboardingEntries.length, \" onboarding steps from \").concat(contentType));\n                    return onboardingEntries.sort((a, b)=>a.current_step - b.current_step);\n                }\n            }\n        } catch (error) {\n            // Log the error but continue trying other content types\n            console.log(\"[CMS] Content type \".concat(contentType, \" failed:\"), error.message || error);\n            continue;\n        }\n    }\n    // If no content type found, try searching modular_section for any onboarding-related entries\n    try {\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().includeReference([\n            \"section\"\n        ]);\n        const result = await query.toJSON().find();\n        const pages = result[0] || [];\n        // Look for pages with \"Onboarding\" in title\n        const onboardingPages = pages.filter((page)=>{\n            var _page_title;\n            return (_page_title = page.title) === null || _page_title === void 0 ? void 0 : _page_title.toLowerCase().includes(\"onboarding\");\n        });\n        if (onboardingPages.length > 0) {\n            console.log(\"[CMS] Found onboarding page(s), but need proper content type structure\");\n        }\n    } catch (error) {\n        console.error(\"Error searching for onboarding page:\", error);\n    }\n    console.warn(\"[CMS] No onboarding content type found. Please check:\");\n    console.warn(\"1. Content type name in Contentstack (might be different)\");\n    console.warn(\"2. Entries are published\");\n    console.warn(\"3. API keys and environment are correct\");\n    return [];\n}\n// ============================================\n// Auth Branding Fetch Functions\n// ============================================\n/**\n * Fetch Auth Branding entry by page type (login or signup)\n * Matches Contentstack schema: page_type is \"Sign In\" or \"Sign Up\"\n */ async function getAuthBranding(pageType) {\n    try {\n        // Convert lowercase to Contentstack format\n        const pageTypeValue = pageType === \"login\" ? \"Sign In\" : \"Sign Up\";\n        const query = Stack.ContentType(CONTENT_TYPES.AUTH_BRANDING).Query().where(\"page_type\", pageTypeValue).includeReference([\n            \"stats\"\n        ]); // stats is reference to icon content type\n        const result = await query.toJSON().find();\n        const entries = result[0] || [];\n        if (entries.length > 0) {\n            const entry = entries[0];\n            // Log for debugging\n            console.log(\"[CMS] Auth branding entry for \".concat(pageType, \":\"), {\n                headline: entry.headline,\n                subtitle: entry.subtitle,\n                branding_content: entry.branding_content,\n                stats: entry.stats,\n                statsType: Array.isArray(entry.stats) ? \"array\" : typeof entry.stats\n            });\n            return {\n                uid: entry.uid || entry._id || \"\",\n                title: entry.title || \"\",\n                page_type: entry.page_type || pageTypeValue,\n                headline: entry.headline,\n                subtitle: entry.subtitle,\n                branding_content: entry.branding_content,\n                stats: entry.stats,\n                background_image: entry.background_image\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching auth branding for \".concat(pageType, \":\"), error);\n        return null;\n    }\n}\n// Export the Stack for advanced usage\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGVudHN0YWNrLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQW1CeEMsaUNBQWlDO0FBQ2pDLE1BQU1DLFFBQVFELHlEQUFrQixDQUFDO0lBQy9CRSxTQUFTQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLGdDQUFnQyxJQUFJRixxQkFBZ0MsSUFBSTtJQUM3RkksZ0JBQWdCSixPQUFPQSxDQUFDQyxHQUFHLENBQUNJLHVDQUF1QyxJQUFJTCw0QkFBdUMsSUFBSTtJQUNsSE8sYUFBYVAsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDTyxvQ0FBb0MsSUFBSVIsS0FBb0MsSUFBSTtJQUN6R1UsUUFBUVYsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDVSwrQkFBK0IsSUFBSVgsTUFBK0IsSUFBSTtBQUM1RjtBQWlCQSxvREFBb0Q7QUFDN0MsTUFBTWEsZ0JBQWdCO0lBQzNCQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLGNBQWM7SUFDZEMsYUFBYTtJQUNiQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsZ0JBQWdCO0lBQ2hCQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsZUFBZTtBQUNqQixFQUFXO0FBRVgsK0NBQStDO0FBQy9DLHdCQUF3QjtBQUN4QiwrQ0FBK0M7QUFFL0M7O0NBRUMsR0FDRCxTQUFTQztJQUNQLElBQUksSUFBa0IsRUFBYTtRQUNqQyxPQUFPQyxhQUFhQyxPQUFPLENBQUMsdUJBQXVCO0lBQ3JEO0lBQ0EsT0FBTztBQUNUO0FBRUE7O0NBRUMsR0FDRCxNQUFNQyxrQkFBa0I7QUFFeEI7O0NBRUMsR0FDTSxlQUFlQyxTQUNwQkMsV0FBbUIsRUFDbkJDLFFBQWdCO1FBQ2hCQyxrQkFBQUEsaUVBQTRCLEVBQUUsRUFD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QyxRQUFRO2dCQUN4QkMsa0JBQWtCNUMsTUFBTTRDLGdCQUFnQjtnQkFDeENDLE9BQU83QyxNQUFNNkMsS0FBSztnQkFDbEJDLFdBQVd6RSxNQUFNQyxPQUFPLENBQUMwQixNQUFNNkMsS0FBSyxJQUFJLFVBQVUsT0FBTzdDLE1BQU02QyxLQUFLO1lBQ3RFO1lBRUEsT0FBTztnQkFDTDFELEtBQUthLE1BQU1iLEdBQUcsSUFBSWEsTUFBTXVCLEdBQUcsSUFBSTtnQkFDL0IxRSxPQUFPbUQsTUFBTW5ELEtBQUssSUFBSTtnQkFDdEJrRyxXQUFXL0MsTUFBTStDLFNBQVMsSUFBSU47Z0JBQzlCQyxVQUFVMUMsTUFBTTBDLFFBQVE7Z0JBQ3hCQyxVQUFVM0MsTUFBTTJDLFFBQVE7Z0JBQ3hCQyxrQkFBa0I1QyxNQUFNNEMsZ0JBQWdCO2dCQUN4Q0MsT0FBTzdDLE1BQU02QyxLQUFLO2dCQUNsQkcsa0JBQWtCaEQsTUFBTWdELGdCQUFnQjtZQUMxQztRQUNGO1FBRUEsT0FBTztJQUNULEVBQUUsT0FBT3ZILE9BQU87UUFDZEMsUUFBUUQsS0FBSyxDQUFDLG9DQUE2QyxPQUFUK0csVUFBUyxNQUFJL0c7UUFDL0QsT0FBTztJQUNUO0FBQ0Y7QUFFQSxzQ0FBc0M7QUFDckIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2xpYi9jb250ZW50c3RhY2sudHM/YjA2NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQ29udGVudHN0YWNrIGZyb20gJ2NvbnRlbnRzdGFjayc7XG5pbXBvcnQgeyBcbiAgSGVhZGVyRW50cnksIFxuICBGb290ZXJFbnRyeSwgXG4gIE5ld3NsZXR0ZXJFbnRyeSwgXG4gIEZBUUVudHJ5LFxuICBQYWdlRW50cnksXG4gIEJhbm5lckVudHJ5LFxuICBUZXN0aW1vbmlhbEVudHJ5LFxuICBIZXJvQmxvY2tFbnRyeSxcbiAgQ2F0ZWdvcnlFbnRyeSxcbiAgQ291cnNlRW50cnksXG4gIE1vZHVsZUVudHJ5LFxuICBMZXNzb25FbnRyeSxcbiAgT25ib2FyZGluZ0Jsb2NrRW50cnksXG4gIEF1dGhCcmFuZGluZ0VudHJ5LFxuICBBdXRob3JFbnRyeVxufSBmcm9tICdAL3R5cGVzL2NvbnRlbnRzdGFjayc7XG5cbi8vIENvbnRlbnRzdGFjayBTREsgQ29uZmlndXJhdGlvblxuY29uc3QgU3RhY2sgPSBDb250ZW50c3RhY2suU3RhY2soe1xuICBhcGlfa2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfQVBJX0tFWSB8fCBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfQVBJX0tFWSB8fCAnJyxcbiAgZGVsaXZlcnlfdG9rZW46IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19ERUxJVkVSWV9UT0tFTiB8fCBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfREVMSVZFUllfVE9LRU4gfHwgJycsXG4gIGVudmlyb25tZW50OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfRU5WSVJPTk1FTlQgfHwgcHJvY2Vzcy5lbnYuQ09OVEVOVFNUQUNLX0VOVklST05NRU5UIHx8ICdkZXYnLFxuICBicmFuY2g6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19CUkFOQ0ggfHwgcHJvY2Vzcy5lbnYuQ09OVEVOVFNUQUNLX0JSQU5DSCB8fCAnbWFpbicsXG59KTtcblxuLy8gVHlwZSBkZWZpbml0aW9ucyBmb3IgQ29udGVudHN0YWNrIGVudHJpZXNcbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudHN0YWNrRW50cnkge1xuICB1aWQ6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgdXJsPzogc3RyaW5nO1xuICBba2V5OiBzdHJpbmddOiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29udGVudHN0YWNrQXNzZXQge1xuICB1aWQ6IHN0cmluZztcbiAgdXJsOiBzdHJpbmc7XG4gIHRpdGxlOiBzdHJpbmc7XG4gIGZpbGVuYW1lOiBzdHJpbmc7XG59XG5cbi8vIENvbnRlbnQgVHlwZSBVSURzIC0gTWF0Y2ggeW91ciBDb250ZW50c3RhY2sgc2V0dXBcbmV4cG9ydCBjb25zdCBDT05URU5UX1RZUEVTID0ge1xuICBQQUdFOiAnbW9kdWxhcl9zZWN0aW9uJywgIC8vIFBhZ2UgY29udGVudCB0eXBlIChtb2R1bGFyIHNlY3Rpb25zKVxuICBCQU5ORVI6ICdiYW5uZXInLFxuICBIRUFERVI6ICdoZWFkZXInLFxuICBGT09URVI6ICdmb290ZXInLFxuICBORVdTTEVUVEVSOiAnbmV3c2xldHRlcicsXG4gIElDT046ICdpY29uJyxcbiAgRkFROiAnZmFxJyxcbiAgRkFRX1FVRVNUSU9OOiAnZmFxX3F1ZXN0aW9uJyxcbiAgVEVTVElNT05JQUw6ICd0ZXN0aW1vbmlhbCcsXG4gIEFVVEhPUjogJ2F1dGhvcicsXG4gIENPVVJTRTogJ2NvdXJzZXMnLCAgLy8gQ291cnNlIGNvbnRlbnQgdHlwZVxuICBNT0RVTEU6ICdtb2R1bGUnLCAgIC8vIE1vZHVsZSBjb250ZW50IHR5cGVcbiAgTEVTU09OOiAnbGVzc29uJywgICAvLyBMZXNzb24gY29udGVudCB0eXBlXG4gIENBVEVHT1JZOiAnY2F0ZWdvcmllc19ibG9jaycsICAvLyBVcGRhdGVkIHRvIG1hdGNoIG5ldyBjb250ZW50IHR5cGVcbiAgQ0FURUdPUllfQkxPQ0s6ICdjYXRlZ29yeV9ibG9jaycsICAvLyBTaW5nbGV0b24gZm9yIHJlZmVyZW5jaW5nIGNhdGVnb3JpZXNcbiAgSU5TVFJVQ1RPUjogJ2luc3RydWN0b3InLFxuICBPTkJPQVJESU5HOiAnb25ib2FyZGluZ19ibG9jaycsICAvLyBPbmJvYXJkaW5nIHN0ZXBzIGNvbnRlbnQgdHlwZVxuICBBVVRIX0JSQU5ESU5HOiAnYXV0aF9icmFuZGluZycsICAvLyBBdXRoIGJyYW5kaW5nIGNvbnRlbnQgdHlwZSBmb3IgbG9naW4vc2lnbnVwIHBhZ2VzXG59IGFzIGNvbnN0O1xuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gR2VuZXJpYyBGZXRjaCBIZWxwZXJzXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEdldCBjdXJyZW50IGxvY2FsZSBmcm9tIGxvY2FsU3RvcmFnZSAoY2xpZW50LXNpZGUpIG9yIGRlZmF1bHRcbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudExvY2FsZSgpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbG9jYWxTdG9yYWdlLmdldEl0ZW0oJ3NlbGVjdGVkTGFuZ3VhZ2UnKSB8fCAnZW4tdXMnO1xuICB9XG4gIHJldHVybiAnZW4tdXMnO1xufVxuXG4vKipcbiAqIERlZmF1bHQgZmFsbGJhY2sgbG9jYWxlIHdoZW4gY29udGVudCBpcyBub3QgYXZhaWxhYmxlIGluIHNlbGVjdGVkIGxvY2FsZVxuICovXG5jb25zdCBGQUxMQkFDS19MT0NBTEUgPSAnZW4tdXMnO1xuXG4vKipcbiAqIEZldGNoIHNpbmdsZSBlbnRyeSBieSBjb250ZW50IHR5cGUgYW5kIFVJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW50cnk8VCA9IENvbnRlbnRzdGFja0VudHJ5PihcbiAgY29udGVudFR5cGU6IHN0cmluZyxcbiAgZW50cnlVaWQ6IHN0cmluZyxcbiAgcmVmZXJlbmNlRmllbGRzOiBzdHJpbmdbXSA9IFtdLFxuICBsb2NhbGU/OiBzdHJpbmdcbik6IFByb21pc2U8VCB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKS5FbnRyeShlbnRyeVVpZCk7XG4gICAgXG4gICAgLy8gU2V0IGxvY2FsZSBpZiBwcm92aWRlZFxuICAgIGNvbnN0IHRhcmdldExvY2FsZSA9IGxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcbiAgICBcbiAgICByZWZlcmVuY2VGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIHF1ZXJ5LmluY2x1ZGVSZWZlcmVuY2UoZmllbGQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICByZXR1cm4gcmVzdWx0IGFzIFQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgZW50cnk6ICR7Y29udGVudFR5cGV9LyR7ZW50cnlVaWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggZW50cmllcyBieSBjb250ZW50IHR5cGUgd2l0aCBvcHRpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbnRyaWVzPFQgPSBDb250ZW50c3RhY2tFbnRyeT4oXG4gIGNvbnRlbnRUeXBlOiBzdHJpbmcsXG4gIG9wdGlvbnM6IHtcbiAgICByZWZlcmVuY2VGaWVsZHM/OiBzdHJpbmdbXTtcbiAgICBsaW1pdD86IG51bWJlcjtcbiAgICBza2lwPzogbnVtYmVyO1xuICAgIG9yZGVyQnk/OiBzdHJpbmc7XG4gICAgbG9jYWxlPzogc3RyaW5nO1xuICAgIG9yZGVyRGlyZWN0aW9uPzogJ2FzYycgfCAnZGVzYyc7XG4gICAgd2hlcmU/OiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xuICB9ID0ge31cbik6IFByb21pc2U8VFtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZSkuUXVlcnkoKTtcbiAgICBcbiAgICAvLyBTZXQgbG9jYWxlIGlmIHByb3ZpZGVkXG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gb3B0aW9ucy5sb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG4gICAgXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlRmllbGRzKSB7XG4gICAgICBvcHRpb25zLnJlZmVyZW5jZUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgICBxdWVyeS5pbmNsdWRlUmVmZXJlbmNlKGZpZWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxpbWl0KSBxdWVyeS5saW1pdChvcHRpb25zLmxpbWl0KTtcbiAgICBpZiAob3B0aW9ucy5za2lwKSBxdWVyeS5za2lwKG9wdGlvbnMuc2tpcCk7XG5cbiAgICBpZiAob3B0aW9ucy5vcmRlckJ5KSB7XG4gICAgICBpZiAob3B0aW9ucy5vcmRlckRpcmVjdGlvbiA9PT0gJ2Rlc2MnKSB7XG4gICAgICAgIHF1ZXJ5LmRlc2NlbmRpbmcob3B0aW9ucy5vcmRlckJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5LmFzY2VuZGluZyhvcHRpb25zLm9yZGVyQnkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRpb25zLndoZXJlKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhvcHRpb25zLndoZXJlKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgcXVlcnkud2hlcmUoa2V5LCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIFRbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBlbnRyaWVzOiAke2NvbnRlbnRUeXBlfWAsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBlbnRyeSBieSBVUkxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVudHJ5QnlVcmw8VCA9IENvbnRlbnRzdGFja0VudHJ5PihcbiAgY29udGVudFR5cGU6IHN0cmluZyxcbiAgdXJsOiBzdHJpbmcsXG4gIHJlZmVyZW5jZUZpZWxkczogc3RyaW5nW10gPSBbXVxuKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGUpLlF1ZXJ5KCkud2hlcmUoJ3VybCcsIHVybCk7XG4gICAgXG4gICAgcmVmZXJlbmNlRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICBxdWVyeS5pbmNsdWRlUmVmZXJlbmNlKGZpZWxkKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdPy5bMF0gYXMgVCB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGVudHJ5IGJ5IFVSTDogJHtjb250ZW50VHlwZX0vJHt1cmx9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBQYWdlIChNb2R1bGFyIFNlY3Rpb24pIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBQYWdlIGVudHJ5IGJ5IHRpdGxlIHdpdGggYWxsIG5lc3RlZCByZWZlcmVuY2VzXG4gKiBUaGlzIGlzIHRoZSBtYWluIGZ1bmN0aW9uIGZvciBmZXRjaGluZyBwYWdlIGNvbnRlbnRcbiAqIFN1cHBvcnRzIGxvY2FsZSBmb3IgZmV0Y2hpbmcgbG9jYWxpemVkIGNvbnRlbnRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFBhZ2UodGl0bGU6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKTogUHJvbWlzZTxQYWdlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuUEFHRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAud2hlcmUoJ3RpdGxlJywgdGl0bGUpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICdoZWFkZXInLFxuICAgICAgICAnaGVhZGVyLmljb24nLFxuICAgICAgICAnc2VjdGlvbi5oZXJvX2Jsb2NrLmhlcm9fYmFubmVyJywgICAgICAgIC8vIEhlcm8gQmFubmVyIHJlZmVyZW5jZVxuICAgICAgICAnc2VjdGlvbi5jYXJvdXNlbF9ibG9jay5iYW5uZXInLCAgICAgICAgICAvLyBCYW5uZXIgcmVmZXJlbmNlcyBmb3IgY2Fyb3VzZWxcbiAgICAgICAgJ3NlY3Rpb24uY2F0ZWdvcnlfYmxvY2suaWNvbicsICAgICAgICAgICAgLy8gTGVnYWN5IGNhdGVnb3J5IGljb25zXG4gICAgICAgICdzZWN0aW9uLmNhdGVnb3J5X2Jsb2NrLmNhdGVnb3J5JywgICAgICAgIC8vIE5ldyBjYXRlZ29yeSByZWZlcmVuY2VzIChjYXRlZ29yaWVzX2Jsb2NrKVxuICAgICAgICAnc2VjdGlvbi5mZWF0dXJlX2Jsb2NrLmZlYXR1cmVzJywgICAgICAgICAvLyBGZWF0dXJlIGljb25zXG4gICAgICAgICdzZWN0aW9uLndvcmtmbG93X2Jsb2NrLnN0YWdlJywgICAgICAgICAgIC8vIFdvcmtmbG93IHN0YWdlIGljb25zXG4gICAgICAgICdzZWN0aW9uLnRlc3RpbW9uaWFsX2Jsb2NrLnRlc3RpbW9uaWFsJywgIC8vIFRlc3RpbW9uaWFsIGVudHJpZXNcbiAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwuYXV0aG9yJywgLy8gVGVzdGltb25pYWwgYXV0aG9yc1xuICAgICAgXSk7XG5cbiAgICAvLyBTZXQgbG9jYWxlIGZvciBjb250ZW50IGZldGNoaW5nXG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBsZXQgcGFnZUVudHJ5ID0gcmVzdWx0WzBdPy5bMF0gYXMgUGFnZUVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgLy8gRmFsbGJhY2sgdG8gZW4tdXMgaWYgbm8gcGFnZSBmb3VuZCBpbiBzZWxlY3RlZCBsb2NhbGVcbiAgICBpZiAoIXBhZ2VFbnRyeSAmJiB0YXJnZXRMb2NhbGUgIT09IEZBTExCQUNLX0xPQ0FMRSkge1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIFBhZ2UgXCIke3RpdGxlfVwiIG5vdCBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLlBBR0UpXG4gICAgICAgIC5RdWVyeSgpXG4gICAgICAgIC53aGVyZSgndGl0bGUnLCB0aXRsZSlcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAgICdoZWFkZXInLFxuICAgICAgICAgICdoZWFkZXIuaWNvbicsXG4gICAgICAgICAgJ3NlY3Rpb24uaGVyb19ibG9jay5oZXJvX2Jhbm5lcicsXG4gICAgICAgICAgJ3NlY3Rpb24uY2Fyb3VzZWxfYmxvY2suYmFubmVyJyxcbiAgICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5pY29uJyxcbiAgICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5jYXRlZ29yeScsXG4gICAgICAgICAgJ3NlY3Rpb24uZmVhdHVyZV9ibG9jay5mZWF0dXJlcycsXG4gICAgICAgICAgJ3NlY3Rpb24ud29ya2Zsb3dfYmxvY2suc3RhZ2UnLFxuICAgICAgICAgICdzZWN0aW9uLnRlc3RpbW9uaWFsX2Jsb2NrLnRlc3RpbW9uaWFsJyxcbiAgICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbC5hdXRob3InLFxuICAgICAgICBdKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIHBhZ2VFbnRyeSA9IGZhbGxiYWNrUmVzdWx0WzBdPy5bMF0gYXMgUGFnZUVudHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIFxuICAgIC8vIERlYnVnIGxvZ2dpbmdcbiAgICBpZiAocGFnZUVudHJ5KSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gUGFnZSBcIiR7dGl0bGV9XCIgbG9hZGVkIHdpdGggJHtwYWdlRW50cnkuc2VjdGlvbj8ubGVuZ3RoIHx8IDB9IHNlY3Rpb25zYCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwYWdlRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcGFnZTogJHt0aXRsZX1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBQYWdlIGVudHJ5IGJ5IFVSTFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFnZUJ5VXJsKHVybDogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPFBhZ2VFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIGxldCBwYWdlRW50cnk6IFBhZ2VFbnRyeSB8IG51bGwgPSBudWxsO1xuICAgIFxuICAgIHRyeSB7XG4gICAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuUEFHRSlcbiAgICAgICAgLlF1ZXJ5KClcbiAgICAgICAgLndoZXJlKCd1cmwnLCB1cmwpXG4gICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgICAnaGVhZGVyJyxcbiAgICAgICAgICAnaGVhZGVyLmljb24nLFxuICAgICAgICAgICdzZWN0aW9uLmNhcm91c2VsX2Jsb2NrLmJhbm5lcicsXG4gICAgICAgICAgJ3NlY3Rpb24uY2F0ZWdvcnlfYmxvY2suaWNvbicsXG4gICAgICAgICAgJ3NlY3Rpb24uY2F0ZWdvcnlfYmxvY2suY2F0ZWdvcnknLFxuICAgICAgICAgICdzZWN0aW9uLmZlYXR1cmVfYmxvY2suZmVhdHVyZXMnLFxuICAgICAgICAgICdzZWN0aW9uLndvcmtmbG93X2Jsb2NrLnN0YWdlJyxcbiAgICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbCcsXG4gICAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwuYXV0aG9yJyxcbiAgICAgICAgXSk7XG4gICAgICBcbiAgICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIHBhZ2VFbnRyeSA9IHJlc3VsdFswXT8uWzBdIGFzIFBhZ2VFbnRyeSB8fCBudWxsO1xuICAgIH0gY2F0Y2ggKGxvY2FsZUVycm9yKSB7XG4gICAgICAvLyBGYWxsYmFjayB0byBlbi11cyBpZiBub3QgZm91bmRcbiAgICAgIGlmICh0YXJnZXRMb2NhbGUgIT09IEZBTExCQUNLX0xPQ0FMRSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0NNU10gUGFnZSBVUkwgJHt1cmx9IG5vdCBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuUEFHRSlcbiAgICAgICAgICAuUXVlcnkoKVxuICAgICAgICAgIC53aGVyZSgndXJsJywgdXJsKVxuICAgICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgICAgICdoZWFkZXInLFxuICAgICAgICAgICAgJ2hlYWRlci5pY29uJyxcbiAgICAgICAgICAgICdzZWN0aW9uLmNhcm91c2VsX2Jsb2NrLmJhbm5lcicsXG4gICAgICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5pY29uJyxcbiAgICAgICAgICAgICdzZWN0aW9uLmNhdGVnb3J5X2Jsb2NrLmNhdGVnb3J5JyxcbiAgICAgICAgICAgICdzZWN0aW9uLmZlYXR1cmVfYmxvY2suZmVhdHVyZXMnLFxuICAgICAgICAgICAgJ3NlY3Rpb24ud29ya2Zsb3dfYmxvY2suc3RhZ2UnLFxuICAgICAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwnLFxuICAgICAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwuYXV0aG9yJyxcbiAgICAgICAgICBdKTtcbiAgICAgICAgZmFsbGJhY2tRdWVyeS5sYW5ndWFnZShGQUxMQkFDS19MT0NBTEUpO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgICAgcGFnZUVudHJ5ID0gZmFsbGJhY2tSZXN1bHRbMF0/LlswXSBhcyBQYWdlRW50cnkgfHwgbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGxvY2FsZUVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBJZiBzdGlsbCBubyBwYWdlIGVudHJ5LCB0cnkgZmFsbGJhY2tcbiAgICBpZiAoIXBhZ2VFbnRyeSAmJiB0YXJnZXRMb2NhbGUgIT09IEZBTExCQUNLX0xPQ0FMRSkge1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIFBhZ2UgVVJMICR7dXJsfSBub3QgZm91bmQgaW4gJHt0YXJnZXRMb2NhbGV9LCBmYWxsaW5nIGJhY2sgdG8gJHtGQUxMQkFDS19MT0NBTEV9YCk7XG4gICAgICBjb25zdCBmYWxsYmFja1F1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5QQUdFKVxuICAgICAgICAuUXVlcnkoKVxuICAgICAgICAud2hlcmUoJ3VybCcsIHVybClcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAgICdoZWFkZXInLFxuICAgICAgICAgICdoZWFkZXIuaWNvbicsXG4gICAgICAgICAgJ3NlY3Rpb24uY2Fyb3VzZWxfYmxvY2suYmFubmVyJyxcbiAgICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5pY29uJyxcbiAgICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5jYXRlZ29yeScsXG4gICAgICAgICAgJ3NlY3Rpb24uZmVhdHVyZV9ibG9jay5mZWF0dXJlcycsXG4gICAgICAgICAgJ3NlY3Rpb24ud29ya2Zsb3dfYmxvY2suc3RhZ2UnLFxuICAgICAgICAgICdzZWN0aW9uLnRlc3RpbW9uaWFsX2Jsb2NrLnRlc3RpbW9uaWFsJyxcbiAgICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbC5hdXRob3InLFxuICAgICAgICBdKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIHBhZ2VFbnRyeSA9IGZhbGxiYWNrUmVzdWx0WzBdPy5bMF0gYXMgUGFnZUVudHJ5IHx8IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhZ2VFbnRyeTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBwYWdlIGJ5IFVSTDogJHt1cmx9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDYXRlZ29yeSBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggYWxsIENhdGVnb3J5IGVudHJpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbENhdGVnb3JpZXMoKTogUHJvbWlzZTxDYXRlZ29yeUVudHJ5W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNBVEVHT1JZKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZpbmQoKTtcbiAgICByZXR1cm4gKHJlc3VsdFswXSB8fCBbXSkgYXMgQ2F0ZWdvcnlFbnRyeVtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNhdGVnb3JpZXMnLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBIZWFkZXIgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIEhlYWRlciBlbnRyeSBieSB0aXRsZVxuICogSGVhZGVyIGlzIGFsd2F5cyBmZXRjaGVkIGluIEVuZ2xpc2ggc2luY2UgaXQgY29udGFpbnMgbm9uLXRyYW5zbGF0YWJsZSBVSSBjb25maWdcbiAqIEBwYXJhbSB0aXRsZSAtIFwiTGFuZGluZyBIZWFkZXJcIiBvciBcIkFwcCBIZWFkZXJcIlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0SGVhZGVyKHRpdGxlOiBzdHJpbmcpOiBQcm9taXNlPEhlYWRlckVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5IRUFERVIpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCd0aXRsZScsIHRpdGxlKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2ljb24nKTtcblxuICAgIC8vIEFsd2F5cyBmZXRjaCBoZWFkZXIgaW4gRW5nbGlzaCAoY29udGFpbnMgVUkgY29uZmlndXJhdGlvbiwgbm90IHRyYW5zbGF0ZWQgY29udGVudClcbiAgICBxdWVyeS5sYW5ndWFnZSgnZW4tdXMnKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBjb25zdCBoZWFkZXIgPSByZXN1bHRbMF0/LlswXSBhcyBIZWFkZXJFbnRyeSB8fCBudWxsO1xuICAgIFxuICAgIGlmIChoZWFkZXIpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBIZWFkZXIgXCIke3RpdGxlfVwiIGxvYWRlZCB3aXRoICR7aGVhZGVyLmFjY2Vzc2liaWxpdHlfbGFuZ3VhZ2U/Lmxlbmd0aCB8fCAwfSBsYW5ndWFnZXNgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWRlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBoZWFkZXI6ICR7dGl0bGV9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggYWxsIEhlYWRlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbEhlYWRlcnMoKTogUHJvbWlzZTxIZWFkZXJFbnRyeVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5IRUFERVIpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2ljb24nKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIHJldHVybiAocmVzdWx0WzBdIHx8IFtdKSBhcyBIZWFkZXJFbnRyeVtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGFsbCBoZWFkZXJzJywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRm9vdGVyICYgTmV3c2xldHRlciBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggRm9vdGVyIGVudHJ5IChzaW5nbGV0b24pXG4gKiBTdXBwb3J0cyBsb2NhbGUgZm9yIGZldGNoaW5nIGxvY2FsaXplZCBjb250ZW50XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRGb290ZXIobG9jYWxlPzogc3RyaW5nKTogUHJvbWlzZTxGb290ZXJFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5GT09URVIpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2ljb24nKTtcbiAgICBcbiAgICBxdWVyeS5sYW5ndWFnZSh0YXJnZXRMb2NhbGUpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGxldCBmb290ZXIgPSByZXN1bHRbMF0/LlswXSBhcyBGb290ZXJFbnRyeSB8fCBudWxsO1xuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIGVuLXVzIGlmIG5vdCBmb3VuZFxuICAgIGlmICghZm9vdGVyICYmIHRhcmdldExvY2FsZSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICBjb25zdCBmYWxsYmFja1F1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5GT09URVIpXG4gICAgICAgIC5RdWVyeSgpXG4gICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKCdpY29uJyk7XG4gICAgICBmYWxsYmFja1F1ZXJ5Lmxhbmd1YWdlKEZBTExCQUNLX0xPQ0FMRSk7XG4gICAgICBcbiAgICAgIGNvbnN0IGZhbGxiYWNrUmVzdWx0ID0gYXdhaXQgZmFsbGJhY2tRdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgICBmb290ZXIgPSBmYWxsYmFja1Jlc3VsdFswXT8uWzBdIGFzIEZvb3RlckVudHJ5IHx8IG51bGw7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmb290ZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgZm9vdGVyJywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggTmV3c2xldHRlciBlbnRyeSAoc2luZ2xldG9uKVxuICogU3VwcG9ydHMgbG9jYWxlIGZvciBmZXRjaGluZyBsb2NhbGl6ZWQgY29udGVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TmV3c2xldHRlcihsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPE5ld3NsZXR0ZXJFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5ORVdTTEVUVEVSKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKCdpY29uJyk7XG4gICAgXG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBsZXQgbmV3c2xldHRlciA9IHJlc3VsdFswXT8uWzBdIGFzIE5ld3NsZXR0ZXJFbnRyeSB8fCBudWxsO1xuICAgIFxuICAgIC8vIEZhbGxiYWNrIHRvIGVuLXVzIGlmIG5vdCBmb3VuZFxuICAgIGlmICghbmV3c2xldHRlciAmJiB0YXJnZXRMb2NhbGUgIT09IEZBTExCQUNLX0xPQ0FMRSkge1xuICAgICAgY29uc3QgZmFsbGJhY2tRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuTkVXU0xFVFRFUilcbiAgICAgICAgLlF1ZXJ5KClcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2ljb24nKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIG5ld3NsZXR0ZXIgPSBmYWxsYmFja1Jlc3VsdFswXT8uWzBdIGFzIE5ld3NsZXR0ZXJFbnRyeSB8fCBudWxsO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbmV3c2xldHRlcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBuZXdzbGV0dGVyJywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBGQVEgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIEZBUSBlbnRyeSAoc2luZ2xldG9uKSB3aXRoIG5lc3RlZCByZWZlcmVuY2VzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRGQVEoKTogUHJvbWlzZTxGQVFFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuRkFRKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnaWNvbicsICdmYXFfcXVlc3Rpb24nXSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgY29uc3QgZmFxRW50cnkgPSByZXN1bHRbMF0/LlswXSBhcyBGQVFFbnRyeSB8fCBudWxsO1xuICAgIFxuICAgIGlmIChmYXFFbnRyeSkge1xuICAgICAgY29uc29sZS5sb2coJ0ZBUSBFbnRyeSBmZXRjaGVkOicsIHtcbiAgICAgICAgdGl0bGU6IGZhcUVudHJ5LnNlY3Rpb25fdGl0bGUsXG4gICAgICAgIGhhc0ljb246ICEhZmFxRW50cnkuaWNvbixcbiAgICAgICAgZmFxUXVlc3Rpb25UeXBlOiBBcnJheS5pc0FycmF5KGZhcUVudHJ5LmZhcV9xdWVzdGlvbikgPyAnYXJyYXknIDogJ29iamVjdCcsXG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhcUVudHJ5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIEZBUScsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQmFubmVyIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhbGwgQmFubmVyIGVudHJpZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbEJhbm5lcnMoKTogUHJvbWlzZTxCYW5uZXJFbnRyeVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5CQU5ORVIpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIHJldHVybiAocmVzdWx0WzBdIHx8IFtdKSBhcyBCYW5uZXJFbnRyeVtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGJhbm5lcnMnLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBUZXN0aW1vbmlhbCBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggYWxsIFRlc3RpbW9uaWFsIGVudHJpZXMgd2l0aCBhdXRob3IgcmVmZXJlbmNlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxUZXN0aW1vbmlhbHMoKTogUHJvbWlzZTxUZXN0aW1vbmlhbEVudHJ5W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLlRFU1RJTU9OSUFMKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKCdhdXRob3InKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIHJldHVybiAocmVzdWx0WzBdIHx8IFtdKSBhcyBUZXN0aW1vbmlhbEVudHJ5W107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdGVzdGltb25pYWxzJywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ291cnNlIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhbGwgY291cnNlcyB3aXRoIGF1dGhvciByZWZlcmVuY2VcbiAqIEZhbGxzIGJhY2sgdG8gRW5nbGlzaCBpZiBubyBjb250ZW50IGZvdW5kIGluIHNlbGVjdGVkIGxvY2FsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsQ291cnNlcyhsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPENvdXJzZUVudHJ5W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIHNlbGVjdGVkIGxvY2FsZVxuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydhdXRob3InLCAnbW9kdWxlcyddKTtcbiAgICBxdWVyeS5sYW5ndWFnZSh0YXJnZXRMb2NhbGUpO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBsZXQgY291cnNlcyA9IChyZXN1bHRbMF0gfHwgW10pIGFzIENvdXJzZUVudHJ5W107XG4gICAgXG4gICAgLy8gSWYgbm8gY291cnNlcyBmb3VuZCBhbmQgd2UncmUgbm90IGFscmVhZHkgdXNpbmcgZmFsbGJhY2ssIHRyeSBmYWxsYmFjayBsb2NhbGVcbiAgICBpZiAoY291cnNlcy5sZW5ndGggPT09IDAgJiYgdGFyZ2V0TG9jYWxlICE9PSBGQUxMQkFDS19MT0NBTEUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBObyBjb3Vyc2VzIGZvdW5kIGluICR7dGFyZ2V0TG9jYWxlfSwgZmFsbGluZyBiYWNrIHRvICR7RkFMTEJBQ0tfTE9DQUxFfWApO1xuICAgICAgY29uc3QgZmFsbGJhY2tRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ09VUlNFKVxuICAgICAgICAuUXVlcnkoKVxuICAgICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2F1dGhvcicsICdtb2R1bGVzJ10pO1xuICAgICAgZmFsbGJhY2tRdWVyeS5sYW5ndWFnZShGQUxMQkFDS19MT0NBTEUpO1xuICAgICAgXG4gICAgICBjb25zdCBmYWxsYmFja1Jlc3VsdCA9IGF3YWl0IGZhbGxiYWNrUXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgICAgY291cnNlcyA9IChmYWxsYmFja1Jlc3VsdFswXSB8fCBbXSkgYXMgQ291cnNlRW50cnlbXTtcbiAgICB9XG4gICAgXG4gICAgLy8gUmVzb2x2ZSBhdXRob3IgcmVmZXJlbmNlcyBmb3IgYWxsIGNvdXJzZXNcbiAgICBjb25zdCByZXNvbHZlZENvdXJzZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGNvdXJzZXMubWFwKGNvdXJzZSA9PiByZXNvbHZlQXV0aG9yUmVmZXJlbmNlcyhjb3Vyc2UpKVxuICAgICk7XG4gICAgXG4gICAgcmV0dXJuIHJlc29sdmVkQ291cnNlcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjb3Vyc2VzJywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIGF1dGhvciBieSBVSUQgLSBhbHdheXMgZmV0Y2hlcyBmcm9tIGRlZmF1bHQgbG9jYWxlIHNpbmNlIGF1dGhvcnMgYXJlIG5vdCBsb2NhbGl6ZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aG9yQnlVaWQodWlkOiBzdHJpbmcpOiBQcm9taXNlPEF1dGhvckVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5BVVRIT1IpXG4gICAgICAuRW50cnkodWlkKTtcbiAgICAvLyBBbHdheXMgZmV0Y2ggYXV0aG9ycyBpbiBmYWxsYmFjayBsb2NhbGUgc2luY2UgYXV0aG9yIGRhdGEgKG5hbWUsIGJpbykgaXMgbm9uLWxvY2FsaXphYmxlXG4gICAgcXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5mZXRjaCgpO1xuICAgIHJldHVybiByZXN1bHQgYXMgQXV0aG9yRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYXV0aG9yIGJ5IFVJRDogJHt1aWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogSGVscGVyIHRvIHJlc29sdmUgYXV0aG9yIHJlZmVyZW5jZXMgdGhhdCBtYXkgbm90IGJlIGZ1bGx5IHBvcHVsYXRlZFxuICogV2hlbiBmZXRjaGluZyBsb2NhbGl6ZWQgY29udGVudCwgcmVmZXJlbmNlcyB0byBub24tbG9jYWxpemVkIGVudHJpZXMgbWF5IG5vdCByZXNvbHZlXG4gKiBUaGlzIGZ1bmN0aW9uIGFsd2F5cyBmZXRjaGVzIGF1dGhvciBkYXRhIGZyb20gdGhlIGZhbGxiYWNrIGxvY2FsZSB0byBlbnN1cmUgY29uc2lzdGVuY3lcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVzb2x2ZUF1dGhvclJlZmVyZW5jZXMoY291cnNlOiBDb3Vyc2VFbnRyeSk6IFByb21pc2U8Q291cnNlRW50cnk+IHtcbiAgaWYgKCFjb3Vyc2UuYXV0aG9yKSByZXR1cm4gY291cnNlO1xuICBcbiAgY29uc3QgYXV0aG9ycyA9IEFycmF5LmlzQXJyYXkoY291cnNlLmF1dGhvcikgPyBjb3Vyc2UuYXV0aG9yIDogW2NvdXJzZS5hdXRob3JdO1xuICBjb25zdCByZXNvbHZlZEF1dGhvcnM6IEF1dGhvckVudHJ5W10gPSBbXTtcbiAgXG4gIGZvciAoY29uc3QgYXV0aG9yIG9mIGF1dGhvcnMpIHtcbiAgICAvLyBBbHdheXMgZmV0Y2ggdGhlIGZ1bGwgYXV0aG9yIGRhdGEgZnJvbSBmYWxsYmFjayBsb2NhbGUgdG8gZW5zdXJlIHdlIGhhdmUgYWxsIGZpZWxkc1xuICAgIC8vIFRoaXMgaXMgYmVjYXVzZSBhdXRob3IgZGF0YSAobmFtZSwgYmlvLCBzb2NpYWwgbGlua3MpIGlzIG1hcmtlZCBhcyBub24tbG9jYWxpemFibGVcbiAgICAvLyBidXQgd2hlbiBmZXRjaGluZyBjb3Vyc2UgaW4gYSBkaWZmZXJlbnQgbG9jYWxlLCB0aGUgcmVmZXJlbmNlIG1heSBub3QgcmVzb2x2ZSBwcm9wZXJseVxuICAgIGlmIChhdXRob3IudWlkKSB7XG4gICAgICAvLyBBbHdheXMgZmV0Y2ggZnJlc2ggdG8gZW5zdXJlIHdlIGdldCBjb21wbGV0ZSBkYXRhXG4gICAgICBjb25zdCBmdWxsQXV0aG9yID0gYXdhaXQgZ2V0QXV0aG9yQnlVaWQoYXV0aG9yLnVpZCk7XG4gICAgICBpZiAoZnVsbEF1dGhvcikge1xuICAgICAgICByZXNvbHZlZEF1dGhvcnMucHVzaChmdWxsQXV0aG9yKTtcbiAgICAgIH0gZWxzZSBpZiAoYXV0aG9yLnRpdGxlKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrOiBpZiBmZXRjaCBmYWlscyBidXQgd2UgaGF2ZSBwYXJ0aWFsIGRhdGEsIHVzZSBpdFxuICAgICAgICByZXNvbHZlZEF1dGhvcnMucHVzaChhdXRob3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYXV0aG9yLnRpdGxlKSB7XG4gICAgICAvLyBObyBVSUQgYnV0IGhhcyB0aXRsZSAtIHVzZSBhcyBpc1xuICAgICAgcmVzb2x2ZWRBdXRob3JzLnB1c2goYXV0aG9yKTtcbiAgICB9XG4gIH1cbiAgXG4gIGNvdXJzZS5hdXRob3IgPSByZXNvbHZlZEF1dGhvcnMubGVuZ3RoID4gMCA/IHJlc29sdmVkQXV0aG9ycyA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNvdXJzZTtcbn1cblxuLyoqXG4gKiBGZXRjaCBhIHNpbmdsZSBjb3Vyc2UgYnkgc2x1ZyB3aXRoIGFsbCBuZXN0ZWQgcmVmZXJlbmNlc1xuICogRmFsbHMgYmFjayB0byBFbmdsaXNoIGlmIG5vIGNvbnRlbnQgZm91bmQgaW4gc2VsZWN0ZWQgbG9jYWxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VCeVNsdWcoc2x1Zzogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPENvdXJzZUVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRhcmdldExvY2FsZSA9IGxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgXG4gICAgLy8gRmlyc3QgdHJ5IHdpdGggc2VsZWN0ZWQgbG9jYWxlXG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAud2hlcmUoJ3NsdWcnLCBzbHVnKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAnYXV0aG9yJyxcbiAgICAgICAgJ21vZHVsZXMnLFxuICAgICAgICAnbW9kdWxlcy5sZXNzb25zJ1xuICAgICAgXSk7XG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBsZXQgY291cnNlID0gcmVzdWx0WzBdPy5bMF0gYXMgQ291cnNlRW50cnkgfHwgbnVsbDtcbiAgICBcbiAgICAvLyBJZiBubyBjb3Vyc2UgZm91bmQgYW5kIHdlJ3JlIG5vdCBhbHJlYWR5IHVzaW5nIGZhbGxiYWNrLCB0cnkgZmFsbGJhY2sgbG9jYWxlXG4gICAgaWYgKCFjb3Vyc2UgJiYgdGFyZ2V0TG9jYWxlICE9PSBGQUxMQkFDS19MT0NBTEUpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBDb3Vyc2Ugbm90IGZvdW5kIGluICR7dGFyZ2V0TG9jYWxlfSwgZmFsbGluZyBiYWNrIHRvICR7RkFMTEJBQ0tfTE9DQUxFfWApO1xuICAgICAgY29uc3QgZmFsbGJhY2tRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ09VUlNFKVxuICAgICAgICAuUXVlcnkoKVxuICAgICAgICAud2hlcmUoJ3NsdWcnLCBzbHVnKVxuICAgICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICAgJ21vZHVsZXMnLFxuICAgICAgICAgICdtb2R1bGVzLmxlc3NvbnMnXG4gICAgICAgIF0pO1xuICAgICAgZmFsbGJhY2tRdWVyeS5sYW5ndWFnZShGQUxMQkFDS19MT0NBTEUpO1xuICAgICAgXG4gICAgICBjb25zdCBmYWxsYmFja1Jlc3VsdCA9IGF3YWl0IGZhbGxiYWNrUXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgICAgY291cnNlID0gZmFsbGJhY2tSZXN1bHRbMF0/LlswXSBhcyBDb3Vyc2VFbnRyeSB8fCBudWxsO1xuICAgIH1cbiAgICBcbiAgICAvLyBFbnN1cmUgYXV0aG9yIHJlZmVyZW5jZXMgYXJlIGZ1bGx5IHJlc29sdmVkXG4gICAgaWYgKGNvdXJzZSkge1xuICAgICAgY291cnNlID0gYXdhaXQgcmVzb2x2ZUF1dGhvclJlZmVyZW5jZXMoY291cnNlKTtcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBDb3Vyc2UgXCIke2NvdXJzZS50aXRsZX1cIiBsb2FkZWQgd2l0aCAke0FycmF5LmlzQXJyYXkoY291cnNlLm1vZHVsZXMpID8gY291cnNlLm1vZHVsZXMubGVuZ3RoIDogY291cnNlLm1vZHVsZXMgPyAxIDogMH0gbW9kdWxlc2ApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gY291cnNlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNvdXJzZSBieSBzbHVnOiAke3NsdWd9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggYSBzaW5nbGUgY291cnNlIGJ5IFVJRCB3aXRoIGFsbCBuZXN0ZWQgcmVmZXJlbmNlc1xuICogRmFsbHMgYmFjayB0byBFbmdsaXNoIGlmIG5vIGNvbnRlbnQgZm91bmQgaW4gc2VsZWN0ZWQgbG9jYWxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VCeVVpZCh1aWQ6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKTogUHJvbWlzZTxDb3Vyc2VFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIGxldCBjb3Vyc2U6IENvdXJzZUVudHJ5IHwgbnVsbCA9IG51bGw7XG4gICAgXG4gICAgLy8gRmlyc3QgdHJ5IHdpdGggc2VsZWN0ZWQgbG9jYWxlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAgIC5FbnRyeSh1aWQpXG4gICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgICAnYXV0aG9yJyxcbiAgICAgICAgICAnbW9kdWxlcycsXG4gICAgICAgICAgJ21vZHVsZXMubGVzc29ucydcbiAgICAgICAgXSk7XG4gICAgICBxdWVyeS5sYW5ndWFnZSh0YXJnZXRMb2NhbGUpO1xuICAgICAgXG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5mZXRjaCgpO1xuICAgICAgY291cnNlID0gcmVzdWx0IGFzIENvdXJzZUVudHJ5O1xuICAgIH0gY2F0Y2ggKGxvY2FsZUVycm9yKSB7XG4gICAgICAvLyBJZiBsb2NhbGUgZmV0Y2ggZmFpbHMgYW5kIHdlJ3JlIG5vdCBhbHJlYWR5IHVzaW5nIGZhbGxiYWNrLCB0cnkgZmFsbGJhY2tcbiAgICAgIGlmICh0YXJnZXRMb2NhbGUgIT09IEZBTExCQUNLX0xPQ0FMRSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW0NNU10gQ291cnNlIFVJRCAke3VpZH0gbm90IGZvdW5kIGluICR7dGFyZ2V0TG9jYWxlfSwgZmFsbGluZyBiYWNrIHRvICR7RkFMTEJBQ0tfTE9DQUxFfWApO1xuICAgICAgICBjb25zdCBmYWxsYmFja1F1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAgICAgLkVudHJ5KHVpZClcbiAgICAgICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICAgICAnYXV0aG9yJyxcbiAgICAgICAgICAgICdtb2R1bGVzJyxcbiAgICAgICAgICAgICdtb2R1bGVzLmxlc3NvbnMnXG4gICAgICAgICAgXSk7XG4gICAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGZhbGxiYWNrUmVzdWx0ID0gYXdhaXQgZmFsbGJhY2tRdWVyeS50b0pTT04oKS5mZXRjaCgpO1xuICAgICAgICBjb3Vyc2UgPSBmYWxsYmFja1Jlc3VsdCBhcyBDb3Vyc2VFbnRyeTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGxvY2FsZUVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICAvLyBFbnN1cmUgYXV0aG9yIHJlZmVyZW5jZXMgYXJlIGZ1bGx5IHJlc29sdmVkXG4gICAgaWYgKGNvdXJzZSkge1xuICAgICAgY291cnNlID0gYXdhaXQgcmVzb2x2ZUF1dGhvclJlZmVyZW5jZXMoY291cnNlKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvdXJzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjb3Vyc2UgYnkgVUlEOiAke3VpZH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE1vZHVsZSBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggYSBzaW5nbGUgbW9kdWxlIGJ5IFVJRCB3aXRoIGxlc3NvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE1vZHVsZUJ5VWlkKHVpZDogc3RyaW5nKTogUHJvbWlzZTxNb2R1bGVFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLk1PRFVMRSlcbiAgICAgIC5FbnRyeSh1aWQpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2xlc3NvbnMnXSlcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZldGNoKCk7XG4gICAgcmV0dXJuIHJlc3VsdCBhcyBNb2R1bGVFbnRyeTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBtb2R1bGUgYnkgVUlEOiAke3VpZH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIExlc3NvbiBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggYSBzaW5nbGUgbGVzc29uIGJ5IFVJRFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0TGVzc29uQnlVaWQodWlkOiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8TGVzc29uRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBcbiAgICBjb25zdCBlbnRyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuTEVTU09OKS5FbnRyeSh1aWQpO1xuICAgIGVudHJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG4gICAgXG4gICAgbGV0IHJlc3VsdCA9IGF3YWl0IGVudHJ5LnRvSlNPTigpLmZldGNoKCk7XG4gICAgXG4gICAgLy8gSWYgbm90IGZvdW5kLCB0cnkgZmFsbGJhY2sgbG9jYWxlXG4gICAgaWYgKCFyZXN1bHQgJiYgdGFyZ2V0TG9jYWxlICE9PSBGQUxMQkFDS19MT0NBTEUpIHtcbiAgICAgIGNvbnN0IGZhbGxiYWNrRW50cnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkxFU1NPTikuRW50cnkodWlkKTtcbiAgICAgIGZhbGxiYWNrRW50cnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIHJlc3VsdCA9IGF3YWl0IGZhbGxiYWNrRW50cnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdCBhcyBMZXNzb25FbnRyeTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBUcnkgZmFsbGJhY2sgbG9jYWxlIG9uIGVycm9yXG4gICAgaWYgKChsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpKSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBmYWxsYmFja0VudHJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5MRVNTT04pLkVudHJ5KHVpZCk7XG4gICAgICAgIGZhbGxiYWNrRW50cnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZmFsbGJhY2tFbnRyeS50b0pTT04oKS5mZXRjaCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0IGFzIExlc3NvbkVudHJ5O1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgIC8vIEZhbGxiYWNrIGFsc28gZmFpbGVkXG4gICAgICB9XG4gICAgfVxuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGxlc3NvbiBieSBVSUQ6ICR7dWlkfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIGxlc3NvbiBieSBzbHVnXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRMZXNzb25CeVNsdWcoc2x1Zzogc3RyaW5nKTogUHJvbWlzZTxMZXNzb25FbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuTEVTU09OKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC53aGVyZSgnc2x1ZycsIHNsdWcpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIHJldHVybiByZXN1bHRbMF0/LlswXSBhcyBMZXNzb25FbnRyeSB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGxlc3NvbiBieSBzbHVnOiAke3NsdWd9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggY291cnNlIGRhdGEgZm9yIGEgZ2l2ZW4gbGVzc29uICh0byBnZXQgY291cnNlIGNvbnRleHQpXG4gKiBSZXR1cm5zIHRoZSBjb3Vyc2UgdGhhdCBjb250YWlucyB0aGlzIGxlc3NvblxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlQnlMZXNzb25VaWQobGVzc29uVWlkOiBzdHJpbmcpOiBQcm9taXNlPENvdXJzZUVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIC8vIEZpcnN0LCBmaW5kIHdoaWNoIG1vZHVsZSBjb250YWlucyB0aGlzIGxlc3NvblxuICAgIGNvbnN0IG1vZHVsZXNSZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLk1PRFVMRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2xlc3NvbnMnXSlcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZpbmQoKTtcbiAgICBcbiAgICBjb25zdCBtb2R1bGVzID0gKG1vZHVsZXNSZXN1bHRbMF0gfHwgW10pIGFzIE1vZHVsZUVudHJ5W107XG4gICAgbGV0IHRhcmdldE1vZHVsZVVpZDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG4gICAgXG4gICAgZm9yIChjb25zdCBtb2R1bGUgb2YgbW9kdWxlcykge1xuICAgICAgY29uc3QgbGVzc29ucyA9IEFycmF5LmlzQXJyYXkobW9kdWxlLmxlc3NvbnMpID8gbW9kdWxlLmxlc3NvbnMgOiBtb2R1bGUubGVzc29ucyA/IFttb2R1bGUubGVzc29uc10gOiBbXTtcbiAgICAgIGlmIChsZXNzb25zLnNvbWUobGVzc29uID0+IGxlc3Nvbi51aWQgPT09IGxlc3NvblVpZCkpIHtcbiAgICAgICAgdGFyZ2V0TW9kdWxlVWlkID0gbW9kdWxlLnVpZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmICghdGFyZ2V0TW9kdWxlVWlkKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICAvLyBOb3cgZmluZCB0aGUgY291cnNlIHRoYXQgY29udGFpbnMgdGhpcyBtb2R1bGVcbiAgICBjb25zdCBjb3Vyc2VzUmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydhdXRob3InLCAnbW9kdWxlcycsICdtb2R1bGVzLmxlc3NvbnMnXSlcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZpbmQoKTtcbiAgICBcbiAgICBjb25zdCBjb3Vyc2VzID0gKGNvdXJzZXNSZXN1bHRbMF0gfHwgW10pIGFzIENvdXJzZUVudHJ5W107XG4gICAgXG4gICAgZm9yIChjb25zdCBjb3Vyc2Ugb2YgY291cnNlcykge1xuICAgICAgY29uc3QgY291cnNlTW9kdWxlcyA9IEFycmF5LmlzQXJyYXkoY291cnNlLm1vZHVsZXMpID8gY291cnNlLm1vZHVsZXMgOiBjb3Vyc2UubW9kdWxlcyA/IFtjb3Vyc2UubW9kdWxlc10gOiBbXTtcbiAgICAgIGlmIChjb3Vyc2VNb2R1bGVzLnNvbWUobSA9PiBtLnVpZCA9PT0gdGFyZ2V0TW9kdWxlVWlkKSkge1xuICAgICAgICByZXR1cm4gY291cnNlO1xuICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjb3Vyc2UgYnkgbGVzc29uIFVJRDogJHtsZXNzb25VaWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBPbmJvYXJkaW5nIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhbGwgb25ib2FyZGluZyBzdGVwc1xuICogUmV0dXJucyBzdGVwcyBzb3J0ZWQgYnkgY3VycmVudF9zdGVwXG4gKiBUcmllcyBtdWx0aXBsZSBjb250ZW50IHR5cGUgbmFtZXMgaW4gY2FzZSB0aGUgZXhhY3QgbmFtZSBkaWZmZXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxPbmJvYXJkaW5nU3RlcHMoKTogUHJvbWlzZTxPbmJvYXJkaW5nQmxvY2tFbnRyeVtdPiB7XG4gIC8vIFRyeSBkaWZmZXJlbnQgcG9zc2libGUgY29udGVudCB0eXBlIG5hbWVzXG4gIGNvbnN0IHBvc3NpYmxlQ29udGVudFR5cGVzID0gW1xuICAgICdvbmJvYXJkaW5nX2Jsb2NrJyxcbiAgICAnb25ib2FyZGluZycsXG4gICAgJ29uYm9hcmRpbmdfc3RlcCcsXG4gICAgJ29uYm9hcmRpbmdfc3RlcHMnLFxuICAgICdtb2R1bGFyX3NlY3Rpb24nLCAgLy8gTWF5YmUgc3RvcmVkIGFzIG1vZHVsYXIgc2VjdGlvbnMgd2l0aCBzcGVjaWZpYyBwYXR0ZXJuXG4gIF07XG5cbiAgZm9yIChjb25zdCBjb250ZW50VHlwZSBvZiBwb3NzaWJsZUNvbnRlbnRUeXBlcykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBiYXNlUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZSkuUXVlcnkoKTtcbiAgICAgIFxuICAgICAgLy8gSWYgaXQncyBtb2R1bGFyX3NlY3Rpb24sIGZpbHRlciBmb3Igb25ib2FyZGluZyBlbnRyaWVzXG4gICAgICBpZiAoY29udGVudFR5cGUgPT09ICdtb2R1bGFyX3NlY3Rpb24nKSB7XG4gICAgICAgIGJhc2VRdWVyeS53aGVyZSgndGl0bGUnLCAnT25ib2FyZGluZyBTdGVwJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb25ib2FyZGluZy1zcGVjaWZpYyBjb250ZW50IHR5cGVzLCBpbmNsdWRlIG9wdGlvbiByZWZlcmVuY2VzXG4gICAgICAgIGJhc2VRdWVyeS5pbmNsdWRlUmVmZXJlbmNlKCdvcHRpb24nKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgYmFzZVF1ZXJ5LmFzY2VuZGluZygnY3VycmVudF9zdGVwJyk7ICAvLyBTb3J0IGJ5IHN0ZXAgbnVtYmVyXG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGJhc2VRdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgICBjb25zdCBlbnRyaWVzID0gKHJlc3VsdFswXSB8fCBbXSkgYXMgYW55W107XG4gICAgICBcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBBdHRlbXB0ZWQgJHtjb250ZW50VHlwZX06IEZvdW5kICR7ZW50cmllcy5sZW5ndGh9IGVudHJpZXNgKTtcbiAgICAgIFxuICAgICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBGaWx0ZXIgYW5kIHRyYW5zZm9ybSBlbnRyaWVzXG4gICAgICAgIGNvbnN0IG9uYm9hcmRpbmdFbnRyaWVzOiBPbmJvYXJkaW5nQmxvY2tFbnRyeVtdID0gZW50cmllc1xuICAgICAgICAgIC5maWx0ZXIoKGVudHJ5OiBhbnkpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIGVudHJ5IGhhcyBvbmJvYXJkaW5nLXJlbGF0ZWQgZmllbGRzXG4gICAgICAgICAgICByZXR1cm4gZW50cnkuY3VycmVudF9zdGVwICE9PSB1bmRlZmluZWQgfHwgXG4gICAgICAgICAgICAgICAgICAgZW50cnkubGFiZWxfdGV4dCAhPT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgZW50cnkudGl0bGU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ29uYm9hcmRpbmcnKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5tYXAoKGVudHJ5OiBhbnkpID0+IHtcbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0byBPbmJvYXJkaW5nQmxvY2tFbnRyeSBmb3JtYXRcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHVpZDogZW50cnkudWlkIHx8IGVudHJ5Ll9pZCB8fCAnJyxcbiAgICAgICAgICAgICAgdGl0bGU6IGVudHJ5LnRpdGxlLFxuICAgICAgICAgICAgICBjdXJyZW50X3N0ZXA6IGVudHJ5LmN1cnJlbnRfc3RlcCB8fCBwYXJzZUludChlbnRyeS50aXRsZT8ubWF0Y2goL1xcZCsvKT8uWzBdIHx8ICcxJyksXG4gICAgICAgICAgICAgIHRvdGFsX3N0ZXBzOiBlbnRyeS50b3RhbF9zdGVwcyB8fCA1LFxuICAgICAgICAgICAgICBsYWJlbF90ZXh0OiBlbnRyeS5sYWJlbF90ZXh0IHx8IGVudHJ5LnRpdGxlIHx8ICcnLFxuICAgICAgICAgICAgICBkaXNwbGF5X3R5cGU6IGVudHJ5LmRpc3BsYXlfdHlwZSB8fCAnQ2FyZCBHcmlkJyxcbiAgICAgICAgICAgICAgb3B0aW9uOiBlbnRyeS5vcHRpb24gfHwgW10sXG4gICAgICAgICAgICAgIGJhY2tfYnV0dG9uX3RleHQ6IGVudHJ5LmJhY2tfYnV0dG9uX3RleHQgfHwgJ0JhY2snLFxuICAgICAgICAgICAgICBuZXh0X2J1dHRvbl90ZXh0OiBlbnRyeS5uZXh0X2J1dHRvbl90ZXh0IHx8ICdDb250aW51ZScsXG4gICAgICAgICAgICB9IGFzIE9uYm9hcmRpbmdCbG9ja0VudHJ5O1xuICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKG9uYm9hcmRpbmdFbnRyaWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhgW0NNU10gU3VjY2Vzc2Z1bGx5IGZldGNoZWQgJHtvbmJvYXJkaW5nRW50cmllcy5sZW5ndGh9IG9uYm9hcmRpbmcgc3RlcHMgZnJvbSAke2NvbnRlbnRUeXBlfWApO1xuICAgICAgICAgIHJldHVybiBvbmJvYXJkaW5nRW50cmllcy5zb3J0KChhLCBiKSA9PiBhLmN1cnJlbnRfc3RlcCAtIGIuY3VycmVudF9zdGVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICAgIC8vIExvZyB0aGUgZXJyb3IgYnV0IGNvbnRpbnVlIHRyeWluZyBvdGhlciBjb250ZW50IHR5cGVzXG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gQ29udGVudCB0eXBlICR7Y29udGVudFR5cGV9IGZhaWxlZDpgLCBlcnJvci5tZXNzYWdlIHx8IGVycm9yKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIG5vIGNvbnRlbnQgdHlwZSBmb3VuZCwgdHJ5IHNlYXJjaGluZyBtb2R1bGFyX3NlY3Rpb24gZm9yIGFueSBvbmJvYXJkaW5nLXJlbGF0ZWQgZW50cmllc1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5QQUdFKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnc2VjdGlvbiddKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgY29uc3QgcGFnZXMgPSAocmVzdWx0WzBdIHx8IFtdKSBhcyBQYWdlRW50cnlbXTtcbiAgICBcbiAgICAvLyBMb29rIGZvciBwYWdlcyB3aXRoIFwiT25ib2FyZGluZ1wiIGluIHRpdGxlXG4gICAgY29uc3Qgb25ib2FyZGluZ1BhZ2VzID0gcGFnZXMuZmlsdGVyKHBhZ2UgPT4gXG4gICAgICBwYWdlLnRpdGxlPy50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdvbmJvYXJkaW5nJylcbiAgICApO1xuICAgIFxuICAgIGlmIChvbmJvYXJkaW5nUGFnZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc29sZS5sb2coJ1tDTVNdIEZvdW5kIG9uYm9hcmRpbmcgcGFnZShzKSwgYnV0IG5lZWQgcHJvcGVyIGNvbnRlbnQgdHlwZSBzdHJ1Y3R1cmUnKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc2VhcmNoaW5nIGZvciBvbmJvYXJkaW5nIHBhZ2U6JywgZXJyb3IpO1xuICB9XG5cbiAgY29uc29sZS53YXJuKCdbQ01TXSBObyBvbmJvYXJkaW5nIGNvbnRlbnQgdHlwZSBmb3VuZC4gUGxlYXNlIGNoZWNrOicpO1xuICBjb25zb2xlLndhcm4oJzEuIENvbnRlbnQgdHlwZSBuYW1lIGluIENvbnRlbnRzdGFjayAobWlnaHQgYmUgZGlmZmVyZW50KScpO1xuICBjb25zb2xlLndhcm4oJzIuIEVudHJpZXMgYXJlIHB1Ymxpc2hlZCcpO1xuICBjb25zb2xlLndhcm4oJzMuIEFQSSBrZXlzIGFuZCBlbnZpcm9ubWVudCBhcmUgY29ycmVjdCcpO1xuICByZXR1cm4gW107XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBBdXRoIEJyYW5kaW5nIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBBdXRoIEJyYW5kaW5nIGVudHJ5IGJ5IHBhZ2UgdHlwZSAobG9naW4gb3Igc2lnbnVwKVxuICogTWF0Y2hlcyBDb250ZW50c3RhY2sgc2NoZW1hOiBwYWdlX3R5cGUgaXMgXCJTaWduIEluXCIgb3IgXCJTaWduIFVwXCJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEF1dGhCcmFuZGluZyhwYWdlVHlwZTogJ2xvZ2luJyB8ICdzaWdudXAnKTogUHJvbWlzZTxBdXRoQnJhbmRpbmdFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICAvLyBDb252ZXJ0IGxvd2VyY2FzZSB0byBDb250ZW50c3RhY2sgZm9ybWF0XG4gICAgY29uc3QgcGFnZVR5cGVWYWx1ZSA9IHBhZ2VUeXBlID09PSAnbG9naW4nID8gJ1NpZ24gSW4nIDogJ1NpZ24gVXAnO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5BVVRIX0JSQU5ESU5HKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC53aGVyZSgncGFnZV90eXBlJywgcGFnZVR5cGVWYWx1ZSlcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnc3RhdHMnXSk7ICAvLyBzdGF0cyBpcyByZWZlcmVuY2UgdG8gaWNvbiBjb250ZW50IHR5cGVcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBjb25zdCBlbnRyaWVzID0gKHJlc3VsdFswXSB8fCBbXSkgYXMgYW55W107XG4gICAgXG4gICAgaWYgKGVudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZW50cnkgPSBlbnRyaWVzWzBdO1xuICAgICAgXG4gICAgICAvLyBMb2cgZm9yIGRlYnVnZ2luZ1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIEF1dGggYnJhbmRpbmcgZW50cnkgZm9yICR7cGFnZVR5cGV9OmAsIHtcbiAgICAgICAgaGVhZGxpbmU6IGVudHJ5LmhlYWRsaW5lLFxuICAgICAgICBzdWJ0aXRsZTogZW50cnkuc3VidGl0bGUsXG4gICAgICAgIGJyYW5kaW5nX2NvbnRlbnQ6IGVudHJ5LmJyYW5kaW5nX2NvbnRlbnQsXG4gICAgICAgIHN0YXRzOiBlbnRyeS5zdGF0cyxcbiAgICAgICAgc3RhdHNUeXBlOiBBcnJheS5pc0FycmF5KGVudHJ5LnN0YXRzKSA/ICdhcnJheScgOiB0eXBlb2YgZW50cnkuc3RhdHMsXG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdWlkOiBlbnRyeS51aWQgfHwgZW50cnkuX2lkIHx8ICcnLFxuICAgICAgICB0aXRsZTogZW50cnkudGl0bGUgfHwgJycsXG4gICAgICAgIHBhZ2VfdHlwZTogZW50cnkucGFnZV90eXBlIHx8IHBhZ2VUeXBlVmFsdWUsXG4gICAgICAgIGhlYWRsaW5lOiBlbnRyeS5oZWFkbGluZSxcbiAgICAgICAgc3VidGl0bGU6IGVudHJ5LnN1YnRpdGxlLCAgLy8gRmllbGQgbmFtZSBpcyBcInN1YnRpdGxlXCIgbm90IFwiZGVzY3JpcHRpb25cIlxuICAgICAgICBicmFuZGluZ19jb250ZW50OiBlbnRyeS5icmFuZGluZ19jb250ZW50LCAgLy8gUmljaCB0ZXh0IGNvbnRlbnRcbiAgICAgICAgc3RhdHM6IGVudHJ5LnN0YXRzLCAgLy8gQ2FuIGJlIHNpbmdsZSBJY29uRW50cnkgb3IgYXJyYXkgb2YgSWNvbkVudHJ5IChzaG91bGQgYmUgZXhwYW5kZWQgYnkgaW5jbHVkZVJlZmVyZW5jZSlcbiAgICAgICAgYmFja2dyb3VuZF9pbWFnZTogZW50cnkuYmFja2dyb3VuZF9pbWFnZSxcbiAgICAgIH0gYXMgQXV0aEJyYW5kaW5nRW50cnk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGF1dGggYnJhbmRpbmcgZm9yICR7cGFnZVR5cGV9OmAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyBFeHBvcnQgdGhlIFN0YWNrIGZvciBhZHZhbmNlZCB1c2FnZVxuZXhwb3J0IHsgU3RhY2sgfTtcbiJdLCJuYW1lcyI6WyJDb250ZW50c3RhY2siLCJTdGFjayIsImFwaV9rZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQ09OVEVOVFNUQUNLX0FQSV9LRVkiLCJDT05URU5UU1RBQ0tfQVBJX0tFWSIsImRlbGl2ZXJ5X3Rva2VuIiwiTkVYVF9QVUJMSUNfQ09OVEVOVFNUQUNLX0RFTElWRVJZX1RPS0VOIiwiQ09OVEVOVFNUQUNLX0RFTElWRVJZX1RPS0VOIiwiZW52aXJvbm1lbnQiLCJORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfRU5WSVJPTk1FTlQiLCJDT05URU5UU1RBQ0tfRU5WSVJPTk1FTlQiLCJicmFuY2giLCJORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfQlJBTkNIIiwiQ09OVEVOVFNUQUNLX0JSQU5DSCIsIkNPTlRFTlRfVFlQRVMiLCJQQUdFIiwiQkFOTkVSIiwiSEVBREVSIiwiRk9PVEVSIiwiTkVXU0xFVFRFUiIsIklDT04iLCJGQVEiLCJGQVFfUVVFU1RJT04iLCJURVNUSU1PTklBTCIsIkFVVEhPUiIsIkNPVVJTRSIsIk1PRFVMRSIsIkxFU1NPTiIsIkNBVEVHT1JZIiwiQ0FURUdPUllfQkxPQ0siLCJJTlNUUlVDVE9SIiwiT05CT0FSRElORyIsIkFVVEhfQlJBTkRJTkciLCJnZXRDdXJyZW50TG9jYWxlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsIkZBTExCQUNLX0xPQ0FMRSIsImdldEVudHJ5IiwiY29udGVudFR5cGUiLCJlbnRyeVVpZCIsInJlZmVyZW5jZUZpZWxkcyIsImxvY2FsZSIsInF1ZXJ5IiwiQ29udGVudFR5cGUiLCJFbnRyeSIsInRhcmdldExvY2FsZSIsImxhbmd1YWdlIiwiZm9yRWFjaCIsImZpZWxkIiwiaW5jbHVkZVJlZmVyZW5jZSIsInJlc3VsdCIsInRvSlNPTiIsImZldGNoIiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0RW50cmllcyIsIm9wdGlvbnMiLCJRdWVyeSIsImxpbWl0Iiwic2tpcCIsIm9yZGVyQnkiLCJvcmRlckRpcmVjdGlvbiIsImRlc2NlbmRpbmciLCJhc2NlbmRpbmciLCJ3aGVyZSIsIk9iamVjdCIsImVudHJpZXMiLCJrZXkiLCJ2YWx1ZSIsImZpbmQiLCJnZXRFbnRyeUJ5VXJsIiwidXJsIiwiZ2V0UGFnZSIsInRpdGxlIiwicGFnZUVudHJ5IiwiZmFsbGJhY2tSZXN1bHQiLCJsb2ciLCJmYWxsYmFja1F1ZXJ5Iiwic2VjdGlvbiIsImxlbmd0aCIsImdldFBhZ2VCeVVybCIsImxvY2FsZUVycm9yIiwiZ2V0QWxsQ2F0ZWdvcmllcyIsImdldEhlYWRlciIsImhlYWRlciIsImFjY2Vzc2liaWxpdHlfbGFuZ3VhZ2UiLCJnZXRBbGxIZWFkZXJzIiwiZ2V0Rm9vdGVyIiwiZm9vdGVyIiwiZ2V0TmV3c2xldHRlciIsIm5ld3NsZXR0ZXIiLCJnZXRGQVEiLCJmYXFFbnRyeSIsInNlY3Rpb25fdGl0bGUiLCJoYXNJY29uIiwiaWNvbiIsImZhcVF1ZXN0aW9uVHlwZSIsIkFycmF5IiwiaXNBcnJheSIsImZhcV9xdWVzdGlvbiIsImdldEFsbEJhbm5lcnMiLCJnZXRBbGxUZXN0aW1vbmlhbHMiLCJnZXRBbGxDb3Vyc2VzIiwiY291cnNlcyIsInJlc29sdmVkQ291cnNlcyIsIlByb21pc2UiLCJhbGwiLCJtYXAiLCJjb3Vyc2UiLCJyZXNvbHZlQXV0aG9yUmVmZXJlbmNlcyIsImdldEF1dGhvckJ5VWlkIiwidWlkIiwiYXV0aG9yIiwiYXV0aG9ycyIsInJlc29sdmVkQXV0aG9ycyIsImZ1bGxBdXRob3IiLCJwdXNoIiwidW5kZWZpbmVkIiwiZ2V0Q291cnNlQnlTbHVnIiwic2x1ZyIsIm1vZHVsZXMiLCJnZXRDb3Vyc2VCeVVpZCIsImdldE1vZHVsZUJ5VWlkIiwiZ2V0TGVzc29uQnlVaWQiLCJlbnRyeSIsImZhbGxiYWNrRW50cnkiLCJnZXRMZXNzb25CeVNsdWciLCJnZXRDb3Vyc2VCeUxlc3NvblVpZCIsImxlc3NvblVpZCIsIm1vZHVsZXNSZXN1bHQiLCJ0YXJnZXRNb2R1bGVVaWQiLCJtb2R1bGUiLCJsZXNzb25zIiwic29tZSIsImxlc3NvbiIsImNvdXJzZXNSZXN1bHQiLCJjb3Vyc2VNb2R1bGVzIiwibSIsImdldEFsbE9uYm9hcmRpbmdTdGVwcyIsInBvc3NpYmxlQ29udGVudFR5cGVzIiwiYmFzZVF1ZXJ5Iiwib25ib2FyZGluZ0VudHJpZXMiLCJmaWx0ZXIiLCJjdXJyZW50X3N0ZXAiLCJsYWJlbF90ZXh0IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIl9pZCIsInBhcnNlSW50IiwibWF0Y2giLCJ0b3RhbF9zdGVwcyIsImRpc3BsYXlfdHlwZSIsIm9wdGlvbiIsImJhY2tfYnV0dG9uX3RleHQiLCJuZXh0X2J1dHRvbl90ZXh0Iiwic29ydCIsImEiLCJiIiwibWVzc2FnZSIsInBhZ2VzIiwib25ib2FyZGluZ1BhZ2VzIiwicGFnZSIsIndhcm4iLCJnZXRBdXRoQnJhbmRpbmciLCJwYWdlVHlwZSIsInBhZ2VUeXBlVmFsdWUiLCJoZWFkbGluZSIsInN1YnRpdGxlIiwiYnJhbmRpbmdfY29udGVudCIsInN0YXRzIiwic3RhdHNUeXBlIiwicGFnZV90eXBlIiwiYmFja2dyb3VuZF9pbWFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contentstack.ts\n"));

/***/ })

});