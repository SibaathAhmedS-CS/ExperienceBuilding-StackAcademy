"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(main)/course/[slug]/page",{

/***/ "(app-pages-browser)/./src/lib/contentstack.ts":
/*!*********************************!*\
  !*** ./src/lib/contentstack.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTENT_TYPES: function() { return /* binding */ CONTENT_TYPES; },\n/* harmony export */   Stack: function() { return /* binding */ Stack; },\n/* harmony export */   getAllBanners: function() { return /* binding */ getAllBanners; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllCourses: function() { return /* binding */ getAllCourses; },\n/* harmony export */   getAllHeaders: function() { return /* binding */ getAllHeaders; },\n/* harmony export */   getAllOnboardingSteps: function() { return /* binding */ getAllOnboardingSteps; },\n/* harmony export */   getAllTestimonials: function() { return /* binding */ getAllTestimonials; },\n/* harmony export */   getAuthBranding: function() { return /* binding */ getAuthBranding; },\n/* harmony export */   getCourseByLessonUid: function() { return /* binding */ getCourseByLessonUid; },\n/* harmony export */   getCourseBySlug: function() { return /* binding */ getCourseBySlug; },\n/* harmony export */   getCourseByUid: function() { return /* binding */ getCourseByUid; },\n/* harmony export */   getEntries: function() { return /* binding */ getEntries; },\n/* harmony export */   getEntry: function() { return /* binding */ getEntry; },\n/* harmony export */   getEntryByUrl: function() { return /* binding */ getEntryByUrl; },\n/* harmony export */   getFAQ: function() { return /* binding */ getFAQ; },\n/* harmony export */   getFooter: function() { return /* binding */ getFooter; },\n/* harmony export */   getHeader: function() { return /* binding */ getHeader; },\n/* harmony export */   getLessonBySlug: function() { return /* binding */ getLessonBySlug; },\n/* harmony export */   getLessonByUid: function() { return /* binding */ getLessonByUid; },\n/* harmony export */   getModuleByUid: function() { return /* binding */ getModuleByUid; },\n/* harmony export */   getNewsletter: function() { return /* binding */ getNewsletter; },\n/* harmony export */   getPage: function() { return /* binding */ getPage; },\n/* harmony export */   getPageByUrl: function() { return /* binding */ getPageByUrl; }\n/* harmony export */ });\n/* harmony import */ var contentstack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! contentstack */ \"(app-pages-browser)/./node_modules/contentstack/dist/web/contentstack.js\");\n/* harmony import */ var contentstack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(contentstack__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Contentstack SDK Configuration\nconst Stack = contentstack__WEBPACK_IMPORTED_MODULE_0___default().Stack({\n    api_key: process.env.NEXT_PUBLIC_CONTENTSTACK_API_KEY || \"blt2b872601d3c5423f\" || 0,\n    delivery_token: process.env.NEXT_PUBLIC_CONTENTSTACK_DELIVERY_TOKEN || \"csab2298d637dc5b151fd67edc\" || 0,\n    environment: process.env.NEXT_PUBLIC_CONTENTSTACK_ENVIRONMENT || \"dev\" || 0,\n    branch: process.env.NEXT_PUBLIC_CONTENTSTACK_BRANCH || \"main\" || 0\n});\n// Content Type UIDs - Match your Contentstack setup\nconst CONTENT_TYPES = {\n    PAGE: \"modular_section\",\n    BANNER: \"banner\",\n    HEADER: \"header\",\n    FOOTER: \"footer\",\n    NEWSLETTER: \"newsletter\",\n    ICON: \"icon\",\n    FAQ: \"faq\",\n    FAQ_QUESTION: \"faq_question\",\n    TESTIMONIAL: \"testimonial\",\n    AUTHOR: \"author\",\n    COURSE: \"courses\",\n    MODULE: \"module\",\n    LESSON: \"lesson\",\n    CATEGORY: \"categories_block\",\n    CATEGORY_BLOCK: \"category_block\",\n    INSTRUCTOR: \"instructor\",\n    ONBOARDING: \"onboarding_block\",\n    AUTH_BRANDING: \"auth_branding\"\n};\n// ============================================\n// Generic Fetch Helpers\n// ============================================\n/**\n * Get current locale from localStorage (client-side) or default\n */ function getCurrentLocale() {\n    if (true) {\n        return localStorage.getItem(\"selectedLanguage\") || \"en-us\";\n    }\n    return \"en-us\";\n}\n/**\n * Default fallback locale when content is not available in selected locale\n */ const FALLBACK_LOCALE = \"en-us\";\n/**\n * Fetch single entry by content type and UID\n */ async function getEntry(contentType, entryUid) {\n    let referenceFields = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], locale = arguments.length > 3 ? arguments[3] : void 0;\n    try {\n        const query = Stack.ContentType(contentType).Entry(entryUid);\n        // Set locale if provided\n        const targetLocale = locale || getCurrentLocale();\n        query.language(targetLocale);\n        referenceFields.forEach((field)=>{\n            query.includeReference(field);\n        });\n        const result = await query.toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching entry: \".concat(contentType, \"/\").concat(entryUid), error);\n        return null;\n    }\n}\n/**\n * Fetch entries by content type with options\n */ async function getEntries(contentType) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const query = Stack.ContentType(contentType).Query();\n        // Set locale if provided\n        const targetLocale = options.locale || getCurrentLocale();\n        query.language(targetLocale);\n        if (options.referenceFields) {\n            options.referenceFields.forEach((field)=>{\n                query.includeReference(field);\n            });\n        }\n        if (options.limit) query.limit(options.limit);\n        if (options.skip) query.skip(options.skip);\n        if (options.orderBy) {\n            if (options.orderDirection === \"desc\") {\n                query.descending(options.orderBy);\n            } else {\n                query.ascending(options.orderBy);\n            }\n        }\n        if (options.where) {\n            Object.entries(options.where).forEach((param)=>{\n                let [key, value] = param;\n                query.where(key, value);\n            });\n        }\n        const result = await query.toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching entries: \".concat(contentType), error);\n        return [];\n    }\n}\n/**\n * Fetch entry by URL\n */ async function getEntryByUrl(contentType, url) {\n    let referenceFields = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    try {\n        var _result_;\n        const query = Stack.ContentType(contentType).Query().where(\"url\", url);\n        referenceFields.forEach((field)=>{\n            query.includeReference(field);\n        });\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching entry by URL: \".concat(contentType, \"/\").concat(url), error);\n        return null;\n    }\n}\n// ============================================\n// Page (Modular Section) Fetch Functions\n// ============================================\n/**\n * Fetch Page entry by title with all nested references\n * This is the main function for fetching page content\n */ async function getPage(title) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"title\", title).includeReference([\n            \"header\",\n            \"header.icon\",\n            \"section.hero_block.hero_banner\",\n            \"section.carousel_block.banner\",\n            \"section.category_block.icon\",\n            \"section.category_block.category\",\n            \"section.feature_block.features\",\n            \"section.workflow_block.stage\",\n            \"section.testimonial_block.testimonial\",\n            \"section.testimonial_block.testimonial.author\"\n        ]);\n        const result = await query.toJSON().find();\n        const pageEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // Debug logging\n        if (pageEntry) {\n            var _pageEntry_section;\n            console.log('[CMS] Page \"'.concat(title, '\" loaded with ').concat(((_pageEntry_section = pageEntry.section) === null || _pageEntry_section === void 0 ? void 0 : _pageEntry_section.length) || 0, \" sections\"));\n        }\n        return pageEntry;\n    } catch (error) {\n        console.error(\"Error fetching page: \".concat(title), error);\n        return null;\n    }\n}\n/**\n * Fetch Page entry by URL\n */ async function getPageByUrl(url) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"url\", url).includeReference([\n            \"header\",\n            \"header.icon\",\n            \"section.carousel_block.banner\",\n            \"section.category_block.icon\",\n            \"section.category_block.category\",\n            \"section.feature_block.features\",\n            \"section.workflow_block.stage\",\n            \"section.testimonial_block.testimonial\",\n            \"section.testimonial_block.testimonial.author\"\n        ]);\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching page by URL: \".concat(url), error);\n        return null;\n    }\n}\n// ============================================\n// Category Fetch Functions\n// ============================================\n/**\n * Fetch all Category entries\n */ async function getAllCategories() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.CATEGORY).Query().toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching categories\", error);\n        return [];\n    }\n}\n// ============================================\n// Header Fetch Functions\n// ============================================\n/**\n * Fetch Header entry by title\n * Header is always fetched in English since it contains non-translatable UI config\n * @param title - \"Landing Header\" or \"App Header\"\n */ async function getHeader(title) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.HEADER).Query().where(\"title\", title).includeReference(\"icon\");\n        // Always fetch header in English (contains UI configuration, not translated content)\n        query.language(\"en-us\");\n        const result = await query.toJSON().find();\n        const header = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        if (header) {\n            var _header_accessibility_language;\n            console.log('[CMS] Header \"'.concat(title, '\" loaded with ').concat(((_header_accessibility_language = header.accessibility_language) === null || _header_accessibility_language === void 0 ? void 0 : _header_accessibility_language.length) || 0, \" languages\"));\n        }\n        return header;\n    } catch (error) {\n        console.error(\"Error fetching header: \".concat(title), error);\n        return null;\n    }\n}\n/**\n * Fetch all Headers\n */ async function getAllHeaders() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.HEADER).Query().includeReference(\"icon\").toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching all headers\", error);\n        return [];\n    }\n}\n// ============================================\n// Footer & Newsletter Fetch Functions\n// ============================================\n/**\n * Fetch Footer entry (singleton)\n */ async function getFooter() {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.FOOTER).Query().includeReference(\"icon\");\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching footer\", error);\n        return null;\n    }\n}\n/**\n * Fetch Newsletter entry (singleton)\n */ async function getNewsletter() {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.NEWSLETTER).Query().includeReference(\"icon\");\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching newsletter\", error);\n        return null;\n    }\n}\n// ============================================\n// FAQ Fetch Functions\n// ============================================\n/**\n * Fetch FAQ entry (singleton) with nested references\n */ async function getFAQ() {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.FAQ).Query().includeReference([\n            \"icon\",\n            \"faq_question\"\n        ]);\n        const result = await query.toJSON().find();\n        const faqEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        if (faqEntry) {\n            console.log(\"FAQ Entry fetched:\", {\n                title: faqEntry.section_title,\n                hasIcon: !!faqEntry.icon,\n                faqQuestionType: Array.isArray(faqEntry.faq_question) ? \"array\" : \"object\"\n            });\n        }\n        return faqEntry;\n    } catch (error) {\n        console.error(\"Error fetching FAQ\", error);\n        return null;\n    }\n}\n// ============================================\n// Banner Fetch Functions\n// ============================================\n/**\n * Fetch all Banner entries\n */ async function getAllBanners() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.BANNER).Query().toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching banners\", error);\n        return [];\n    }\n}\n// ============================================\n// Testimonial Fetch Functions\n// ============================================\n/**\n * Fetch all Testimonial entries with author reference\n */ async function getAllTestimonials() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.TESTIMONIAL).Query().includeReference(\"author\").toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching testimonials\", error);\n        return [];\n    }\n}\n// ============================================\n// Course Fetch Functions\n// ============================================\n/**\n * Fetch all courses with author reference\n * Falls back to English if no content found in selected locale\n */ async function getAllCourses(locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        // First try with selected locale\n        const query = Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n            \"author\",\n            \"modules\"\n        ]);\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        const courses = result[0] || [];\n        // If no courses found and we're not already using fallback, try fallback locale\n        if (courses.length === 0 && targetLocale !== FALLBACK_LOCALE) {\n            console.log(\"[CMS] No courses found in \".concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n                \"author\",\n                \"modules\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            return fallbackResult[0] || [];\n        }\n        return courses;\n    } catch (error) {\n        console.error(\"Error fetching courses\", error);\n        return [];\n    }\n}\n/**\n * Fetch author by UID - always fetches from default locale since authors are not localized\n */ async function getAuthorByUid(uid) {\n    try {\n        const query = Stack.ContentType(CONTENT_TYPES.AUTHOR).Entry(uid);\n        query.language(FALLBACK_LOCALE);\n        const result = await query.toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching author by UID: \".concat(uid), error);\n        return null;\n    }\n}\n/**\n * Helper to resolve author references that may not be fully populated\n * When fetching localized content, references to non-localized entries may not resolve\n */ async function resolveAuthorReferences(course) {\n    if (!course.author) return course;\n    const authors = Array.isArray(course.author) ? course.author : [\n        course.author\n    ];\n    const resolvedAuthors = [];\n    for (const author of authors){\n        // Check if author is fully resolved (has title/bio) or just a reference\n        if (author.title && author.bio) {\n            // Already resolved\n            resolvedAuthors.push(author);\n        } else if (author.uid) {\n            // Need to fetch the full author data\n            console.log(\"[CMS] Resolving author reference: \".concat(author.uid));\n            const fullAuthor = await getAuthorByUid(author.uid);\n            if (fullAuthor) {\n                resolvedAuthors.push(fullAuthor);\n            }\n        }\n    }\n    course.author = resolvedAuthors.length > 0 ? resolvedAuthors : undefined;\n    return course;\n}\n/**\n * Fetch a single course by slug with all nested references\n * Falls back to English if no content found in selected locale\n */ async function getCourseBySlug(slug, locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        // First try with selected locale\n        const query = Stack.ContentType(CONTENT_TYPES.COURSE).Query().where(\"slug\", slug).includeReference([\n            \"author\",\n            \"modules\",\n            \"modules.lessons\"\n        ]);\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let course = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // If no course found and we're not already using fallback, try fallback locale\n        if (!course && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            console.log(\"[CMS] Course not found in \".concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Query().where(\"slug\", slug).includeReference([\n                \"author\",\n                \"modules\",\n                \"modules.lessons\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            course = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        // Ensure author references are fully resolved\n        if (course) {\n            course = await resolveAuthorReferences(course);\n            console.log('[CMS] Course \"'.concat(course.title, '\" loaded with ').concat(Array.isArray(course.modules) ? course.modules.length : course.modules ? 1 : 0, \" modules\"));\n        }\n        return course;\n    } catch (error) {\n        console.error(\"Error fetching course by slug: \".concat(slug), error);\n        return null;\n    }\n}\n/**\n * Fetch a single course by UID with all nested references\n * Falls back to English if no content found in selected locale\n */ async function getCourseByUid(uid, locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        let course = null;\n        // First try with selected locale\n        try {\n            const query = Stack.ContentType(CONTENT_TYPES.COURSE).Entry(uid).includeReference([\n                \"author\",\n                \"modules\",\n                \"modules.lessons\"\n            ]);\n            query.language(targetLocale);\n            const result = await query.toJSON().fetch();\n            course = result;\n        } catch (localeError) {\n            // If locale fetch fails and we're not already using fallback, try fallback\n            if (targetLocale !== FALLBACK_LOCALE) {\n                console.log(\"[CMS] Course UID \".concat(uid, \" not found in \").concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n                const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Entry(uid).includeReference([\n                    \"author\",\n                    \"modules\",\n                    \"modules.lessons\"\n                ]);\n                fallbackQuery.language(FALLBACK_LOCALE);\n                const fallbackResult = await fallbackQuery.toJSON().fetch();\n                course = fallbackResult;\n            } else {\n                throw localeError;\n            }\n        }\n        // Ensure author references are fully resolved\n        if (course) {\n            course = await resolveAuthorReferences(course);\n        }\n        return course;\n    } catch (error) {\n        console.error(\"Error fetching course by UID: \".concat(uid), error);\n        return null;\n    }\n}\n// ============================================\n// Module Fetch Functions\n// ============================================\n/**\n * Fetch a single module by UID with lessons\n */ async function getModuleByUid(uid) {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.MODULE).Entry(uid).includeReference([\n            \"lessons\"\n        ]).toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching module by UID: \".concat(uid), error);\n        return null;\n    }\n}\n// ============================================\n// Lesson Fetch Functions\n// ============================================\n/**\n * Fetch a single lesson by UID\n */ async function getLessonByUid(uid) {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.LESSON).Entry(uid).toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching lesson by UID: \".concat(uid), error);\n        return null;\n    }\n}\n/**\n * Fetch a single lesson by slug\n */ async function getLessonBySlug(slug) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.LESSON).Query().where(\"slug\", slug);\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching lesson by slug: \".concat(slug), error);\n        return null;\n    }\n}\n/**\n * Fetch course data for a given lesson (to get course context)\n * Returns the course that contains this lesson\n */ async function getCourseByLessonUid(lessonUid) {\n    try {\n        // First, find which module contains this lesson\n        const modulesResult = await Stack.ContentType(CONTENT_TYPES.MODULE).Query().includeReference([\n            \"lessons\"\n        ]).toJSON().find();\n        const modules = modulesResult[0] || [];\n        let targetModuleUid = null;\n        for (const module of modules){\n            const lessons = Array.isArray(module.lessons) ? module.lessons : module.lessons ? [\n                module.lessons\n            ] : [];\n            if (lessons.some((lesson)=>lesson.uid === lessonUid)) {\n                targetModuleUid = module.uid;\n                break;\n            }\n        }\n        if (!targetModuleUid) return null;\n        // Now find the course that contains this module\n        const coursesResult = await Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n            \"author\",\n            \"modules\",\n            \"modules.lessons\"\n        ]).toJSON().find();\n        const courses = coursesResult[0] || [];\n        for (const course of courses){\n            const courseModules = Array.isArray(course.modules) ? course.modules : course.modules ? [\n                course.modules\n            ] : [];\n            if (courseModules.some((m)=>m.uid === targetModuleUid)) {\n                return course;\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching course by lesson UID: \".concat(lessonUid), error);\n        return null;\n    }\n}\n// ============================================\n// Onboarding Fetch Functions\n// ============================================\n/**\n * Fetch all onboarding steps\n * Returns steps sorted by current_step\n * Tries multiple content type names in case the exact name differs\n */ async function getAllOnboardingSteps() {\n    // Try different possible content type names\n    const possibleContentTypes = [\n        \"onboarding_block\",\n        \"onboarding\",\n        \"onboarding_step\",\n        \"onboarding_steps\",\n        \"modular_section\"\n    ];\n    for (const contentType of possibleContentTypes){\n        try {\n            const baseQuery = Stack.ContentType(contentType).Query();\n            // If it's modular_section, filter for onboarding entries\n            if (contentType === \"modular_section\") {\n                baseQuery.where(\"title\", \"Onboarding Step\");\n            } else {\n                // For onboarding-specific content types, include option references\n                baseQuery.includeReference(\"option\");\n            }\n            baseQuery.ascending(\"current_step\"); // Sort by step number\n            const result = await baseQuery.toJSON().find();\n            const entries = result[0] || [];\n            console.log(\"[CMS] Attempted \".concat(contentType, \": Found \").concat(entries.length, \" entries\"));\n            if (entries.length > 0) {\n                // Filter and transform entries\n                const onboardingEntries = entries.filter((entry)=>{\n                    var _entry_title;\n                    // Check if entry has onboarding-related fields\n                    return entry.current_step !== undefined || entry.label_text !== undefined || ((_entry_title = entry.title) === null || _entry_title === void 0 ? void 0 : _entry_title.toLowerCase().includes(\"onboarding\"));\n                }).map((entry)=>{\n                    var _entry_title_match, _entry_title;\n                    // Transform to OnboardingBlockEntry format\n                    return {\n                        uid: entry.uid || entry._id || \"\",\n                        title: entry.title,\n                        current_step: entry.current_step || parseInt(((_entry_title = entry.title) === null || _entry_title === void 0 ? void 0 : (_entry_title_match = _entry_title.match(/\\d+/)) === null || _entry_title_match === void 0 ? void 0 : _entry_title_match[0]) || \"1\"),\n                        total_steps: entry.total_steps || 5,\n                        label_text: entry.label_text || entry.title || \"\",\n                        display_type: entry.display_type || \"Card Grid\",\n                        option: entry.option || [],\n                        back_button_text: entry.back_button_text || \"Back\",\n                        next_button_text: entry.next_button_text || \"Continue\"\n                    };\n                });\n                if (onboardingEntries.length > 0) {\n                    console.log(\"[CMS] Successfully fetched \".concat(onboardingEntries.length, \" onboarding steps from \").concat(contentType));\n                    return onboardingEntries.sort((a, b)=>a.current_step - b.current_step);\n                }\n            }\n        } catch (error) {\n            // Log the error but continue trying other content types\n            console.log(\"[CMS] Content type \".concat(contentType, \" failed:\"), error.message || error);\n            continue;\n        }\n    }\n    // If no content type found, try searching modular_section for any onboarding-related entries\n    try {\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().includeReference([\n            \"section\"\n        ]);\n        const result = await query.toJSON().find();\n        const pages = result[0] || [];\n        // Look for pages with \"Onboarding\" in title\n        const onboardingPages = pages.filter((page)=>{\n            var _page_title;\n            return (_page_title = page.title) === null || _page_title === void 0 ? void 0 : _page_title.toLowerCase().includes(\"onboarding\");\n        });\n        if (onboardingPages.length > 0) {\n            console.log(\"[CMS] Found onboarding page(s), but need proper content type structure\");\n        }\n    } catch (error) {\n        console.error(\"Error searching for onboarding page:\", error);\n    }\n    console.warn(\"[CMS] No onboarding content type found. Please check:\");\n    console.warn(\"1. Content type name in Contentstack (might be different)\");\n    console.warn(\"2. Entries are published\");\n    console.warn(\"3. API keys and environment are correct\");\n    return [];\n}\n// ============================================\n// Auth Branding Fetch Functions\n// ============================================\n/**\n * Fetch Auth Branding entry by page type (login or signup)\n * Matches Contentstack schema: page_type is \"Sign In\" or \"Sign Up\"\n */ async function getAuthBranding(pageType) {\n    try {\n        // Convert lowercase to Contentstack format\n        const pageTypeValue = pageType === \"login\" ? \"Sign In\" : \"Sign Up\";\n        const query = Stack.ContentType(CONTENT_TYPES.AUTH_BRANDING).Query().where(\"page_type\", pageTypeValue).includeReference([\n            \"stats\"\n        ]); // stats is reference to icon content type\n        const result = await query.toJSON().find();\n        const entries = result[0] || [];\n        if (entries.length > 0) {\n            const entry = entries[0];\n            // Log for debugging\n            console.log(\"[CMS] Auth branding entry for \".concat(pageType, \":\"), {\n                headline: entry.headline,\n                subtitle: entry.subtitle,\n                branding_content: entry.branding_content,\n                stats: entry.stats,\n                statsType: Array.isArray(entry.stats) ? \"array\" : typeof entry.stats\n            });\n            return {\n                uid: entry.uid || entry._id || \"\",\n                title: entry.title || \"\",\n                page_type: entry.page_type || pageTypeValue,\n                headline: entry.headline,\n                subtitle: entry.subtitle,\n                branding_content: entry.branding_content,\n                stats: entry.stats,\n                background_image: entry.background_image\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching auth branding for \".concat(pageType, \":\"), error);\n        return null;\n    }\n}\n// Export the Stack for advanced usage\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGVudHN0YWNrLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQW1CeEMsaUNBQWlDO0FBQ2pDLE1BQU1DLFFBQVFELHlEQUFrQixDQUFDO0lBQy9CRSxTQUFTQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLGdDQUFnQyxJQUFJRixxQkFBZ0MsSUFBSTtJQUM3RkksZ0JBQWdCSixPQUFPQSxDQUFDQyxHQUFHLENBQUNJLHVDQUF1QyxJQUFJTCw0QkFBdUMsSUFBSTtJQUNsSE8sYUFBYVAsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDTyxvQ0FBb0MsSUFBSVIsS0FBb0MsSUFBSTtJQUN6R1UsUUFBUVYsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDVSwrQkFBK0IsSUFBSVgsTUFBK0IsSUFBSTtBQUM1RjtBQWlCQSxvREFBb0Q7QUFDN0MsTUFBTWEsZ0JBQWdCO0lBQzNCQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLGNBQWM7SUFDZEMsYUFBYTtJQUNiQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsZ0JBQWdCO0lBQ2hCQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsZUFBZTtBQUNqQixFQUFXO0FBRVgsK0NBQStDO0FBQy9DLHdCQUF3QjtBQUN4QiwrQ0FBK0M7QUFFL0M7O0NBRUMsR0FDRCxTQUFTQztJQUNQLElBQUksSUFBa0IsRUFBYTtRQUNqQyxPQUFPQyxhQUFhQyxPQUFPLENBQUMsdUJBQXVCO0lBQ3JEO0lBQ0EsT0FBTztBQUNUO0FBRUE7O0NBRUMsR0FDRCxNQUFNQyxrQkFBa0I7QUFFeEI7O0NBRUMsR0FDTSxlQUFlQyxTQUNwQkMsV0FBbUIsRUFDbkJDLFFBQWdCO1FBQ2hCQyxrQkFBQUEsaUVBQTRCLEVBQUUsRUFD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QUFNK0IsZ0JBQWdCO1lBQzFDO1FBQ0Y7UUFFQSxPQUFPO0lBQ1QsRUFBRSxPQUFPbEgsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsb0NBQTZDLE9BQVQwRyxVQUFTLE1BQUkxRztRQUMvRCxPQUFPO0lBQ1Q7QUFDRjtBQUVBLHNDQUFzQztBQUNyQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvbGliL2NvbnRlbnRzdGFjay50cz9iMDY1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDb250ZW50c3RhY2sgZnJvbSAnY29udGVudHN0YWNrJztcbmltcG9ydCB7IFxuICBIZWFkZXJFbnRyeSwgXG4gIEZvb3RlckVudHJ5LCBcbiAgTmV3c2xldHRlckVudHJ5LCBcbiAgRkFRRW50cnksXG4gIFBhZ2VFbnRyeSxcbiAgQmFubmVyRW50cnksXG4gIFRlc3RpbW9uaWFsRW50cnksXG4gIEhlcm9CbG9ja0VudHJ5LFxuICBDYXRlZ29yeUVudHJ5LFxuICBDb3Vyc2VFbnRyeSxcbiAgTW9kdWxlRW50cnksXG4gIExlc3NvbkVudHJ5LFxuICBPbmJvYXJkaW5nQmxvY2tFbnRyeSxcbiAgQXV0aEJyYW5kaW5nRW50cnksXG4gIEF1dGhvckVudHJ5XG59IGZyb20gJ0AvdHlwZXMvY29udGVudHN0YWNrJztcblxuLy8gQ29udGVudHN0YWNrIFNESyBDb25maWd1cmF0aW9uXG5jb25zdCBTdGFjayA9IENvbnRlbnRzdGFjay5TdGFjayh7XG4gIGFwaV9rZXk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19BUElfS0VZIHx8IHByb2Nlc3MuZW52LkNPTlRFTlRTVEFDS19BUElfS0VZIHx8ICcnLFxuICBkZWxpdmVyeV90b2tlbjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ09OVEVOVFNUQUNLX0RFTElWRVJZX1RPS0VOIHx8IHByb2Nlc3MuZW52LkNPTlRFTlRTVEFDS19ERUxJVkVSWV9UT0tFTiB8fCAnJyxcbiAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19FTlZJUk9OTUVOVCB8fCBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfRU5WSVJPTk1FTlQgfHwgJ2RldicsXG4gIGJyYW5jaDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ09OVEVOVFNUQUNLX0JSQU5DSCB8fCBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfQlJBTkNIIHx8ICdtYWluJyxcbn0pO1xuXG4vLyBUeXBlIGRlZmluaXRpb25zIGZvciBDb250ZW50c3RhY2sgZW50cmllc1xuZXhwb3J0IGludGVyZmFjZSBDb250ZW50c3RhY2tFbnRyeSB7XG4gIHVpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50c3RhY2tBc3NldCB7XG4gIHVpZDogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgZmlsZW5hbWU6IHN0cmluZztcbn1cblxuLy8gQ29udGVudCBUeXBlIFVJRHMgLSBNYXRjaCB5b3VyIENvbnRlbnRzdGFjayBzZXR1cFxuZXhwb3J0IGNvbnN0IENPTlRFTlRfVFlQRVMgPSB7XG4gIFBBR0U6ICdtb2R1bGFyX3NlY3Rpb24nLCAgLy8gUGFnZSBjb250ZW50IHR5cGUgKG1vZHVsYXIgc2VjdGlvbnMpXG4gIEJBTk5FUjogJ2Jhbm5lcicsXG4gIEhFQURFUjogJ2hlYWRlcicsXG4gIEZPT1RFUjogJ2Zvb3RlcicsXG4gIE5FV1NMRVRURVI6ICduZXdzbGV0dGVyJyxcbiAgSUNPTjogJ2ljb24nLFxuICBGQVE6ICdmYXEnLFxuICBGQVFfUVVFU1RJT046ICdmYXFfcXVlc3Rpb24nLFxuICBURVNUSU1PTklBTDogJ3Rlc3RpbW9uaWFsJyxcbiAgQVVUSE9SOiAnYXV0aG9yJyxcbiAgQ09VUlNFOiAnY291cnNlcycsICAvLyBDb3Vyc2UgY29udGVudCB0eXBlXG4gIE1PRFVMRTogJ21vZHVsZScsICAgLy8gTW9kdWxlIGNvbnRlbnQgdHlwZVxuICBMRVNTT046ICdsZXNzb24nLCAgIC8vIExlc3NvbiBjb250ZW50IHR5cGVcbiAgQ0FURUdPUlk6ICdjYXRlZ29yaWVzX2Jsb2NrJywgIC8vIFVwZGF0ZWQgdG8gbWF0Y2ggbmV3IGNvbnRlbnQgdHlwZVxuICBDQVRFR09SWV9CTE9DSzogJ2NhdGVnb3J5X2Jsb2NrJywgIC8vIFNpbmdsZXRvbiBmb3IgcmVmZXJlbmNpbmcgY2F0ZWdvcmllc1xuICBJTlNUUlVDVE9SOiAnaW5zdHJ1Y3RvcicsXG4gIE9OQk9BUkRJTkc6ICdvbmJvYXJkaW5nX2Jsb2NrJywgIC8vIE9uYm9hcmRpbmcgc3RlcHMgY29udGVudCB0eXBlXG4gIEFVVEhfQlJBTkRJTkc6ICdhdXRoX2JyYW5kaW5nJywgIC8vIEF1dGggYnJhbmRpbmcgY29udGVudCB0eXBlIGZvciBsb2dpbi9zaWdudXAgcGFnZXNcbn0gYXMgY29uc3Q7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBHZW5lcmljIEZldGNoIEhlbHBlcnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgbG9jYWxlIGZyb20gbG9jYWxTdG9yYWdlIChjbGllbnQtc2lkZSkgb3IgZGVmYXVsdFxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50TG9jYWxlKCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2VsZWN0ZWRMYW5ndWFnZScpIHx8ICdlbi11cyc7XG4gIH1cbiAgcmV0dXJuICdlbi11cyc7XG59XG5cbi8qKlxuICogRGVmYXVsdCBmYWxsYmFjayBsb2NhbGUgd2hlbiBjb250ZW50IGlzIG5vdCBhdmFpbGFibGUgaW4gc2VsZWN0ZWQgbG9jYWxlXG4gKi9cbmNvbnN0IEZBTExCQUNLX0xPQ0FMRSA9ICdlbi11cyc7XG5cbi8qKlxuICogRmV0Y2ggc2luZ2xlIGVudHJ5IGJ5IGNvbnRlbnQgdHlwZSBhbmQgVUlEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbnRyeTxUID0gQ29udGVudHN0YWNrRW50cnk+KFxuICBjb250ZW50VHlwZTogc3RyaW5nLFxuICBlbnRyeVVpZDogc3RyaW5nLFxuICByZWZlcmVuY2VGaWVsZHM6IHN0cmluZ1tdID0gW10sXG4gIGxvY2FsZT86IHN0cmluZ1xuKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGUpLkVudHJ5KGVudHJ5VWlkKTtcbiAgICBcbiAgICAvLyBTZXQgbG9jYWxlIGlmIHByb3ZpZGVkXG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBxdWVyeS5sYW5ndWFnZSh0YXJnZXRMb2NhbGUpO1xuICAgIFxuICAgIHJlZmVyZW5jZUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgcXVlcnkuaW5jbHVkZVJlZmVyZW5jZShmaWVsZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5mZXRjaCgpO1xuICAgIHJldHVybiByZXN1bHQgYXMgVDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBlbnRyeTogJHtjb250ZW50VHlwZX0vJHtlbnRyeVVpZH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBlbnRyaWVzIGJ5IGNvbnRlbnQgdHlwZSB3aXRoIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVudHJpZXM8VCA9IENvbnRlbnRzdGFja0VudHJ5PihcbiAgY29udGVudFR5cGU6IHN0cmluZyxcbiAgb3B0aW9uczoge1xuICAgIHJlZmVyZW5jZUZpZWxkcz86IHN0cmluZ1tdO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIHNraXA/OiBudW1iZXI7XG4gICAgb3JkZXJCeT86IHN0cmluZztcbiAgICBsb2NhbGU/OiBzdHJpbmc7XG4gICAgb3JkZXJEaXJlY3Rpb24/OiAnYXNjJyB8ICdkZXNjJztcbiAgICB3aGVyZT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIH0gPSB7fVxuKTogUHJvbWlzZTxUW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKS5RdWVyeSgpO1xuICAgIFxuICAgIC8vIFNldCBsb2NhbGUgaWYgcHJvdmlkZWRcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBvcHRpb25zLmxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcbiAgICBcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2VGaWVsZHMpIHtcbiAgICAgIG9wdGlvbnMucmVmZXJlbmNlRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgIHF1ZXJ5LmluY2x1ZGVSZWZlcmVuY2UoZmllbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHF1ZXJ5LmxpbWl0KG9wdGlvbnMubGltaXQpO1xuICAgIGlmIChvcHRpb25zLnNraXApIHF1ZXJ5LnNraXAob3B0aW9ucy5za2lwKTtcblxuICAgIGlmIChvcHRpb25zLm9yZGVyQnkpIHtcbiAgICAgIGlmIChvcHRpb25zLm9yZGVyRGlyZWN0aW9uID09PSAnZGVzYycpIHtcbiAgICAgICAgcXVlcnkuZGVzY2VuZGluZyhvcHRpb25zLm9yZGVyQnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkuYXNjZW5kaW5nKG9wdGlvbnMub3JkZXJCeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMud2hlcmUpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMud2hlcmUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBxdWVyeS53aGVyZShrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICByZXR1cm4gKHJlc3VsdFswXSB8fCBbXSkgYXMgVFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGVudHJpZXM6ICR7Y29udGVudFR5cGV9YCwgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIGVudHJ5IGJ5IFVSTFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW50cnlCeVVybDxUID0gQ29udGVudHN0YWNrRW50cnk+KFxuICBjb250ZW50VHlwZTogc3RyaW5nLFxuICB1cmw6IHN0cmluZyxcbiAgcmVmZXJlbmNlRmllbGRzOiBzdHJpbmdbXSA9IFtdXG4pOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZSkuUXVlcnkoKS53aGVyZSgndXJsJywgdXJsKTtcbiAgICBcbiAgICByZWZlcmVuY2VGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIHF1ZXJ5LmluY2x1ZGVSZWZlcmVuY2UoZmllbGQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIHJldHVybiByZXN1bHRbMF0/LlswXSBhcyBUIHx8IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgZW50cnkgYnkgVVJMOiAke2NvbnRlbnRUeXBlfS8ke3VybH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBhZ2UgKE1vZHVsYXIgU2VjdGlvbikgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIFBhZ2UgZW50cnkgYnkgdGl0bGUgd2l0aCBhbGwgbmVzdGVkIHJlZmVyZW5jZXNcbiAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gZm9yIGZldGNoaW5nIHBhZ2UgY29udGVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFnZSh0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxQYWdlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLlBBR0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCd0aXRsZScsIHRpdGxlKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAnaGVhZGVyJyxcbiAgICAgICAgJ2hlYWRlci5pY29uJyxcbiAgICAgICAgJ3NlY3Rpb24uaGVyb19ibG9jay5oZXJvX2Jhbm5lcicsICAgICAgICAvLyBIZXJvIEJhbm5lciByZWZlcmVuY2VcbiAgICAgICAgJ3NlY3Rpb24uY2Fyb3VzZWxfYmxvY2suYmFubmVyJywgICAgICAgICAgLy8gQmFubmVyIHJlZmVyZW5jZXMgZm9yIGNhcm91c2VsXG4gICAgICAgICdzZWN0aW9uLmNhdGVnb3J5X2Jsb2NrLmljb24nLCAgICAgICAgICAgIC8vIExlZ2FjeSBjYXRlZ29yeSBpY29uc1xuICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5jYXRlZ29yeScsICAgICAgICAvLyBOZXcgY2F0ZWdvcnkgcmVmZXJlbmNlcyAoY2F0ZWdvcmllc19ibG9jaylcbiAgICAgICAgJ3NlY3Rpb24uZmVhdHVyZV9ibG9jay5mZWF0dXJlcycsICAgICAgICAgLy8gRmVhdHVyZSBpY29uc1xuICAgICAgICAnc2VjdGlvbi53b3JrZmxvd19ibG9jay5zdGFnZScsICAgICAgICAgICAvLyBXb3JrZmxvdyBzdGFnZSBpY29uc1xuICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbCcsICAvLyBUZXN0aW1vbmlhbCBlbnRyaWVzXG4gICAgICAgICdzZWN0aW9uLnRlc3RpbW9uaWFsX2Jsb2NrLnRlc3RpbW9uaWFsLmF1dGhvcicsIC8vIFRlc3RpbW9uaWFsIGF1dGhvcnNcbiAgICAgIF0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGNvbnN0IHBhZ2VFbnRyeSA9IHJlc3VsdFswXT8uWzBdIGFzIFBhZ2VFbnRyeSB8fCBudWxsO1xuICAgIFxuICAgIC8vIERlYnVnIGxvZ2dpbmdcbiAgICBpZiAocGFnZUVudHJ5KSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gUGFnZSBcIiR7dGl0bGV9XCIgbG9hZGVkIHdpdGggJHtwYWdlRW50cnkuc2VjdGlvbj8ubGVuZ3RoIHx8IDB9IHNlY3Rpb25zYCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBwYWdlRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcGFnZTogJHt0aXRsZX1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBQYWdlIGVudHJ5IGJ5IFVSTFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFnZUJ5VXJsKHVybDogc3RyaW5nKTogUHJvbWlzZTxQYWdlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLlBBR0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCd1cmwnLCB1cmwpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICdoZWFkZXInLFxuICAgICAgICAnaGVhZGVyLmljb24nLFxuICAgICAgICAnc2VjdGlvbi5jYXJvdXNlbF9ibG9jay5iYW5uZXInLFxuICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5pY29uJyxcbiAgICAgICAgJ3NlY3Rpb24uY2F0ZWdvcnlfYmxvY2suY2F0ZWdvcnknLCAgICAgICAgLy8gTmV3IGNhdGVnb3J5IHJlZmVyZW5jZXNcbiAgICAgICAgJ3NlY3Rpb24uZmVhdHVyZV9ibG9jay5mZWF0dXJlcycsXG4gICAgICAgICdzZWN0aW9uLndvcmtmbG93X2Jsb2NrLnN0YWdlJyxcbiAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwnLFxuICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbC5hdXRob3InLFxuICAgICAgXSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgcmV0dXJuIHJlc3VsdFswXT8uWzBdIGFzIFBhZ2VFbnRyeSB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIHBhZ2UgYnkgVVJMOiAke3VybH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENhdGVnb3J5IEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhbGwgQ2F0ZWdvcnkgZW50cmllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsQ2F0ZWdvcmllcygpOiBQcm9taXNlPENhdGVnb3J5RW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ0FURUdPUlkpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIHJldHVybiAocmVzdWx0WzBdIHx8IFtdKSBhcyBDYXRlZ29yeUVudHJ5W107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY2F0ZWdvcmllcycsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEhlYWRlciBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggSGVhZGVyIGVudHJ5IGJ5IHRpdGxlXG4gKiBIZWFkZXIgaXMgYWx3YXlzIGZldGNoZWQgaW4gRW5nbGlzaCBzaW5jZSBpdCBjb250YWlucyBub24tdHJhbnNsYXRhYmxlIFVJIGNvbmZpZ1xuICogQHBhcmFtIHRpdGxlIC0gXCJMYW5kaW5nIEhlYWRlclwiIG9yIFwiQXBwIEhlYWRlclwiXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRIZWFkZXIodGl0bGU6IHN0cmluZyk6IFByb21pc2U8SGVhZGVyRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkhFQURFUilcbiAgICAgIC5RdWVyeSgpXG4gICAgICAud2hlcmUoJ3RpdGxlJywgdGl0bGUpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZSgnaWNvbicpO1xuXG4gICAgLy8gQWx3YXlzIGZldGNoIGhlYWRlciBpbiBFbmdsaXNoIChjb250YWlucyBVSSBjb25maWd1cmF0aW9uLCBub3QgdHJhbnNsYXRlZCBjb250ZW50KVxuICAgIHF1ZXJ5Lmxhbmd1YWdlKCdlbi11cycpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGNvbnN0IGhlYWRlciA9IHJlc3VsdFswXT8uWzBdIGFzIEhlYWRlckVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgaWYgKGhlYWRlcikge1xuICAgICAgY29uc29sZS5sb2coYFtDTVNdIEhlYWRlciBcIiR7dGl0bGV9XCIgbG9hZGVkIHdpdGggJHtoZWFkZXIuYWNjZXNzaWJpbGl0eV9sYW5ndWFnZT8ubGVuZ3RoIHx8IDB9IGxhbmd1YWdlc2ApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gaGVhZGVyO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGhlYWRlcjogJHt0aXRsZX1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBhbGwgSGVhZGVyc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsSGVhZGVycygpOiBQcm9taXNlPEhlYWRlckVudHJ5W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkhFQURFUilcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZSgnaWNvbicpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIEhlYWRlckVudHJ5W107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYWxsIGhlYWRlcnMnLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBGb290ZXIgJiBOZXdzbGV0dGVyIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBGb290ZXIgZW50cnkgKHNpbmdsZXRvbilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZvb3RlcigpOiBQcm9taXNlPEZvb3RlckVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5GT09URVIpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2ljb24nKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdPy5bMF0gYXMgRm9vdGVyRW50cnkgfHwgbnVsbDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBmb290ZXInLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBOZXdzbGV0dGVyIGVudHJ5IChzaW5nbGV0b24pXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXROZXdzbGV0dGVyKCk6IFByb21pc2U8TmV3c2xldHRlckVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5ORVdTTEVUVEVSKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKCdpY29uJyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgcmV0dXJuIHJlc3VsdFswXT8uWzBdIGFzIE5ld3NsZXR0ZXJFbnRyeSB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIG5ld3NsZXR0ZXInLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEZBUSBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggRkFRIGVudHJ5IChzaW5nbGV0b24pIHdpdGggbmVzdGVkIHJlZmVyZW5jZXNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZBUSgpOiBQcm9taXNlPEZBUUVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5GQVEpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydpY29uJywgJ2ZhcV9xdWVzdGlvbiddKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBjb25zdCBmYXFFbnRyeSA9IHJlc3VsdFswXT8uWzBdIGFzIEZBUUVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgaWYgKGZhcUVudHJ5KSB7XG4gICAgICBjb25zb2xlLmxvZygnRkFRIEVudHJ5IGZldGNoZWQ6Jywge1xuICAgICAgICB0aXRsZTogZmFxRW50cnkuc2VjdGlvbl90aXRsZSxcbiAgICAgICAgaGFzSWNvbjogISFmYXFFbnRyeS5pY29uLFxuICAgICAgICBmYXFRdWVzdGlvblR5cGU6IEFycmF5LmlzQXJyYXkoZmFxRW50cnkuZmFxX3F1ZXN0aW9uKSA/ICdhcnJheScgOiAnb2JqZWN0JyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFxRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgRkFRJywgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBCYW5uZXIgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGFsbCBCYW5uZXIgZW50cmllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsQmFubmVycygpOiBQcm9taXNlPEJhbm5lckVudHJ5W10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkJBTk5FUilcbiAgICAgIC5RdWVyeSgpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIEJhbm5lckVudHJ5W107XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgYmFubmVycycsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFRlc3RpbW9uaWFsIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBhbGwgVGVzdGltb25pYWwgZW50cmllcyB3aXRoIGF1dGhvciByZWZlcmVuY2VcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbFRlc3RpbW9uaWFscygpOiBQcm9taXNlPFRlc3RpbW9uaWFsRW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuVEVTVElNT05JQUwpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2F1dGhvcicpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIFRlc3RpbW9uaWFsRW50cnlbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB0ZXN0aW1vbmlhbHMnLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDb3Vyc2UgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGFsbCBjb3Vyc2VzIHdpdGggYXV0aG9yIHJlZmVyZW5jZVxuICogRmFsbHMgYmFjayB0byBFbmdsaXNoIGlmIG5vIGNvbnRlbnQgZm91bmQgaW4gc2VsZWN0ZWQgbG9jYWxlXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxDb3Vyc2VzKGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8Q291cnNlRW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHRhcmdldExvY2FsZSA9IGxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgXG4gICAgLy8gRmlyc3QgdHJ5IHdpdGggc2VsZWN0ZWQgbG9jYWxlXG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2F1dGhvcicsICdtb2R1bGVzJ10pO1xuICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGNvbnN0IGNvdXJzZXMgPSAocmVzdWx0WzBdIHx8IFtdKSBhcyBDb3Vyc2VFbnRyeVtdO1xuICAgIFxuICAgIC8vIElmIG5vIGNvdXJzZXMgZm91bmQgYW5kIHdlJ3JlIG5vdCBhbHJlYWR5IHVzaW5nIGZhbGxiYWNrLCB0cnkgZmFsbGJhY2sgbG9jYWxlXG4gICAgaWYgKGNvdXJzZXMubGVuZ3RoID09PSAwICYmIHRhcmdldExvY2FsZSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gTm8gY291cnNlcyBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgICAgLlF1ZXJ5KClcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydhdXRob3InLCAnbW9kdWxlcyddKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIHJldHVybiAoZmFsbGJhY2tSZXN1bHRbMF0gfHwgW10pIGFzIENvdXJzZUVudHJ5W107XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb3Vyc2VzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvdXJzZXMnLCBlcnJvcik7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggYXV0aG9yIGJ5IFVJRCAtIGFsd2F5cyBmZXRjaGVzIGZyb20gZGVmYXVsdCBsb2NhbGUgc2luY2UgYXV0aG9ycyBhcmUgbm90IGxvY2FsaXplZFxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBdXRob3JCeVVpZCh1aWQ6IHN0cmluZyk6IFByb21pc2U8QXV0aG9yRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkFVVEhPUilcbiAgICAgIC5FbnRyeSh1aWQpO1xuICAgIHF1ZXJ5Lmxhbmd1YWdlKEZBTExCQUNLX0xPQ0FMRSk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICByZXR1cm4gcmVzdWx0IGFzIEF1dGhvckVudHJ5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGF1dGhvciBieSBVSUQ6ICR7dWlkfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byByZXNvbHZlIGF1dGhvciByZWZlcmVuY2VzIHRoYXQgbWF5IG5vdCBiZSBmdWxseSBwb3B1bGF0ZWRcbiAqIFdoZW4gZmV0Y2hpbmcgbG9jYWxpemVkIGNvbnRlbnQsIHJlZmVyZW5jZXMgdG8gbm9uLWxvY2FsaXplZCBlbnRyaWVzIG1heSBub3QgcmVzb2x2ZVxuICovXG5hc3luYyBmdW5jdGlvbiByZXNvbHZlQXV0aG9yUmVmZXJlbmNlcyhjb3Vyc2U6IENvdXJzZUVudHJ5KTogUHJvbWlzZTxDb3Vyc2VFbnRyeT4ge1xuICBpZiAoIWNvdXJzZS5hdXRob3IpIHJldHVybiBjb3Vyc2U7XG4gIFxuICBjb25zdCBhdXRob3JzID0gQXJyYXkuaXNBcnJheShjb3Vyc2UuYXV0aG9yKSA/IGNvdXJzZS5hdXRob3IgOiBbY291cnNlLmF1dGhvcl07XG4gIGNvbnN0IHJlc29sdmVkQXV0aG9yczogQXV0aG9yRW50cnlbXSA9IFtdO1xuICBcbiAgZm9yIChjb25zdCBhdXRob3Igb2YgYXV0aG9ycykge1xuICAgIC8vIENoZWNrIGlmIGF1dGhvciBpcyBmdWxseSByZXNvbHZlZCAoaGFzIHRpdGxlL2Jpbykgb3IganVzdCBhIHJlZmVyZW5jZVxuICAgIGlmIChhdXRob3IudGl0bGUgJiYgYXV0aG9yLmJpbykge1xuICAgICAgLy8gQWxyZWFkeSByZXNvbHZlZFxuICAgICAgcmVzb2x2ZWRBdXRob3JzLnB1c2goYXV0aG9yKTtcbiAgICB9IGVsc2UgaWYgKGF1dGhvci51aWQpIHtcbiAgICAgIC8vIE5lZWQgdG8gZmV0Y2ggdGhlIGZ1bGwgYXV0aG9yIGRhdGFcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBSZXNvbHZpbmcgYXV0aG9yIHJlZmVyZW5jZTogJHthdXRob3IudWlkfWApO1xuICAgICAgY29uc3QgZnVsbEF1dGhvciA9IGF3YWl0IGdldEF1dGhvckJ5VWlkKGF1dGhvci51aWQpO1xuICAgICAgaWYgKGZ1bGxBdXRob3IpIHtcbiAgICAgICAgcmVzb2x2ZWRBdXRob3JzLnB1c2goZnVsbEF1dGhvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIFxuICBjb3Vyc2UuYXV0aG9yID0gcmVzb2x2ZWRBdXRob3JzLmxlbmd0aCA+IDAgPyByZXNvbHZlZEF1dGhvcnMgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjb3Vyc2U7XG59XG5cbi8qKlxuICogRmV0Y2ggYSBzaW5nbGUgY291cnNlIGJ5IHNsdWcgd2l0aCBhbGwgbmVzdGVkIHJlZmVyZW5jZXNcbiAqIEZhbGxzIGJhY2sgdG8gRW5nbGlzaCBpZiBubyBjb250ZW50IGZvdW5kIGluIHNlbGVjdGVkIGxvY2FsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlQnlTbHVnKHNsdWc6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKTogUHJvbWlzZTxDb3Vyc2VFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIHNlbGVjdGVkIGxvY2FsZVxuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCdzbHVnJywgc2x1ZylcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICdtb2R1bGVzJyxcbiAgICAgICAgJ21vZHVsZXMubGVzc29ucydcbiAgICAgIF0pO1xuICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgbGV0IGNvdXJzZSA9IHJlc3VsdFswXT8uWzBdIGFzIENvdXJzZUVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgLy8gSWYgbm8gY291cnNlIGZvdW5kIGFuZCB3ZSdyZSBub3QgYWxyZWFkeSB1c2luZyBmYWxsYmFjaywgdHJ5IGZhbGxiYWNrIGxvY2FsZVxuICAgIGlmICghY291cnNlICYmIHRhcmdldExvY2FsZSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gQ291cnNlIG5vdCBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgICAgLlF1ZXJ5KClcbiAgICAgICAgLndoZXJlKCdzbHVnJywgc2x1ZylcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAgICdhdXRob3InLFxuICAgICAgICAgICdtb2R1bGVzJyxcbiAgICAgICAgICAnbW9kdWxlcy5sZXNzb25zJ1xuICAgICAgICBdKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIGNvdXJzZSA9IGZhbGxiYWNrUmVzdWx0WzBdPy5bMF0gYXMgQ291cnNlRW50cnkgfHwgbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIGF1dGhvciByZWZlcmVuY2VzIGFyZSBmdWxseSByZXNvbHZlZFxuICAgIGlmIChjb3Vyc2UpIHtcbiAgICAgIGNvdXJzZSA9IGF3YWl0IHJlc29sdmVBdXRob3JSZWZlcmVuY2VzKGNvdXJzZSk7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gQ291cnNlIFwiJHtjb3Vyc2UudGl0bGV9XCIgbG9hZGVkIHdpdGggJHtBcnJheS5pc0FycmF5KGNvdXJzZS5tb2R1bGVzKSA/IGNvdXJzZS5tb2R1bGVzLmxlbmd0aCA6IGNvdXJzZS5tb2R1bGVzID8gMSA6IDB9IG1vZHVsZXNgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvdXJzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjb3Vyc2UgYnkgc2x1ZzogJHtzbHVnfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIGNvdXJzZSBieSBVSUQgd2l0aCBhbGwgbmVzdGVkIHJlZmVyZW5jZXNcbiAqIEZhbGxzIGJhY2sgdG8gRW5nbGlzaCBpZiBubyBjb250ZW50IGZvdW5kIGluIHNlbGVjdGVkIGxvY2FsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlQnlVaWQodWlkOiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8Q291cnNlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBsZXQgY291cnNlOiBDb3Vyc2VFbnRyeSB8IG51bGwgPSBudWxsO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIHNlbGVjdGVkIGxvY2FsZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ09VUlNFKVxuICAgICAgICAuRW50cnkodWlkKVxuICAgICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICAgJ21vZHVsZXMnLFxuICAgICAgICAgICdtb2R1bGVzLmxlc3NvbnMnXG4gICAgICAgIF0pO1xuICAgICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICAgIGNvdXJzZSA9IHJlc3VsdCBhcyBDb3Vyc2VFbnRyeTtcbiAgICB9IGNhdGNoIChsb2NhbGVFcnJvcikge1xuICAgICAgLy8gSWYgbG9jYWxlIGZldGNoIGZhaWxzIGFuZCB3ZSdyZSBub3QgYWxyZWFkeSB1c2luZyBmYWxsYmFjaywgdHJ5IGZhbGxiYWNrXG4gICAgICBpZiAodGFyZ2V0TG9jYWxlICE9PSBGQUxMQkFDS19MT0NBTEUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtDTVNdIENvdXJzZSBVSUQgJHt1aWR9IG5vdCBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ09VUlNFKVxuICAgICAgICAgIC5FbnRyeSh1aWQpXG4gICAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICAgICAnbW9kdWxlcycsXG4gICAgICAgICAgICAnbW9kdWxlcy5sZXNzb25zJ1xuICAgICAgICAgIF0pO1xuICAgICAgICBmYWxsYmFja1F1ZXJ5Lmxhbmd1YWdlKEZBTExCQUNLX0xPQ0FMRSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBmYWxsYmFja1Jlc3VsdCA9IGF3YWl0IGZhbGxiYWNrUXVlcnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICAgICAgY291cnNlID0gZmFsbGJhY2tSZXN1bHQgYXMgQ291cnNlRW50cnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBsb2NhbGVFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIGF1dGhvciByZWZlcmVuY2VzIGFyZSBmdWxseSByZXNvbHZlZFxuICAgIGlmIChjb3Vyc2UpIHtcbiAgICAgIGNvdXJzZSA9IGF3YWl0IHJlc29sdmVBdXRob3JSZWZlcmVuY2VzKGNvdXJzZSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb3Vyc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgY291cnNlIGJ5IFVJRDogJHt1aWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNb2R1bGUgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIG1vZHVsZSBieSBVSUQgd2l0aCBsZXNzb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2R1bGVCeVVpZCh1aWQ6IHN0cmluZyk6IFByb21pc2U8TW9kdWxlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5NT0RVTEUpXG4gICAgICAuRW50cnkodWlkKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydsZXNzb25zJ10pXG4gICAgICAudG9KU09OKClcbiAgICAgIC5mZXRjaCgpO1xuICAgIHJldHVybiByZXN1bHQgYXMgTW9kdWxlRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbW9kdWxlIGJ5IFVJRDogJHt1aWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMZXNzb24gRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIGxlc3NvbiBieSBVSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExlc3NvbkJ5VWlkKHVpZDogc3RyaW5nKTogUHJvbWlzZTxMZXNzb25FbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkxFU1NPTilcbiAgICAgIC5FbnRyeSh1aWQpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5mZXRjaCgpO1xuICAgIHJldHVybiByZXN1bHQgYXMgTGVzc29uRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGVzc29uIGJ5IFVJRDogJHt1aWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggYSBzaW5nbGUgbGVzc29uIGJ5IHNsdWdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExlc3NvbkJ5U2x1ZyhzbHVnOiBzdHJpbmcpOiBQcm9taXNlPExlc3NvbkVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5MRVNTT04pXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCdzbHVnJywgc2x1Zyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgcmV0dXJuIHJlc3VsdFswXT8uWzBdIGFzIExlc3NvbkVudHJ5IHx8IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGVzc29uIGJ5IHNsdWc6ICR7c2x1Z31gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBjb3Vyc2UgZGF0YSBmb3IgYSBnaXZlbiBsZXNzb24gKHRvIGdldCBjb3Vyc2UgY29udGV4dClcbiAqIFJldHVybnMgdGhlIGNvdXJzZSB0aGF0IGNvbnRhaW5zIHRoaXMgbGVzc29uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VCeUxlc3NvblVpZChsZXNzb25VaWQ6IHN0cmluZyk6IFByb21pc2U8Q291cnNlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgLy8gRmlyc3QsIGZpbmQgd2hpY2ggbW9kdWxlIGNvbnRhaW5zIHRoaXMgbGVzc29uXG4gICAgY29uc3QgbW9kdWxlc1Jlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuTU9EVUxFKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnbGVzc29ucyddKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIFxuICAgIGNvbnN0IG1vZHVsZXMgPSAobW9kdWxlc1Jlc3VsdFswXSB8fCBbXSkgYXMgTW9kdWxlRW50cnlbXTtcbiAgICBsZXQgdGFyZ2V0TW9kdWxlVWlkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICBjb25zdCBsZXNzb25zID0gQXJyYXkuaXNBcnJheShtb2R1bGUubGVzc29ucykgPyBtb2R1bGUubGVzc29ucyA6IG1vZHVsZS5sZXNzb25zID8gW21vZHVsZS5sZXNzb25zXSA6IFtdO1xuICAgICAgaWYgKGxlc3NvbnMuc29tZShsZXNzb24gPT4gbGVzc29uLnVpZCA9PT0gbGVzc29uVWlkKSkge1xuICAgICAgICB0YXJnZXRNb2R1bGVVaWQgPSBtb2R1bGUudWlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKCF0YXJnZXRNb2R1bGVVaWQpIHJldHVybiBudWxsO1xuICAgIFxuICAgIC8vIE5vdyBmaW5kIHRoZSBjb3Vyc2UgdGhhdCBjb250YWlucyB0aGlzIG1vZHVsZVxuICAgIGNvbnN0IGNvdXJzZXNSZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2F1dGhvcicsICdtb2R1bGVzJywgJ21vZHVsZXMubGVzc29ucyddKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIFxuICAgIGNvbnN0IGNvdXJzZXMgPSAoY291cnNlc1Jlc3VsdFswXSB8fCBbXSkgYXMgQ291cnNlRW50cnlbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGNvdXJzZSBvZiBjb3Vyc2VzKSB7XG4gICAgICBjb25zdCBjb3Vyc2VNb2R1bGVzID0gQXJyYXkuaXNBcnJheShjb3Vyc2UubW9kdWxlcykgPyBjb3Vyc2UubW9kdWxlcyA6IGNvdXJzZS5tb2R1bGVzID8gW2NvdXJzZS5tb2R1bGVzXSA6IFtdO1xuICAgICAgaWYgKGNvdXJzZU1vZHVsZXMuc29tZShtID0+IG0udWlkID09PSB0YXJnZXRNb2R1bGVVaWQpKSB7XG4gICAgICAgIHJldHVybiBjb3Vyc2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNvdXJzZSBieSBsZXNzb24gVUlEOiAke2xlc3NvblVpZH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE9uYm9hcmRpbmcgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGFsbCBvbmJvYXJkaW5nIHN0ZXBzXG4gKiBSZXR1cm5zIHN0ZXBzIHNvcnRlZCBieSBjdXJyZW50X3N0ZXBcbiAqIFRyaWVzIG11bHRpcGxlIGNvbnRlbnQgdHlwZSBuYW1lcyBpbiBjYXNlIHRoZSBleGFjdCBuYW1lIGRpZmZlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbE9uYm9hcmRpbmdTdGVwcygpOiBQcm9taXNlPE9uYm9hcmRpbmdCbG9ja0VudHJ5W10+IHtcbiAgLy8gVHJ5IGRpZmZlcmVudCBwb3NzaWJsZSBjb250ZW50IHR5cGUgbmFtZXNcbiAgY29uc3QgcG9zc2libGVDb250ZW50VHlwZXMgPSBbXG4gICAgJ29uYm9hcmRpbmdfYmxvY2snLFxuICAgICdvbmJvYXJkaW5nJyxcbiAgICAnb25ib2FyZGluZ19zdGVwJyxcbiAgICAnb25ib2FyZGluZ19zdGVwcycsXG4gICAgJ21vZHVsYXJfc2VjdGlvbicsICAvLyBNYXliZSBzdG9yZWQgYXMgbW9kdWxhciBzZWN0aW9ucyB3aXRoIHNwZWNpZmljIHBhdHRlcm5cbiAgXTtcblxuICBmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIHBvc3NpYmxlQ29udGVudFR5cGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJhc2VRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKS5RdWVyeSgpO1xuICAgICAgXG4gICAgICAvLyBJZiBpdCdzIG1vZHVsYXJfc2VjdGlvbiwgZmlsdGVyIGZvciBvbmJvYXJkaW5nIGVudHJpZXNcbiAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ21vZHVsYXJfc2VjdGlvbicpIHtcbiAgICAgICAgYmFzZVF1ZXJ5LndoZXJlKCd0aXRsZScsICdPbmJvYXJkaW5nIFN0ZXAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbmJvYXJkaW5nLXNwZWNpZmljIGNvbnRlbnQgdHlwZXMsIGluY2x1ZGUgb3B0aW9uIHJlZmVyZW5jZXNcbiAgICAgICAgYmFzZVF1ZXJ5LmluY2x1ZGVSZWZlcmVuY2UoJ29wdGlvbicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBiYXNlUXVlcnkuYXNjZW5kaW5nKCdjdXJyZW50X3N0ZXAnKTsgIC8vIFNvcnQgYnkgc3RlcCBudW1iZXJcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmFzZVF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSAocmVzdWx0WzBdIHx8IFtdKSBhcyBhbnlbXTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFtDTVNdIEF0dGVtcHRlZCAke2NvbnRlbnRUeXBlfTogRm91bmQgJHtlbnRyaWVzLmxlbmd0aH0gZW50cmllc2ApO1xuICAgICAgXG4gICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIEZpbHRlciBhbmQgdHJhbnNmb3JtIGVudHJpZXNcbiAgICAgICAgY29uc3Qgb25ib2FyZGluZ0VudHJpZXM6IE9uYm9hcmRpbmdCbG9ja0VudHJ5W10gPSBlbnRyaWVzXG4gICAgICAgICAgLmZpbHRlcigoZW50cnk6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgaGFzIG9uYm9hcmRpbmctcmVsYXRlZCBmaWVsZHNcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5jdXJyZW50X3N0ZXAgIT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgICAgICAgICAgICBlbnRyeS5sYWJlbF90ZXh0ICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICBlbnRyeS50aXRsZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnb25ib2FyZGluZycpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcCgoZW50cnk6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRvIE9uYm9hcmRpbmdCbG9ja0VudHJ5IGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdWlkOiBlbnRyeS51aWQgfHwgZW50cnkuX2lkIHx8ICcnLFxuICAgICAgICAgICAgICB0aXRsZTogZW50cnkudGl0bGUsXG4gICAgICAgICAgICAgIGN1cnJlbnRfc3RlcDogZW50cnkuY3VycmVudF9zdGVwIHx8IHBhcnNlSW50KGVudHJ5LnRpdGxlPy5tYXRjaCgvXFxkKy8pPy5bMF0gfHwgJzEnKSxcbiAgICAgICAgICAgICAgdG90YWxfc3RlcHM6IGVudHJ5LnRvdGFsX3N0ZXBzIHx8IDUsXG4gICAgICAgICAgICAgIGxhYmVsX3RleHQ6IGVudHJ5LmxhYmVsX3RleHQgfHwgZW50cnkudGl0bGUgfHwgJycsXG4gICAgICAgICAgICAgIGRpc3BsYXlfdHlwZTogZW50cnkuZGlzcGxheV90eXBlIHx8ICdDYXJkIEdyaWQnLFxuICAgICAgICAgICAgICBvcHRpb246IGVudHJ5Lm9wdGlvbiB8fCBbXSxcbiAgICAgICAgICAgICAgYmFja19idXR0b25fdGV4dDogZW50cnkuYmFja19idXR0b25fdGV4dCB8fCAnQmFjaycsXG4gICAgICAgICAgICAgIG5leHRfYnV0dG9uX3RleHQ6IGVudHJ5Lm5leHRfYnV0dG9uX3RleHQgfHwgJ0NvbnRpbnVlJyxcbiAgICAgICAgICAgIH0gYXMgT25ib2FyZGluZ0Jsb2NrRW50cnk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAob25ib2FyZGluZ0VudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCAke29uYm9hcmRpbmdFbnRyaWVzLmxlbmd0aH0gb25ib2FyZGluZyBzdGVwcyBmcm9tICR7Y29udGVudFR5cGV9YCk7XG4gICAgICAgICAgcmV0dXJuIG9uYm9hcmRpbmdFbnRyaWVzLnNvcnQoKGEsIGIpID0+IGEuY3VycmVudF9zdGVwIC0gYi5jdXJyZW50X3N0ZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgLy8gTG9nIHRoZSBlcnJvciBidXQgY29udGludWUgdHJ5aW5nIG90aGVyIGNvbnRlbnQgdHlwZXNcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBDb250ZW50IHR5cGUgJHtjb250ZW50VHlwZX0gZmFpbGVkOmAsIGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gY29udGVudCB0eXBlIGZvdW5kLCB0cnkgc2VhcmNoaW5nIG1vZHVsYXJfc2VjdGlvbiBmb3IgYW55IG9uYm9hcmRpbmctcmVsYXRlZCBlbnRyaWVzXG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLlBBR0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydzZWN0aW9uJ10pO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBjb25zdCBwYWdlcyA9IChyZXN1bHRbMF0gfHwgW10pIGFzIFBhZ2VFbnRyeVtdO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIHBhZ2VzIHdpdGggXCJPbmJvYXJkaW5nXCIgaW4gdGl0bGVcbiAgICBjb25zdCBvbmJvYXJkaW5nUGFnZXMgPSBwYWdlcy5maWx0ZXIocGFnZSA9PiBcbiAgICAgIHBhZ2UudGl0bGU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ29uYm9hcmRpbmcnKVxuICAgICk7XG4gICAgXG4gICAgaWYgKG9uYm9hcmRpbmdQYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0NNU10gRm91bmQgb25ib2FyZGluZyBwYWdlKHMpLCBidXQgbmVlZCBwcm9wZXIgY29udGVudCB0eXBlIHN0cnVjdHVyZScpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgZm9yIG9uYm9hcmRpbmcgcGFnZTonLCBlcnJvcik7XG4gIH1cblxuICBjb25zb2xlLndhcm4oJ1tDTVNdIE5vIG9uYm9hcmRpbmcgY29udGVudCB0eXBlIGZvdW5kLiBQbGVhc2UgY2hlY2s6Jyk7XG4gIGNvbnNvbGUud2FybignMS4gQ29udGVudCB0eXBlIG5hbWUgaW4gQ29udGVudHN0YWNrIChtaWdodCBiZSBkaWZmZXJlbnQpJyk7XG4gIGNvbnNvbGUud2FybignMi4gRW50cmllcyBhcmUgcHVibGlzaGVkJyk7XG4gIGNvbnNvbGUud2FybignMy4gQVBJIGtleXMgYW5kIGVudmlyb25tZW50IGFyZSBjb3JyZWN0Jyk7XG4gIHJldHVybiBbXTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEF1dGggQnJhbmRpbmcgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIEF1dGggQnJhbmRpbmcgZW50cnkgYnkgcGFnZSB0eXBlIChsb2dpbiBvciBzaWdudXApXG4gKiBNYXRjaGVzIENvbnRlbnRzdGFjayBzY2hlbWE6IHBhZ2VfdHlwZSBpcyBcIlNpZ24gSW5cIiBvciBcIlNpZ24gVXBcIlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aEJyYW5kaW5nKHBhZ2VUeXBlOiAnbG9naW4nIHwgJ3NpZ251cCcpOiBQcm9taXNlPEF1dGhCcmFuZGluZ0VudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIC8vIENvbnZlcnQgbG93ZXJjYXNlIHRvIENvbnRlbnRzdGFjayBmb3JtYXRcbiAgICBjb25zdCBwYWdlVHlwZVZhbHVlID0gcGFnZVR5cGUgPT09ICdsb2dpbicgPyAnU2lnbiBJbicgOiAnU2lnbiBVcCc7XG4gICAgXG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkFVVEhfQlJBTkRJTkcpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCdwYWdlX3R5cGUnLCBwYWdlVHlwZVZhbHVlKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydzdGF0cyddKTsgIC8vIHN0YXRzIGlzIHJlZmVyZW5jZSB0byBpY29uIGNvbnRlbnQgdHlwZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGNvbnN0IGVudHJpZXMgPSAocmVzdWx0WzBdIHx8IFtdKSBhcyBhbnlbXTtcbiAgICBcbiAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgICBcbiAgICAgIC8vIExvZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gQXV0aCBicmFuZGluZyBlbnRyeSBmb3IgJHtwYWdlVHlwZX06YCwge1xuICAgICAgICBoZWFkbGluZTogZW50cnkuaGVhZGxpbmUsXG4gICAgICAgIHN1YnRpdGxlOiBlbnRyeS5zdWJ0aXRsZSxcbiAgICAgICAgYnJhbmRpbmdfY29udGVudDogZW50cnkuYnJhbmRpbmdfY29udGVudCxcbiAgICAgICAgc3RhdHM6IGVudHJ5LnN0YXRzLFxuICAgICAgICBzdGF0c1R5cGU6IEFycmF5LmlzQXJyYXkoZW50cnkuc3RhdHMpID8gJ2FycmF5JyA6IHR5cGVvZiBlbnRyeS5zdGF0cyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1aWQ6IGVudHJ5LnVpZCB8fCBlbnRyeS5faWQgfHwgJycsXG4gICAgICAgIHRpdGxlOiBlbnRyeS50aXRsZSB8fCAnJyxcbiAgICAgICAgcGFnZV90eXBlOiBlbnRyeS5wYWdlX3R5cGUgfHwgcGFnZVR5cGVWYWx1ZSxcbiAgICAgICAgaGVhZGxpbmU6IGVudHJ5LmhlYWRsaW5lLFxuICAgICAgICBzdWJ0aXRsZTogZW50cnkuc3VidGl0bGUsICAvLyBGaWVsZCBuYW1lIGlzIFwic3VidGl0bGVcIiBub3QgXCJkZXNjcmlwdGlvblwiXG4gICAgICAgIGJyYW5kaW5nX2NvbnRlbnQ6IGVudHJ5LmJyYW5kaW5nX2NvbnRlbnQsICAvLyBSaWNoIHRleHQgY29udGVudFxuICAgICAgICBzdGF0czogZW50cnkuc3RhdHMsICAvLyBDYW4gYmUgc2luZ2xlIEljb25FbnRyeSBvciBhcnJheSBvZiBJY29uRW50cnkgKHNob3VsZCBiZSBleHBhbmRlZCBieSBpbmNsdWRlUmVmZXJlbmNlKVxuICAgICAgICBiYWNrZ3JvdW5kX2ltYWdlOiBlbnRyeS5iYWNrZ3JvdW5kX2ltYWdlLFxuICAgICAgfSBhcyBBdXRoQnJhbmRpbmdFbnRyeTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYXV0aCBicmFuZGluZyBmb3IgJHtwYWdlVHlwZX06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIEV4cG9ydCB0aGUgU3RhY2sgZm9yIGFkdmFuY2VkIHVzYWdlXG5leHBvcnQgeyBTdGFjayB9O1xuIl0sIm5hbWVzIjpbIkNvbnRlbnRzdGFjayIsIlN0YWNrIiwiYXBpX2tleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfQVBJX0tFWSIsIkNPTlRFTlRTVEFDS19BUElfS0VZIiwiZGVsaXZlcnlfdG9rZW4iLCJORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfREVMSVZFUllfVE9LRU4iLCJDT05URU5UU1RBQ0tfREVMSVZFUllfVE9LRU4iLCJlbnZpcm9ubWVudCIsIk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19FTlZJUk9OTUVOVCIsIkNPTlRFTlRTVEFDS19FTlZJUk9OTUVOVCIsImJyYW5jaCIsIk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19CUkFOQ0giLCJDT05URU5UU1RBQ0tfQlJBTkNIIiwiQ09OVEVOVF9UWVBFUyIsIlBBR0UiLCJCQU5ORVIiLCJIRUFERVIiLCJGT09URVIiLCJORVdTTEVUVEVSIiwiSUNPTiIsIkZBUSIsIkZBUV9RVUVTVElPTiIsIlRFU1RJTU9OSUFMIiwiQVVUSE9SIiwiQ09VUlNFIiwiTU9EVUxFIiwiTEVTU09OIiwiQ0FURUdPUlkiLCJDQVRFR09SWV9CTE9DSyIsIklOU1RSVUNUT1IiLCJPTkJPQVJESU5HIiwiQVVUSF9CUkFORElORyIsImdldEN1cnJlbnRMb2NhbGUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiRkFMTEJBQ0tfTE9DQUxFIiwiZ2V0RW50cnkiLCJjb250ZW50VHlwZSIsImVudHJ5VWlkIiwicmVmZXJlbmNlRmllbGRzIiwibG9jYWxlIiwicXVlcnkiLCJDb250ZW50VHlwZSIsIkVudHJ5IiwidGFyZ2V0TG9jYWxlIiwibGFuZ3VhZ2UiLCJmb3JFYWNoIiwiZmllbGQiLCJpbmNsdWRlUmVmZXJlbmNlIiwicmVzdWx0IiwidG9KU09OIiwiZmV0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJnZXRFbnRyaWVzIiwib3B0aW9ucyIsIlF1ZXJ5IiwibGltaXQiLCJza2lwIiwib3JkZXJCeSIsIm9yZGVyRGlyZWN0aW9uIiwiZGVzY2VuZGluZyIsImFzY2VuZGluZyIsIndoZXJlIiwiT2JqZWN0IiwiZW50cmllcyIsImtleSIsInZhbHVlIiwiZmluZCIsImdldEVudHJ5QnlVcmwiLCJ1cmwiLCJnZXRQYWdlIiwidGl0bGUiLCJwYWdlRW50cnkiLCJsb2ciLCJzZWN0aW9uIiwibGVuZ3RoIiwiZ2V0UGFnZUJ5VXJsIiwiZ2V0QWxsQ2F0ZWdvcmllcyIsImdldEhlYWRlciIsImhlYWRlciIsImFjY2Vzc2liaWxpdHlfbGFuZ3VhZ2UiLCJnZXRBbGxIZWFkZXJzIiwiZ2V0Rm9vdGVyIiwiZ2V0TmV3c2xldHRlciIsImdldEZBUSIsImZhcUVudHJ5Iiwic2VjdGlvbl90aXRsZSIsImhhc0ljb24iLCJpY29uIiwiZmFxUXVlc3Rpb25UeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiZmFxX3F1ZXN0aW9uIiwiZ2V0QWxsQmFubmVycyIsImdldEFsbFRlc3RpbW9uaWFscyIsImdldEFsbENvdXJzZXMiLCJjb3Vyc2VzIiwiZmFsbGJhY2tRdWVyeSIsImZhbGxiYWNrUmVzdWx0IiwiZ2V0QXV0aG9yQnlVaWQiLCJ1aWQiLCJyZXNvbHZlQXV0aG9yUmVmZXJlbmNlcyIsImNvdXJzZSIsImF1dGhvciIsImF1dGhvcnMiLCJyZXNvbHZlZEF1dGhvcnMiLCJiaW8iLCJwdXNoIiwiZnVsbEF1dGhvciIsInVuZGVmaW5lZCIsImdldENvdXJzZUJ5U2x1ZyIsInNsdWciLCJtb2R1bGVzIiwiZ2V0Q291cnNlQnlVaWQiLCJsb2NhbGVFcnJvciIsImdldE1vZHVsZUJ5VWlkIiwiZ2V0TGVzc29uQnlVaWQiLCJnZXRMZXNzb25CeVNsdWciLCJnZXRDb3Vyc2VCeUxlc3NvblVpZCIsImxlc3NvblVpZCIsIm1vZHVsZXNSZXN1bHQiLCJ0YXJnZXRNb2R1bGVVaWQiLCJtb2R1bGUiLCJsZXNzb25zIiwic29tZSIsImxlc3NvbiIsImNvdXJzZXNSZXN1bHQiLCJjb3Vyc2VNb2R1bGVzIiwibSIsImdldEFsbE9uYm9hcmRpbmdTdGVwcyIsInBvc3NpYmxlQ29udGVudFR5cGVzIiwiYmFzZVF1ZXJ5Iiwib25ib2FyZGluZ0VudHJpZXMiLCJmaWx0ZXIiLCJlbnRyeSIsImN1cnJlbnRfc3RlcCIsImxhYmVsX3RleHQiLCJ0b0xvd2VyQ2FzZSIsImluY2x1ZGVzIiwibWFwIiwiX2lkIiwicGFyc2VJbnQiLCJtYXRjaCIsInRvdGFsX3N0ZXBzIiwiZGlzcGxheV90eXBlIiwib3B0aW9uIiwiYmFja19idXR0b25fdGV4dCIsIm5leHRfYnV0dG9uX3RleHQiLCJzb3J0IiwiYSIsImIiLCJtZXNzYWdlIiwicGFnZXMiLCJvbmJvYXJkaW5nUGFnZXMiLCJwYWdlIiwid2FybiIsImdldEF1dGhCcmFuZGluZyIsInBhZ2VUeXBlIiwicGFnZVR5cGVWYWx1ZSIsImhlYWRsaW5lIiwic3VidGl0bGUiLCJicmFuZGluZ19jb250ZW50Iiwic3RhdHMiLCJzdGF0c1R5cGUiLCJwYWdlX3R5cGUiLCJiYWNrZ3JvdW5kX2ltYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contentstack.ts\n"));

/***/ })

});