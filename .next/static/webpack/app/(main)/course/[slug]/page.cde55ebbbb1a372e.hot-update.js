"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/(main)/course/[slug]/page",{

/***/ "(app-pages-browser)/./src/lib/contentstack.ts":
/*!*********************************!*\
  !*** ./src/lib/contentstack.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CONTENT_TYPES: function() { return /* binding */ CONTENT_TYPES; },\n/* harmony export */   Stack: function() { return /* binding */ Stack; },\n/* harmony export */   getAllBanners: function() { return /* binding */ getAllBanners; },\n/* harmony export */   getAllCategories: function() { return /* binding */ getAllCategories; },\n/* harmony export */   getAllCourses: function() { return /* binding */ getAllCourses; },\n/* harmony export */   getAllHeaders: function() { return /* binding */ getAllHeaders; },\n/* harmony export */   getAllOnboardingSteps: function() { return /* binding */ getAllOnboardingSteps; },\n/* harmony export */   getAllTestimonials: function() { return /* binding */ getAllTestimonials; },\n/* harmony export */   getAuthBranding: function() { return /* binding */ getAuthBranding; },\n/* harmony export */   getCourseByLessonUid: function() { return /* binding */ getCourseByLessonUid; },\n/* harmony export */   getCourseBySlug: function() { return /* binding */ getCourseBySlug; },\n/* harmony export */   getCourseByUid: function() { return /* binding */ getCourseByUid; },\n/* harmony export */   getEntries: function() { return /* binding */ getEntries; },\n/* harmony export */   getEntry: function() { return /* binding */ getEntry; },\n/* harmony export */   getEntryByUrl: function() { return /* binding */ getEntryByUrl; },\n/* harmony export */   getFAQ: function() { return /* binding */ getFAQ; },\n/* harmony export */   getFooter: function() { return /* binding */ getFooter; },\n/* harmony export */   getHeader: function() { return /* binding */ getHeader; },\n/* harmony export */   getLessonBySlug: function() { return /* binding */ getLessonBySlug; },\n/* harmony export */   getLessonByUid: function() { return /* binding */ getLessonByUid; },\n/* harmony export */   getModuleByUid: function() { return /* binding */ getModuleByUid; },\n/* harmony export */   getNewsletter: function() { return /* binding */ getNewsletter; },\n/* harmony export */   getPage: function() { return /* binding */ getPage; },\n/* harmony export */   getPageByUrl: function() { return /* binding */ getPageByUrl; }\n/* harmony export */ });\n/* harmony import */ var contentstack__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! contentstack */ \"(app-pages-browser)/./node_modules/contentstack/dist/web/contentstack.js\");\n/* harmony import */ var contentstack__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(contentstack__WEBPACK_IMPORTED_MODULE_0__);\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/next/dist/build/polyfills/process.js\");\n\n// Contentstack SDK Configuration\nconst Stack = contentstack__WEBPACK_IMPORTED_MODULE_0___default().Stack({\n    api_key: process.env.NEXT_PUBLIC_CONTENTSTACK_API_KEY || \"blt2b872601d3c5423f\" || 0,\n    delivery_token: process.env.NEXT_PUBLIC_CONTENTSTACK_DELIVERY_TOKEN || \"csab2298d637dc5b151fd67edc\" || 0,\n    environment: process.env.NEXT_PUBLIC_CONTENTSTACK_ENVIRONMENT || \"dev\" || 0,\n    branch: process.env.NEXT_PUBLIC_CONTENTSTACK_BRANCH || \"main\" || 0\n});\n// Content Type UIDs - Match your Contentstack setup\nconst CONTENT_TYPES = {\n    PAGE: \"modular_section\",\n    BANNER: \"banner\",\n    HEADER: \"header\",\n    FOOTER: \"footer\",\n    NEWSLETTER: \"newsletter\",\n    ICON: \"icon\",\n    FAQ: \"faq\",\n    FAQ_QUESTION: \"faq_question\",\n    TESTIMONIAL: \"testimonial\",\n    AUTHOR: \"author\",\n    COURSE: \"courses\",\n    MODULE: \"module\",\n    LESSON: \"lesson\",\n    CATEGORY: \"categories_block\",\n    CATEGORY_BLOCK: \"category_block\",\n    INSTRUCTOR: \"instructor\",\n    ONBOARDING: \"onboarding_block\",\n    AUTH_BRANDING: \"auth_branding\"\n};\n// ============================================\n// Generic Fetch Helpers\n// ============================================\n/**\n * Get current locale from localStorage (client-side) or default\n */ function getCurrentLocale() {\n    if (true) {\n        return localStorage.getItem(\"selectedLanguage\") || \"en-us\";\n    }\n    return \"en-us\";\n}\n/**\n * Default fallback locale when content is not available in selected locale\n */ const FALLBACK_LOCALE = \"en-us\";\n/**\n * Fetch single entry by content type and UID\n */ async function getEntry(contentType, entryUid) {\n    let referenceFields = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [], locale = arguments.length > 3 ? arguments[3] : void 0;\n    try {\n        const query = Stack.ContentType(contentType).Entry(entryUid);\n        // Set locale if provided\n        const targetLocale = locale || getCurrentLocale();\n        query.language(targetLocale);\n        referenceFields.forEach((field)=>{\n            query.includeReference(field);\n        });\n        const result = await query.toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching entry: \".concat(contentType, \"/\").concat(entryUid), error);\n        return null;\n    }\n}\n/**\n * Fetch entries by content type with options\n */ async function getEntries(contentType) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    try {\n        const query = Stack.ContentType(contentType).Query();\n        // Set locale if provided\n        const targetLocale = options.locale || getCurrentLocale();\n        query.language(targetLocale);\n        if (options.referenceFields) {\n            options.referenceFields.forEach((field)=>{\n                query.includeReference(field);\n            });\n        }\n        if (options.limit) query.limit(options.limit);\n        if (options.skip) query.skip(options.skip);\n        if (options.orderBy) {\n            if (options.orderDirection === \"desc\") {\n                query.descending(options.orderBy);\n            } else {\n                query.ascending(options.orderBy);\n            }\n        }\n        if (options.where) {\n            Object.entries(options.where).forEach((param)=>{\n                let [key, value] = param;\n                query.where(key, value);\n            });\n        }\n        const result = await query.toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching entries: \".concat(contentType), error);\n        return [];\n    }\n}\n/**\n * Fetch entry by URL\n */ async function getEntryByUrl(contentType, url) {\n    let referenceFields = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    try {\n        var _result_;\n        const query = Stack.ContentType(contentType).Query().where(\"url\", url);\n        referenceFields.forEach((field)=>{\n            query.includeReference(field);\n        });\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching entry by URL: \".concat(contentType, \"/\").concat(url), error);\n        return null;\n    }\n}\n// ============================================\n// Page (Modular Section) Fetch Functions\n// ============================================\n/**\n * Fetch Page entry by title with all nested references\n * This is the main function for fetching page content\n * Supports locale for fetching localized content\n */ async function getPage(title, locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"title\", title).includeReference([\n            \"header\",\n            \"header.icon\",\n            \"section.hero_block.hero_banner\",\n            \"section.carousel_block.banner\",\n            \"section.category_block.icon\",\n            \"section.category_block.category\",\n            \"section.feature_block.features\",\n            \"section.workflow_block.stage\",\n            \"section.testimonial_block.testimonial\",\n            \"section.testimonial_block.testimonial.author\"\n        ]);\n        // Set locale for content fetching\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let pageEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // Fallback to en-us if no page found in selected locale\n        if (!pageEntry && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            console.log('[CMS] Page \"'.concat(title, '\" not found in ').concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"title\", title).includeReference([\n                \"header\",\n                \"header.icon\",\n                \"section.hero_block.hero_banner\",\n                \"section.carousel_block.banner\",\n                \"section.category_block.icon\",\n                \"section.category_block.category\",\n                \"section.feature_block.features\",\n                \"section.workflow_block.stage\",\n                \"section.testimonial_block.testimonial\",\n                \"section.testimonial_block.testimonial.author\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            pageEntry = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        // Debug logging\n        if (pageEntry) {\n            var _pageEntry_section;\n            console.log('[CMS] Page \"'.concat(title, '\" loaded with ').concat(((_pageEntry_section = pageEntry.section) === null || _pageEntry_section === void 0 ? void 0 : _pageEntry_section.length) || 0, \" sections\"));\n        }\n        return pageEntry;\n    } catch (error) {\n        console.error(\"Error fetching page: \".concat(title), error);\n        return null;\n    }\n}\n/**\n * Fetch Page entry by URL\n */ async function getPageByUrl(url) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().where(\"url\", url).includeReference([\n            \"header\",\n            \"header.icon\",\n            \"section.carousel_block.banner\",\n            \"section.category_block.icon\",\n            \"section.category_block.category\",\n            \"section.feature_block.features\",\n            \"section.workflow_block.stage\",\n            \"section.testimonial_block.testimonial\",\n            \"section.testimonial_block.testimonial.author\"\n        ]);\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching page by URL: \".concat(url), error);\n        return null;\n    }\n}\n// ============================================\n// Category Fetch Functions\n// ============================================\n/**\n * Fetch all Category entries\n */ async function getAllCategories() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.CATEGORY).Query().toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching categories\", error);\n        return [];\n    }\n}\n// ============================================\n// Header Fetch Functions\n// ============================================\n/**\n * Fetch Header entry by title\n * Header is always fetched in English since it contains non-translatable UI config\n * @param title - \"Landing Header\" or \"App Header\"\n */ async function getHeader(title) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.HEADER).Query().where(\"title\", title).includeReference(\"icon\");\n        // Always fetch header in English (contains UI configuration, not translated content)\n        query.language(\"en-us\");\n        const result = await query.toJSON().find();\n        const header = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        if (header) {\n            var _header_accessibility_language;\n            console.log('[CMS] Header \"'.concat(title, '\" loaded with ').concat(((_header_accessibility_language = header.accessibility_language) === null || _header_accessibility_language === void 0 ? void 0 : _header_accessibility_language.length) || 0, \" languages\"));\n        }\n        return header;\n    } catch (error) {\n        console.error(\"Error fetching header: \".concat(title), error);\n        return null;\n    }\n}\n/**\n * Fetch all Headers\n */ async function getAllHeaders() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.HEADER).Query().includeReference(\"icon\").toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching all headers\", error);\n        return [];\n    }\n}\n// ============================================\n// Footer & Newsletter Fetch Functions\n// ============================================\n/**\n * Fetch Footer entry (singleton)\n */ async function getFooter() {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.FOOTER).Query().includeReference(\"icon\");\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching footer\", error);\n        return null;\n    }\n}\n/**\n * Fetch Newsletter entry (singleton)\n */ async function getNewsletter() {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.NEWSLETTER).Query().includeReference(\"icon\");\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching newsletter\", error);\n        return null;\n    }\n}\n// ============================================\n// FAQ Fetch Functions\n// ============================================\n/**\n * Fetch FAQ entry (singleton) with nested references\n */ async function getFAQ() {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.FAQ).Query().includeReference([\n            \"icon\",\n            \"faq_question\"\n        ]);\n        const result = await query.toJSON().find();\n        const faqEntry = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        if (faqEntry) {\n            console.log(\"FAQ Entry fetched:\", {\n                title: faqEntry.section_title,\n                hasIcon: !!faqEntry.icon,\n                faqQuestionType: Array.isArray(faqEntry.faq_question) ? \"array\" : \"object\"\n            });\n        }\n        return faqEntry;\n    } catch (error) {\n        console.error(\"Error fetching FAQ\", error);\n        return null;\n    }\n}\n// ============================================\n// Banner Fetch Functions\n// ============================================\n/**\n * Fetch all Banner entries\n */ async function getAllBanners() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.BANNER).Query().toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching banners\", error);\n        return [];\n    }\n}\n// ============================================\n// Testimonial Fetch Functions\n// ============================================\n/**\n * Fetch all Testimonial entries with author reference\n */ async function getAllTestimonials() {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.TESTIMONIAL).Query().includeReference(\"author\").toJSON().find();\n        return result[0] || [];\n    } catch (error) {\n        console.error(\"Error fetching testimonials\", error);\n        return [];\n    }\n}\n// ============================================\n// Course Fetch Functions\n// ============================================\n/**\n * Fetch all courses with author reference\n * Falls back to English if no content found in selected locale\n */ async function getAllCourses(locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        // First try with selected locale\n        const query = Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n            \"author\",\n            \"modules\"\n        ]);\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let courses = result[0] || [];\n        // If no courses found and we're not already using fallback, try fallback locale\n        if (courses.length === 0 && targetLocale !== FALLBACK_LOCALE) {\n            console.log(\"[CMS] No courses found in \".concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n                \"author\",\n                \"modules\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            courses = fallbackResult[0] || [];\n        }\n        // Resolve author references for all courses\n        const resolvedCourses = await Promise.all(courses.map((course)=>resolveAuthorReferences(course)));\n        return resolvedCourses;\n    } catch (error) {\n        console.error(\"Error fetching courses\", error);\n        return [];\n    }\n}\n/**\n * Fetch author by UID - always fetches from default locale since authors are not localized\n */ async function getAuthorByUid(uid) {\n    try {\n        const query = Stack.ContentType(CONTENT_TYPES.AUTHOR).Entry(uid);\n        // Always fetch authors in fallback locale since author data (name, bio) is non-localizable\n        query.language(FALLBACK_LOCALE);\n        const result = await query.toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching author by UID: \".concat(uid), error);\n        return null;\n    }\n}\n/**\n * Helper to resolve author references that may not be fully populated\n * When fetching localized content, references to non-localized entries may not resolve\n * This function always fetches author data from the fallback locale to ensure consistency\n */ async function resolveAuthorReferences(course) {\n    if (!course.author) return course;\n    const authors = Array.isArray(course.author) ? course.author : [\n        course.author\n    ];\n    const resolvedAuthors = [];\n    for (const author of authors){\n        // Always fetch the full author data from fallback locale to ensure we have all fields\n        // This is because author data (name, bio, social links) is marked as non-localizable\n        // but when fetching course in a different locale, the reference may not resolve properly\n        if (author.uid) {\n            // Always fetch fresh to ensure we get complete data\n            const fullAuthor = await getAuthorByUid(author.uid);\n            if (fullAuthor) {\n                resolvedAuthors.push(fullAuthor);\n            } else if (author.title) {\n                // Fallback: if fetch fails but we have partial data, use it\n                resolvedAuthors.push(author);\n            }\n        } else if (author.title) {\n            // No UID but has title - use as is\n            resolvedAuthors.push(author);\n        }\n    }\n    course.author = resolvedAuthors.length > 0 ? resolvedAuthors : undefined;\n    return course;\n}\n/**\n * Fetch a single course by slug with all nested references\n * Falls back to English if no content found in selected locale\n */ async function getCourseBySlug(slug, locale) {\n    try {\n        var _result_;\n        const targetLocale = locale || getCurrentLocale();\n        // First try with selected locale\n        const query = Stack.ContentType(CONTENT_TYPES.COURSE).Query().where(\"slug\", slug).includeReference([\n            \"author\",\n            \"modules\",\n            \"modules.lessons\"\n        ]);\n        query.language(targetLocale);\n        const result = await query.toJSON().find();\n        let course = ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n        // If no course found and we're not already using fallback, try fallback locale\n        if (!course && targetLocale !== FALLBACK_LOCALE) {\n            var _fallbackResult_;\n            console.log(\"[CMS] Course not found in \".concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n            const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Query().where(\"slug\", slug).includeReference([\n                \"author\",\n                \"modules\",\n                \"modules.lessons\"\n            ]);\n            fallbackQuery.language(FALLBACK_LOCALE);\n            const fallbackResult = await fallbackQuery.toJSON().find();\n            course = ((_fallbackResult_ = fallbackResult[0]) === null || _fallbackResult_ === void 0 ? void 0 : _fallbackResult_[0]) || null;\n        }\n        // Ensure author references are fully resolved\n        if (course) {\n            course = await resolveAuthorReferences(course);\n            console.log('[CMS] Course \"'.concat(course.title, '\" loaded with ').concat(Array.isArray(course.modules) ? course.modules.length : course.modules ? 1 : 0, \" modules\"));\n        }\n        return course;\n    } catch (error) {\n        console.error(\"Error fetching course by slug: \".concat(slug), error);\n        return null;\n    }\n}\n/**\n * Fetch a single course by UID with all nested references\n * Falls back to English if no content found in selected locale\n */ async function getCourseByUid(uid, locale) {\n    try {\n        const targetLocale = locale || getCurrentLocale();\n        let course = null;\n        // First try with selected locale\n        try {\n            const query = Stack.ContentType(CONTENT_TYPES.COURSE).Entry(uid).includeReference([\n                \"author\",\n                \"modules\",\n                \"modules.lessons\"\n            ]);\n            query.language(targetLocale);\n            const result = await query.toJSON().fetch();\n            course = result;\n        } catch (localeError) {\n            // If locale fetch fails and we're not already using fallback, try fallback\n            if (targetLocale !== FALLBACK_LOCALE) {\n                console.log(\"[CMS] Course UID \".concat(uid, \" not found in \").concat(targetLocale, \", falling back to \").concat(FALLBACK_LOCALE));\n                const fallbackQuery = Stack.ContentType(CONTENT_TYPES.COURSE).Entry(uid).includeReference([\n                    \"author\",\n                    \"modules\",\n                    \"modules.lessons\"\n                ]);\n                fallbackQuery.language(FALLBACK_LOCALE);\n                const fallbackResult = await fallbackQuery.toJSON().fetch();\n                course = fallbackResult;\n            } else {\n                throw localeError;\n            }\n        }\n        // Ensure author references are fully resolved\n        if (course) {\n            course = await resolveAuthorReferences(course);\n        }\n        return course;\n    } catch (error) {\n        console.error(\"Error fetching course by UID: \".concat(uid), error);\n        return null;\n    }\n}\n// ============================================\n// Module Fetch Functions\n// ============================================\n/**\n * Fetch a single module by UID with lessons\n */ async function getModuleByUid(uid) {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.MODULE).Entry(uid).includeReference([\n            \"lessons\"\n        ]).toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching module by UID: \".concat(uid), error);\n        return null;\n    }\n}\n// ============================================\n// Lesson Fetch Functions\n// ============================================\n/**\n * Fetch a single lesson by UID\n */ async function getLessonByUid(uid) {\n    try {\n        const result = await Stack.ContentType(CONTENT_TYPES.LESSON).Entry(uid).toJSON().fetch();\n        return result;\n    } catch (error) {\n        console.error(\"Error fetching lesson by UID: \".concat(uid), error);\n        return null;\n    }\n}\n/**\n * Fetch a single lesson by slug\n */ async function getLessonBySlug(slug) {\n    try {\n        var _result_;\n        const query = Stack.ContentType(CONTENT_TYPES.LESSON).Query().where(\"slug\", slug);\n        const result = await query.toJSON().find();\n        return ((_result_ = result[0]) === null || _result_ === void 0 ? void 0 : _result_[0]) || null;\n    } catch (error) {\n        console.error(\"Error fetching lesson by slug: \".concat(slug), error);\n        return null;\n    }\n}\n/**\n * Fetch course data for a given lesson (to get course context)\n * Returns the course that contains this lesson\n */ async function getCourseByLessonUid(lessonUid) {\n    try {\n        // First, find which module contains this lesson\n        const modulesResult = await Stack.ContentType(CONTENT_TYPES.MODULE).Query().includeReference([\n            \"lessons\"\n        ]).toJSON().find();\n        const modules = modulesResult[0] || [];\n        let targetModuleUid = null;\n        for (const module of modules){\n            const lessons = Array.isArray(module.lessons) ? module.lessons : module.lessons ? [\n                module.lessons\n            ] : [];\n            if (lessons.some((lesson)=>lesson.uid === lessonUid)) {\n                targetModuleUid = module.uid;\n                break;\n            }\n        }\n        if (!targetModuleUid) return null;\n        // Now find the course that contains this module\n        const coursesResult = await Stack.ContentType(CONTENT_TYPES.COURSE).Query().includeReference([\n            \"author\",\n            \"modules\",\n            \"modules.lessons\"\n        ]).toJSON().find();\n        const courses = coursesResult[0] || [];\n        for (const course of courses){\n            const courseModules = Array.isArray(course.modules) ? course.modules : course.modules ? [\n                course.modules\n            ] : [];\n            if (courseModules.some((m)=>m.uid === targetModuleUid)) {\n                return course;\n            }\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching course by lesson UID: \".concat(lessonUid), error);\n        return null;\n    }\n}\n// ============================================\n// Onboarding Fetch Functions\n// ============================================\n/**\n * Fetch all onboarding steps\n * Returns steps sorted by current_step\n * Tries multiple content type names in case the exact name differs\n */ async function getAllOnboardingSteps() {\n    // Try different possible content type names\n    const possibleContentTypes = [\n        \"onboarding_block\",\n        \"onboarding\",\n        \"onboarding_step\",\n        \"onboarding_steps\",\n        \"modular_section\"\n    ];\n    for (const contentType of possibleContentTypes){\n        try {\n            const baseQuery = Stack.ContentType(contentType).Query();\n            // If it's modular_section, filter for onboarding entries\n            if (contentType === \"modular_section\") {\n                baseQuery.where(\"title\", \"Onboarding Step\");\n            } else {\n                // For onboarding-specific content types, include option references\n                baseQuery.includeReference(\"option\");\n            }\n            baseQuery.ascending(\"current_step\"); // Sort by step number\n            const result = await baseQuery.toJSON().find();\n            const entries = result[0] || [];\n            console.log(\"[CMS] Attempted \".concat(contentType, \": Found \").concat(entries.length, \" entries\"));\n            if (entries.length > 0) {\n                // Filter and transform entries\n                const onboardingEntries = entries.filter((entry)=>{\n                    var _entry_title;\n                    // Check if entry has onboarding-related fields\n                    return entry.current_step !== undefined || entry.label_text !== undefined || ((_entry_title = entry.title) === null || _entry_title === void 0 ? void 0 : _entry_title.toLowerCase().includes(\"onboarding\"));\n                }).map((entry)=>{\n                    var _entry_title_match, _entry_title;\n                    // Transform to OnboardingBlockEntry format\n                    return {\n                        uid: entry.uid || entry._id || \"\",\n                        title: entry.title,\n                        current_step: entry.current_step || parseInt(((_entry_title = entry.title) === null || _entry_title === void 0 ? void 0 : (_entry_title_match = _entry_title.match(/\\d+/)) === null || _entry_title_match === void 0 ? void 0 : _entry_title_match[0]) || \"1\"),\n                        total_steps: entry.total_steps || 5,\n                        label_text: entry.label_text || entry.title || \"\",\n                        display_type: entry.display_type || \"Card Grid\",\n                        option: entry.option || [],\n                        back_button_text: entry.back_button_text || \"Back\",\n                        next_button_text: entry.next_button_text || \"Continue\"\n                    };\n                });\n                if (onboardingEntries.length > 0) {\n                    console.log(\"[CMS] Successfully fetched \".concat(onboardingEntries.length, \" onboarding steps from \").concat(contentType));\n                    return onboardingEntries.sort((a, b)=>a.current_step - b.current_step);\n                }\n            }\n        } catch (error) {\n            // Log the error but continue trying other content types\n            console.log(\"[CMS] Content type \".concat(contentType, \" failed:\"), error.message || error);\n            continue;\n        }\n    }\n    // If no content type found, try searching modular_section for any onboarding-related entries\n    try {\n        const query = Stack.ContentType(CONTENT_TYPES.PAGE).Query().includeReference([\n            \"section\"\n        ]);\n        const result = await query.toJSON().find();\n        const pages = result[0] || [];\n        // Look for pages with \"Onboarding\" in title\n        const onboardingPages = pages.filter((page)=>{\n            var _page_title;\n            return (_page_title = page.title) === null || _page_title === void 0 ? void 0 : _page_title.toLowerCase().includes(\"onboarding\");\n        });\n        if (onboardingPages.length > 0) {\n            console.log(\"[CMS] Found onboarding page(s), but need proper content type structure\");\n        }\n    } catch (error) {\n        console.error(\"Error searching for onboarding page:\", error);\n    }\n    console.warn(\"[CMS] No onboarding content type found. Please check:\");\n    console.warn(\"1. Content type name in Contentstack (might be different)\");\n    console.warn(\"2. Entries are published\");\n    console.warn(\"3. API keys and environment are correct\");\n    return [];\n}\n// ============================================\n// Auth Branding Fetch Functions\n// ============================================\n/**\n * Fetch Auth Branding entry by page type (login or signup)\n * Matches Contentstack schema: page_type is \"Sign In\" or \"Sign Up\"\n */ async function getAuthBranding(pageType) {\n    try {\n        // Convert lowercase to Contentstack format\n        const pageTypeValue = pageType === \"login\" ? \"Sign In\" : \"Sign Up\";\n        const query = Stack.ContentType(CONTENT_TYPES.AUTH_BRANDING).Query().where(\"page_type\", pageTypeValue).includeReference([\n            \"stats\"\n        ]); // stats is reference to icon content type\n        const result = await query.toJSON().find();\n        const entries = result[0] || [];\n        if (entries.length > 0) {\n            const entry = entries[0];\n            // Log for debugging\n            console.log(\"[CMS] Auth branding entry for \".concat(pageType, \":\"), {\n                headline: entry.headline,\n                subtitle: entry.subtitle,\n                branding_content: entry.branding_content,\n                stats: entry.stats,\n                statsType: Array.isArray(entry.stats) ? \"array\" : typeof entry.stats\n            });\n            return {\n                uid: entry.uid || entry._id || \"\",\n                title: entry.title || \"\",\n                page_type: entry.page_type || pageTypeValue,\n                headline: entry.headline,\n                subtitle: entry.subtitle,\n                branding_content: entry.branding_content,\n                stats: entry.stats,\n                background_image: entry.background_image\n            };\n        }\n        return null;\n    } catch (error) {\n        console.error(\"Error fetching auth branding for \".concat(pageType, \":\"), error);\n        return null;\n    }\n}\n// Export the Stack for advanced usage\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvY29udGVudHN0YWNrLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQW1CeEMsaUNBQWlDO0FBQ2pDLE1BQU1DLFFBQVFELHlEQUFrQixDQUFDO0lBQy9CRSxTQUFTQyxPQUFPQSxDQUFDQyxHQUFHLENBQUNDLGdDQUFnQyxJQUFJRixxQkFBZ0MsSUFBSTtJQUM3RkksZ0JBQWdCSixPQUFPQSxDQUFDQyxHQUFHLENBQUNJLHVDQUF1QyxJQUFJTCw0QkFBdUMsSUFBSTtJQUNsSE8sYUFBYVAsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDTyxvQ0FBb0MsSUFBSVIsS0FBb0MsSUFBSTtJQUN6R1UsUUFBUVYsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDVSwrQkFBK0IsSUFBSVgsTUFBK0IsSUFBSTtBQUM1RjtBQWlCQSxvREFBb0Q7QUFDN0MsTUFBTWEsZ0JBQWdCO0lBQzNCQyxNQUFNO0lBQ05DLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFlBQVk7SUFDWkMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLGNBQWM7SUFDZEMsYUFBYTtJQUNiQyxRQUFRO0lBQ1JDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxRQUFRO0lBQ1JDLFVBQVU7SUFDVkMsZ0JBQWdCO0lBQ2hCQyxZQUFZO0lBQ1pDLFlBQVk7SUFDWkMsZUFBZTtBQUNqQixFQUFXO0FBRVgsK0NBQStDO0FBQy9DLHdCQUF3QjtBQUN4QiwrQ0FBK0M7QUFFL0M7O0NBRUMsR0FDRCxTQUFTQztJQUNQLElBQUksSUFBa0IsRUFBYTtRQUNqQyxPQUFPQyxhQUFhQyxPQUFPLENBQUMsdUJBQXVCO0lBQ3JEO0lBQ0EsT0FBTztBQUNUO0FBRUE7O0NBRUMsR0FDRCxNQUFNQyxrQkFBa0I7QUFFeEI7O0NBRUMsR0FDTSxlQUFlQyxTQUNwQkMsV0FBbUIsRUFDbkJDLFFBQWdCO1FBQ2hCQyxrQkFBQUEsaUVBQTRCLEVBQUUsRUFD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dXJjZXNDb250ZW50IjpbImltcG9ydCBDb250ZW50c3RhY2sgZnJvbSAnY29udGVudHN0YWNrJztcbmltcG9ydCB7IFxuICBIZWFkZXJFbnRyeSwgXG4gIEZvb3RlckVudHJ5LCBcbiAgTmV3c2xldHRlckVudHJ5LCBcbiAgRkFRRW50cnksXG4gIFBhZ2VFbnRyeSxcbiAgQmFubmVyRW50cnksXG4gIFRlc3RpbW9uaWFsRW50cnksXG4gIEhlcm9CbG9ja0VudHJ5LFxuICBDYXRlZ29yeUVudHJ5LFxuICBDb3Vyc2VFbnRyeSxcbiAgTW9kdWxlRW50cnksXG4gIExlc3NvbkVudHJ5LFxuICBPbmJvYXJkaW5nQmxvY2tFbnRyeSxcbiAgQXV0aEJyYW5kaW5nRW50cnksXG4gIEF1dGhvckVudHJ5XG59IGZyb20gJ0AvdHlwZXMvY29udGVudHN0YWNrJztcblxuLy8gQ29udGVudHN0YWNrIFNESyBDb25maWd1cmF0aW9uXG5jb25zdCBTdGFjayA9IENvbnRlbnRzdGFjay5TdGFjayh7XG4gIGFwaV9rZXk6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19BUElfS0VZIHx8IHByb2Nlc3MuZW52LkNPTlRFTlRTVEFDS19BUElfS0VZIHx8ICcnLFxuICBkZWxpdmVyeV90b2tlbjogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ09OVEVOVFNUQUNLX0RFTElWRVJZX1RPS0VOIHx8IHByb2Nlc3MuZW52LkNPTlRFTlRTVEFDS19ERUxJVkVSWV9UT0tFTiB8fCAnJyxcbiAgZW52aXJvbm1lbnQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19FTlZJUk9OTUVOVCB8fCBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfRU5WSVJPTk1FTlQgfHwgJ2RldicsXG4gIGJyYW5jaDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ09OVEVOVFNUQUNLX0JSQU5DSCB8fCBwcm9jZXNzLmVudi5DT05URU5UU1RBQ0tfQlJBTkNIIHx8ICdtYWluJyxcbn0pO1xuXG4vLyBUeXBlIGRlZmluaXRpb25zIGZvciBDb250ZW50c3RhY2sgZW50cmllc1xuZXhwb3J0IGludGVyZmFjZSBDb250ZW50c3RhY2tFbnRyeSB7XG4gIHVpZDogc3RyaW5nO1xuICB0aXRsZTogc3RyaW5nO1xuICB1cmw/OiBzdHJpbmc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb250ZW50c3RhY2tBc3NldCB7XG4gIHVpZDogc3RyaW5nO1xuICB1cmw6IHN0cmluZztcbiAgdGl0bGU6IHN0cmluZztcbiAgZmlsZW5hbWU6IHN0cmluZztcbn1cblxuLy8gQ29udGVudCBUeXBlIFVJRHMgLSBNYXRjaCB5b3VyIENvbnRlbnRzdGFjayBzZXR1cFxuZXhwb3J0IGNvbnN0IENPTlRFTlRfVFlQRVMgPSB7XG4gIFBBR0U6ICdtb2R1bGFyX3NlY3Rpb24nLCAgLy8gUGFnZSBjb250ZW50IHR5cGUgKG1vZHVsYXIgc2VjdGlvbnMpXG4gIEJBTk5FUjogJ2Jhbm5lcicsXG4gIEhFQURFUjogJ2hlYWRlcicsXG4gIEZPT1RFUjogJ2Zvb3RlcicsXG4gIE5FV1NMRVRURVI6ICduZXdzbGV0dGVyJyxcbiAgSUNPTjogJ2ljb24nLFxuICBGQVE6ICdmYXEnLFxuICBGQVFfUVVFU1RJT046ICdmYXFfcXVlc3Rpb24nLFxuICBURVNUSU1PTklBTDogJ3Rlc3RpbW9uaWFsJyxcbiAgQVVUSE9SOiAnYXV0aG9yJyxcbiAgQ09VUlNFOiAnY291cnNlcycsICAvLyBDb3Vyc2UgY29udGVudCB0eXBlXG4gIE1PRFVMRTogJ21vZHVsZScsICAgLy8gTW9kdWxlIGNvbnRlbnQgdHlwZVxuICBMRVNTT046ICdsZXNzb24nLCAgIC8vIExlc3NvbiBjb250ZW50IHR5cGVcbiAgQ0FURUdPUlk6ICdjYXRlZ29yaWVzX2Jsb2NrJywgIC8vIFVwZGF0ZWQgdG8gbWF0Y2ggbmV3IGNvbnRlbnQgdHlwZVxuICBDQVRFR09SWV9CTE9DSzogJ2NhdGVnb3J5X2Jsb2NrJywgIC8vIFNpbmdsZXRvbiBmb3IgcmVmZXJlbmNpbmcgY2F0ZWdvcmllc1xuICBJTlNUUlVDVE9SOiAnaW5zdHJ1Y3RvcicsXG4gIE9OQk9BUkRJTkc6ICdvbmJvYXJkaW5nX2Jsb2NrJywgIC8vIE9uYm9hcmRpbmcgc3RlcHMgY29udGVudCB0eXBlXG4gIEFVVEhfQlJBTkRJTkc6ICdhdXRoX2JyYW5kaW5nJywgIC8vIEF1dGggYnJhbmRpbmcgY29udGVudCB0eXBlIGZvciBsb2dpbi9zaWdudXAgcGFnZXNcbn0gYXMgY29uc3Q7XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBHZW5lcmljIEZldGNoIEhlbHBlcnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogR2V0IGN1cnJlbnQgbG9jYWxlIGZyb20gbG9jYWxTdG9yYWdlIChjbGllbnQtc2lkZSkgb3IgZGVmYXVsdFxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50TG9jYWxlKCk6IHN0cmluZyB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnc2VsZWN0ZWRMYW5ndWFnZScpIHx8ICdlbi11cyc7XG4gIH1cbiAgcmV0dXJuICdlbi11cyc7XG59XG5cbi8qKlxuICogRGVmYXVsdCBmYWxsYmFjayBsb2NhbGUgd2hlbiBjb250ZW50IGlzIG5vdCBhdmFpbGFibGUgaW4gc2VsZWN0ZWQgbG9jYWxlXG4gKi9cbmNvbnN0IEZBTExCQUNLX0xPQ0FMRSA9ICdlbi11cyc7XG5cbi8qKlxuICogRmV0Y2ggc2luZ2xlIGVudHJ5IGJ5IGNvbnRlbnQgdHlwZSBhbmQgVUlEXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRFbnRyeTxUID0gQ29udGVudHN0YWNrRW50cnk+KFxuICBjb250ZW50VHlwZTogc3RyaW5nLFxuICBlbnRyeVVpZDogc3RyaW5nLFxuICByZWZlcmVuY2VGaWVsZHM6IHN0cmluZ1tdID0gW10sXG4gIGxvY2FsZT86IHN0cmluZ1xuKTogUHJvbWlzZTxUIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGUpLkVudHJ5KGVudHJ5VWlkKTtcbiAgICBcbiAgICAvLyBTZXQgbG9jYWxlIGlmIHByb3ZpZGVkXG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBxdWVyeS5sYW5ndWFnZSh0YXJnZXRMb2NhbGUpO1xuICAgIFxuICAgIHJlZmVyZW5jZUZpZWxkcy5mb3JFYWNoKChmaWVsZCkgPT4ge1xuICAgICAgcXVlcnkuaW5jbHVkZVJlZmVyZW5jZShmaWVsZCk7XG4gICAgfSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5mZXRjaCgpO1xuICAgIHJldHVybiByZXN1bHQgYXMgVDtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBlbnRyeTogJHtjb250ZW50VHlwZX0vJHtlbnRyeVVpZH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBlbnRyaWVzIGJ5IGNvbnRlbnQgdHlwZSB3aXRoIG9wdGlvbnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEVudHJpZXM8VCA9IENvbnRlbnRzdGFja0VudHJ5PihcbiAgY29udGVudFR5cGU6IHN0cmluZyxcbiAgb3B0aW9uczoge1xuICAgIHJlZmVyZW5jZUZpZWxkcz86IHN0cmluZ1tdO1xuICAgIGxpbWl0PzogbnVtYmVyO1xuICAgIHNraXA/OiBudW1iZXI7XG4gICAgb3JkZXJCeT86IHN0cmluZztcbiAgICBsb2NhbGU/OiBzdHJpbmc7XG4gICAgb3JkZXJEaXJlY3Rpb24/OiAnYXNjJyB8ICdkZXNjJztcbiAgICB3aGVyZT86IFJlY29yZDxzdHJpbmcsIGFueT47XG4gIH0gPSB7fVxuKTogUHJvbWlzZTxUW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKS5RdWVyeSgpO1xuICAgIFxuICAgIC8vIFNldCBsb2NhbGUgaWYgcHJvdmlkZWRcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBvcHRpb25zLmxvY2FsZSB8fCBnZXRDdXJyZW50TG9jYWxlKCk7XG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcbiAgICBcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2VGaWVsZHMpIHtcbiAgICAgIG9wdGlvbnMucmVmZXJlbmNlRmllbGRzLmZvckVhY2goKGZpZWxkKSA9PiB7XG4gICAgICAgIHF1ZXJ5LmluY2x1ZGVSZWZlcmVuY2UoZmllbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMubGltaXQpIHF1ZXJ5LmxpbWl0KG9wdGlvbnMubGltaXQpO1xuICAgIGlmIChvcHRpb25zLnNraXApIHF1ZXJ5LnNraXAob3B0aW9ucy5za2lwKTtcblxuICAgIGlmIChvcHRpb25zLm9yZGVyQnkpIHtcbiAgICAgIGlmIChvcHRpb25zLm9yZGVyRGlyZWN0aW9uID09PSAnZGVzYycpIHtcbiAgICAgICAgcXVlcnkuZGVzY2VuZGluZyhvcHRpb25zLm9yZGVyQnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcXVlcnkuYXNjZW5kaW5nKG9wdGlvbnMub3JkZXJCeSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMud2hlcmUpIHtcbiAgICAgIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMud2hlcmUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICBxdWVyeS53aGVyZShrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICByZXR1cm4gKHJlc3VsdFswXSB8fCBbXSkgYXMgVFtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGVudHJpZXM6ICR7Y29udGVudFR5cGV9YCwgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIGVudHJ5IGJ5IFVSTFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RW50cnlCeVVybDxUID0gQ29udGVudHN0YWNrRW50cnk+KFxuICBjb250ZW50VHlwZTogc3RyaW5nLFxuICB1cmw6IHN0cmluZyxcbiAgcmVmZXJlbmNlRmllbGRzOiBzdHJpbmdbXSA9IFtdXG4pOiBQcm9taXNlPFQgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZSkuUXVlcnkoKS53aGVyZSgndXJsJywgdXJsKTtcbiAgICBcbiAgICByZWZlcmVuY2VGaWVsZHMuZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgIHF1ZXJ5LmluY2x1ZGVSZWZlcmVuY2UoZmllbGQpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIHJldHVybiByZXN1bHRbMF0/LlswXSBhcyBUIHx8IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgZW50cnkgYnkgVVJMOiAke2NvbnRlbnRUeXBlfS8ke3VybH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIFBhZ2UgKE1vZHVsYXIgU2VjdGlvbikgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIFBhZ2UgZW50cnkgYnkgdGl0bGUgd2l0aCBhbGwgbmVzdGVkIHJlZmVyZW5jZXNcbiAqIFRoaXMgaXMgdGhlIG1haW4gZnVuY3Rpb24gZm9yIGZldGNoaW5nIHBhZ2UgY29udGVudFxuICogU3VwcG9ydHMgbG9jYWxlIGZvciBmZXRjaGluZyBsb2NhbGl6ZWQgY29udGVudFxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UGFnZSh0aXRsZTogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpOiBQcm9taXNlPFBhZ2VFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIFxuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5QQUdFKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC53aGVyZSgndGl0bGUnLCB0aXRsZSlcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgJ2hlYWRlcicsXG4gICAgICAgICdoZWFkZXIuaWNvbicsXG4gICAgICAgICdzZWN0aW9uLmhlcm9fYmxvY2suaGVyb19iYW5uZXInLCAgICAgICAgLy8gSGVybyBCYW5uZXIgcmVmZXJlbmNlXG4gICAgICAgICdzZWN0aW9uLmNhcm91c2VsX2Jsb2NrLmJhbm5lcicsICAgICAgICAgIC8vIEJhbm5lciByZWZlcmVuY2VzIGZvciBjYXJvdXNlbFxuICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5pY29uJywgICAgICAgICAgICAvLyBMZWdhY3kgY2F0ZWdvcnkgaWNvbnNcbiAgICAgICAgJ3NlY3Rpb24uY2F0ZWdvcnlfYmxvY2suY2F0ZWdvcnknLCAgICAgICAgLy8gTmV3IGNhdGVnb3J5IHJlZmVyZW5jZXMgKGNhdGVnb3JpZXNfYmxvY2spXG4gICAgICAgICdzZWN0aW9uLmZlYXR1cmVfYmxvY2suZmVhdHVyZXMnLCAgICAgICAgIC8vIEZlYXR1cmUgaWNvbnNcbiAgICAgICAgJ3NlY3Rpb24ud29ya2Zsb3dfYmxvY2suc3RhZ2UnLCAgICAgICAgICAgLy8gV29ya2Zsb3cgc3RhZ2UgaWNvbnNcbiAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwnLCAgLy8gVGVzdGltb25pYWwgZW50cmllc1xuICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbC5hdXRob3InLCAvLyBUZXN0aW1vbmlhbCBhdXRob3JzXG4gICAgICBdKTtcblxuICAgIC8vIFNldCBsb2NhbGUgZm9yIGNvbnRlbnQgZmV0Y2hpbmdcbiAgICBxdWVyeS5sYW5ndWFnZSh0YXJnZXRMb2NhbGUpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGxldCBwYWdlRW50cnkgPSByZXN1bHRbMF0/LlswXSBhcyBQYWdlRW50cnkgfHwgbnVsbDtcbiAgICBcbiAgICAvLyBGYWxsYmFjayB0byBlbi11cyBpZiBubyBwYWdlIGZvdW5kIGluIHNlbGVjdGVkIGxvY2FsZVxuICAgIGlmICghcGFnZUVudHJ5ICYmIHRhcmdldExvY2FsZSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gUGFnZSBcIiR7dGl0bGV9XCIgbm90IGZvdW5kIGluICR7dGFyZ2V0TG9jYWxlfSwgZmFsbGluZyBiYWNrIHRvICR7RkFMTEJBQ0tfTE9DQUxFfWApO1xuICAgICAgY29uc3QgZmFsbGJhY2tRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuUEFHRSlcbiAgICAgICAgLlF1ZXJ5KClcbiAgICAgICAgLndoZXJlKCd0aXRsZScsIHRpdGxlKVxuICAgICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICAgJ2hlYWRlcicsXG4gICAgICAgICAgJ2hlYWRlci5pY29uJyxcbiAgICAgICAgICAnc2VjdGlvbi5oZXJvX2Jsb2NrLmhlcm9fYmFubmVyJyxcbiAgICAgICAgICAnc2VjdGlvbi5jYXJvdXNlbF9ibG9jay5iYW5uZXInLFxuICAgICAgICAgICdzZWN0aW9uLmNhdGVnb3J5X2Jsb2NrLmljb24nLFxuICAgICAgICAgICdzZWN0aW9uLmNhdGVnb3J5X2Jsb2NrLmNhdGVnb3J5JyxcbiAgICAgICAgICAnc2VjdGlvbi5mZWF0dXJlX2Jsb2NrLmZlYXR1cmVzJyxcbiAgICAgICAgICAnc2VjdGlvbi53b3JrZmxvd19ibG9jay5zdGFnZScsXG4gICAgICAgICAgJ3NlY3Rpb24udGVzdGltb25pYWxfYmxvY2sudGVzdGltb25pYWwnLFxuICAgICAgICAgICdzZWN0aW9uLnRlc3RpbW9uaWFsX2Jsb2NrLnRlc3RpbW9uaWFsLmF1dGhvcicsXG4gICAgICAgIF0pO1xuICAgICAgZmFsbGJhY2tRdWVyeS5sYW5ndWFnZShGQUxMQkFDS19MT0NBTEUpO1xuICAgICAgXG4gICAgICBjb25zdCBmYWxsYmFja1Jlc3VsdCA9IGF3YWl0IGZhbGxiYWNrUXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgICAgcGFnZUVudHJ5ID0gZmFsbGJhY2tSZXN1bHRbMF0/LlswXSBhcyBQYWdlRW50cnkgfHwgbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gRGVidWcgbG9nZ2luZ1xuICAgIGlmIChwYWdlRW50cnkpIHtcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBQYWdlIFwiJHt0aXRsZX1cIiBsb2FkZWQgd2l0aCAke3BhZ2VFbnRyeS5zZWN0aW9uPy5sZW5ndGggfHwgMH0gc2VjdGlvbnNgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHBhZ2VFbnRyeTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBwYWdlOiAke3RpdGxlfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIFBhZ2UgZW50cnkgYnkgVVJMXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQYWdlQnlVcmwodXJsOiBzdHJpbmcpOiBQcm9taXNlPFBhZ2VFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuUEFHRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAud2hlcmUoJ3VybCcsIHVybClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgJ2hlYWRlcicsXG4gICAgICAgICdoZWFkZXIuaWNvbicsXG4gICAgICAgICdzZWN0aW9uLmNhcm91c2VsX2Jsb2NrLmJhbm5lcicsXG4gICAgICAgICdzZWN0aW9uLmNhdGVnb3J5X2Jsb2NrLmljb24nLFxuICAgICAgICAnc2VjdGlvbi5jYXRlZ29yeV9ibG9jay5jYXRlZ29yeScsICAgICAgICAvLyBOZXcgY2F0ZWdvcnkgcmVmZXJlbmNlc1xuICAgICAgICAnc2VjdGlvbi5mZWF0dXJlX2Jsb2NrLmZlYXR1cmVzJyxcbiAgICAgICAgJ3NlY3Rpb24ud29ya2Zsb3dfYmxvY2suc3RhZ2UnLFxuICAgICAgICAnc2VjdGlvbi50ZXN0aW1vbmlhbF9ibG9jay50ZXN0aW1vbmlhbCcsXG4gICAgICAgICdzZWN0aW9uLnRlc3RpbW9uaWFsX2Jsb2NrLnRlc3RpbW9uaWFsLmF1dGhvcicsXG4gICAgICBdKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdPy5bMF0gYXMgUGFnZUVudHJ5IHx8IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgcGFnZSBieSBVUkw6ICR7dXJsfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gQ2F0ZWdvcnkgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGFsbCBDYXRlZ29yeSBlbnRyaWVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxDYXRlZ29yaWVzKCk6IFByb21pc2U8Q2F0ZWdvcnlFbnRyeVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DQVRFR09SWSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5maW5kKCk7XG4gICAgcmV0dXJuIChyZXN1bHRbMF0gfHwgW10pIGFzIENhdGVnb3J5RW50cnlbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBjYXRlZ29yaWVzJywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSGVhZGVyIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBIZWFkZXIgZW50cnkgYnkgdGl0bGVcbiAqIEhlYWRlciBpcyBhbHdheXMgZmV0Y2hlZCBpbiBFbmdsaXNoIHNpbmNlIGl0IGNvbnRhaW5zIG5vbi10cmFuc2xhdGFibGUgVUkgY29uZmlnXG4gKiBAcGFyYW0gdGl0bGUgLSBcIkxhbmRpbmcgSGVhZGVyXCIgb3IgXCJBcHAgSGVhZGVyXCJcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEhlYWRlcih0aXRsZTogc3RyaW5nKTogUHJvbWlzZTxIZWFkZXJFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuSEVBREVSKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC53aGVyZSgndGl0bGUnLCB0aXRsZSlcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKCdpY29uJyk7XG5cbiAgICAvLyBBbHdheXMgZmV0Y2ggaGVhZGVyIGluIEVuZ2xpc2ggKGNvbnRhaW5zIFVJIGNvbmZpZ3VyYXRpb24sIG5vdCB0cmFuc2xhdGVkIGNvbnRlbnQpXG4gICAgcXVlcnkubGFuZ3VhZ2UoJ2VuLXVzJyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgY29uc3QgaGVhZGVyID0gcmVzdWx0WzBdPy5bMF0gYXMgSGVhZGVyRW50cnkgfHwgbnVsbDtcbiAgICBcbiAgICBpZiAoaGVhZGVyKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gSGVhZGVyIFwiJHt0aXRsZX1cIiBsb2FkZWQgd2l0aCAke2hlYWRlci5hY2Nlc3NpYmlsaXR5X2xhbmd1YWdlPy5sZW5ndGggfHwgMH0gbGFuZ3VhZ2VzYCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBoZWFkZXI7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgaGVhZGVyOiAke3RpdGxlfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIGFsbCBIZWFkZXJzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxIZWFkZXJzKCk6IFByb21pc2U8SGVhZGVyRW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuSEVBREVSKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKCdpY29uJylcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZpbmQoKTtcbiAgICByZXR1cm4gKHJlc3VsdFswXSB8fCBbXSkgYXMgSGVhZGVyRW50cnlbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhbGwgaGVhZGVycycsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEZvb3RlciAmIE5ld3NsZXR0ZXIgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIEZvb3RlciBlbnRyeSAoc2luZ2xldG9uKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Rm9vdGVyKCk6IFByb21pc2U8Rm9vdGVyRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkZPT1RFUilcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZSgnaWNvbicpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIHJldHVybiByZXN1bHRbMF0/LlswXSBhcyBGb290ZXJFbnRyeSB8fCBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGZvb3RlcicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIE5ld3NsZXR0ZXIgZW50cnkgKHNpbmdsZXRvbilcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldE5ld3NsZXR0ZXIoKTogUHJvbWlzZTxOZXdzbGV0dGVyRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLk5FV1NMRVRURVIpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ2ljb24nKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICByZXR1cm4gcmVzdWx0WzBdPy5bMF0gYXMgTmV3c2xldHRlckVudHJ5IHx8IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgbmV3c2xldHRlcicsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gRkFRIEZldGNoIEZ1bmN0aW9uc1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLyoqXG4gKiBGZXRjaCBGQVEgZW50cnkgKHNpbmdsZXRvbikgd2l0aCBuZXN0ZWQgcmVmZXJlbmNlc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0RkFRKCk6IFByb21pc2U8RkFRRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkZBUSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2ljb24nLCAnZmFxX3F1ZXN0aW9uJ10pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGNvbnN0IGZhcUVudHJ5ID0gcmVzdWx0WzBdPy5bMF0gYXMgRkFRRW50cnkgfHwgbnVsbDtcbiAgICBcbiAgICBpZiAoZmFxRW50cnkpIHtcbiAgICAgIGNvbnNvbGUubG9nKCdGQVEgRW50cnkgZmV0Y2hlZDonLCB7XG4gICAgICAgIHRpdGxlOiBmYXFFbnRyeS5zZWN0aW9uX3RpdGxlLFxuICAgICAgICBoYXNJY29uOiAhIWZhcUVudHJ5Lmljb24sXG4gICAgICAgIGZhcVF1ZXN0aW9uVHlwZTogQXJyYXkuaXNBcnJheShmYXFFbnRyeS5mYXFfcXVlc3Rpb24pID8gJ2FycmF5JyA6ICdvYmplY3QnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBmYXFFbnRyeTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBGQVEnLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEJhbm5lciBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggYWxsIEJhbm5lciBlbnRyaWVzXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRBbGxCYW5uZXJzKCk6IFByb21pc2U8QmFubmVyRW50cnlbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQkFOTkVSKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZpbmQoKTtcbiAgICByZXR1cm4gKHJlc3VsdFswXSB8fCBbXSkgYXMgQmFubmVyRW50cnlbXTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBiYW5uZXJzJywgZXJyb3IpO1xuICAgIHJldHVybiBbXTtcbiAgfVxufVxuXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gVGVzdGltb25pYWwgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGFsbCBUZXN0aW1vbmlhbCBlbnRyaWVzIHdpdGggYXV0aG9yIHJlZmVyZW5jZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QWxsVGVzdGltb25pYWxzKCk6IFByb21pc2U8VGVzdGltb25pYWxFbnRyeVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5URVNUSU1PTklBTClcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZSgnYXV0aG9yJylcbiAgICAgIC50b0pTT04oKVxuICAgICAgLmZpbmQoKTtcbiAgICByZXR1cm4gKHJlc3VsdFswXSB8fCBbXSkgYXMgVGVzdGltb25pYWxFbnRyeVtdO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHRlc3RpbW9uaWFscycsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIENvdXJzZSBGZXRjaCBGdW5jdGlvbnNcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbi8qKlxuICogRmV0Y2ggYWxsIGNvdXJzZXMgd2l0aCBhdXRob3IgcmVmZXJlbmNlXG4gKiBGYWxscyBiYWNrIHRvIEVuZ2xpc2ggaWYgbm8gY29udGVudCBmb3VuZCBpbiBzZWxlY3RlZCBsb2NhbGVcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbENvdXJzZXMobG9jYWxlPzogc3RyaW5nKTogUHJvbWlzZTxDb3Vyc2VFbnRyeVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBcbiAgICAvLyBGaXJzdCB0cnkgd2l0aCBzZWxlY3RlZCBsb2NhbGVcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ09VUlNFKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnYXV0aG9yJywgJ21vZHVsZXMnXSk7XG4gICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcbiAgICBcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgbGV0IGNvdXJzZXMgPSAocmVzdWx0WzBdIHx8IFtdKSBhcyBDb3Vyc2VFbnRyeVtdO1xuICAgIFxuICAgIC8vIElmIG5vIGNvdXJzZXMgZm91bmQgYW5kIHdlJ3JlIG5vdCBhbHJlYWR5IHVzaW5nIGZhbGxiYWNrLCB0cnkgZmFsbGJhY2sgbG9jYWxlXG4gICAgaWYgKGNvdXJzZXMubGVuZ3RoID09PSAwICYmIHRhcmdldExvY2FsZSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gTm8gY291cnNlcyBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgICAgLlF1ZXJ5KClcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydhdXRob3InLCAnbW9kdWxlcyddKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIGNvdXJzZXMgPSAoZmFsbGJhY2tSZXN1bHRbMF0gfHwgW10pIGFzIENvdXJzZUVudHJ5W107XG4gICAgfVxuICAgIFxuICAgIC8vIFJlc29sdmUgYXV0aG9yIHJlZmVyZW5jZXMgZm9yIGFsbCBjb3Vyc2VzXG4gICAgY29uc3QgcmVzb2x2ZWRDb3Vyc2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBjb3Vyc2VzLm1hcChjb3Vyc2UgPT4gcmVzb2x2ZUF1dGhvclJlZmVyZW5jZXMoY291cnNlKSlcbiAgICApO1xuICAgIFxuICAgIHJldHVybiByZXNvbHZlZENvdXJzZXM7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgY291cnNlcycsIGVycm9yKTtcbiAgICByZXR1cm4gW107XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBhdXRob3IgYnkgVUlEIC0gYWx3YXlzIGZldGNoZXMgZnJvbSBkZWZhdWx0IGxvY2FsZSBzaW5jZSBhdXRob3JzIGFyZSBub3QgbG9jYWxpemVkXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEF1dGhvckJ5VWlkKHVpZDogc3RyaW5nKTogUHJvbWlzZTxBdXRob3JFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQVVUSE9SKVxuICAgICAgLkVudHJ5KHVpZCk7XG4gICAgLy8gQWx3YXlzIGZldGNoIGF1dGhvcnMgaW4gZmFsbGJhY2sgbG9jYWxlIHNpbmNlIGF1dGhvciBkYXRhIChuYW1lLCBiaW8pIGlzIG5vbi1sb2NhbGl6YWJsZVxuICAgIHF1ZXJ5Lmxhbmd1YWdlKEZBTExCQUNLX0xPQ0FMRSk7XG4gICAgXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICByZXR1cm4gcmVzdWx0IGFzIEF1dGhvckVudHJ5O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGF1dGhvciBieSBVSUQ6ICR7dWlkfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB0byByZXNvbHZlIGF1dGhvciByZWZlcmVuY2VzIHRoYXQgbWF5IG5vdCBiZSBmdWxseSBwb3B1bGF0ZWRcbiAqIFdoZW4gZmV0Y2hpbmcgbG9jYWxpemVkIGNvbnRlbnQsIHJlZmVyZW5jZXMgdG8gbm9uLWxvY2FsaXplZCBlbnRyaWVzIG1heSBub3QgcmVzb2x2ZVxuICogVGhpcyBmdW5jdGlvbiBhbHdheXMgZmV0Y2hlcyBhdXRob3IgZGF0YSBmcm9tIHRoZSBmYWxsYmFjayBsb2NhbGUgdG8gZW5zdXJlIGNvbnNpc3RlbmN5XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlc29sdmVBdXRob3JSZWZlcmVuY2VzKGNvdXJzZTogQ291cnNlRW50cnkpOiBQcm9taXNlPENvdXJzZUVudHJ5PiB7XG4gIGlmICghY291cnNlLmF1dGhvcikgcmV0dXJuIGNvdXJzZTtcbiAgXG4gIGNvbnN0IGF1dGhvcnMgPSBBcnJheS5pc0FycmF5KGNvdXJzZS5hdXRob3IpID8gY291cnNlLmF1dGhvciA6IFtjb3Vyc2UuYXV0aG9yXTtcbiAgY29uc3QgcmVzb2x2ZWRBdXRob3JzOiBBdXRob3JFbnRyeVtdID0gW107XG4gIFxuICBmb3IgKGNvbnN0IGF1dGhvciBvZiBhdXRob3JzKSB7XG4gICAgLy8gQWx3YXlzIGZldGNoIHRoZSBmdWxsIGF1dGhvciBkYXRhIGZyb20gZmFsbGJhY2sgbG9jYWxlIHRvIGVuc3VyZSB3ZSBoYXZlIGFsbCBmaWVsZHNcbiAgICAvLyBUaGlzIGlzIGJlY2F1c2UgYXV0aG9yIGRhdGEgKG5hbWUsIGJpbywgc29jaWFsIGxpbmtzKSBpcyBtYXJrZWQgYXMgbm9uLWxvY2FsaXphYmxlXG4gICAgLy8gYnV0IHdoZW4gZmV0Y2hpbmcgY291cnNlIGluIGEgZGlmZmVyZW50IGxvY2FsZSwgdGhlIHJlZmVyZW5jZSBtYXkgbm90IHJlc29sdmUgcHJvcGVybHlcbiAgICBpZiAoYXV0aG9yLnVpZCkge1xuICAgICAgLy8gQWx3YXlzIGZldGNoIGZyZXNoIHRvIGVuc3VyZSB3ZSBnZXQgY29tcGxldGUgZGF0YVxuICAgICAgY29uc3QgZnVsbEF1dGhvciA9IGF3YWl0IGdldEF1dGhvckJ5VWlkKGF1dGhvci51aWQpO1xuICAgICAgaWYgKGZ1bGxBdXRob3IpIHtcbiAgICAgICAgcmVzb2x2ZWRBdXRob3JzLnB1c2goZnVsbEF1dGhvcik7XG4gICAgICB9IGVsc2UgaWYgKGF1dGhvci50aXRsZSkge1xuICAgICAgICAvLyBGYWxsYmFjazogaWYgZmV0Y2ggZmFpbHMgYnV0IHdlIGhhdmUgcGFydGlhbCBkYXRhLCB1c2UgaXRcbiAgICAgICAgcmVzb2x2ZWRBdXRob3JzLnB1c2goYXV0aG9yKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGF1dGhvci50aXRsZSkge1xuICAgICAgLy8gTm8gVUlEIGJ1dCBoYXMgdGl0bGUgLSB1c2UgYXMgaXNcbiAgICAgIHJlc29sdmVkQXV0aG9ycy5wdXNoKGF1dGhvcik7XG4gICAgfVxuICB9XG4gIFxuICBjb3Vyc2UuYXV0aG9yID0gcmVzb2x2ZWRBdXRob3JzLmxlbmd0aCA+IDAgPyByZXNvbHZlZEF1dGhvcnMgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBjb3Vyc2U7XG59XG5cbi8qKlxuICogRmV0Y2ggYSBzaW5nbGUgY291cnNlIGJ5IHNsdWcgd2l0aCBhbGwgbmVzdGVkIHJlZmVyZW5jZXNcbiAqIEZhbGxzIGJhY2sgdG8gRW5nbGlzaCBpZiBubyBjb250ZW50IGZvdW5kIGluIHNlbGVjdGVkIGxvY2FsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlQnlTbHVnKHNsdWc6IHN0cmluZywgbG9jYWxlPzogc3RyaW5nKTogUHJvbWlzZTxDb3Vyc2VFbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YXJnZXRMb2NhbGUgPSBsb2NhbGUgfHwgZ2V0Q3VycmVudExvY2FsZSgpO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIHNlbGVjdGVkIGxvY2FsZVxuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5DT1VSU0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCdzbHVnJywgc2x1ZylcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFtcbiAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICdtb2R1bGVzJyxcbiAgICAgICAgJ21vZHVsZXMubGVzc29ucydcbiAgICAgIF0pO1xuICAgIHF1ZXJ5Lmxhbmd1YWdlKHRhcmdldExvY2FsZSk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgbGV0IGNvdXJzZSA9IHJlc3VsdFswXT8uWzBdIGFzIENvdXJzZUVudHJ5IHx8IG51bGw7XG4gICAgXG4gICAgLy8gSWYgbm8gY291cnNlIGZvdW5kIGFuZCB3ZSdyZSBub3QgYWxyZWFkeSB1c2luZyBmYWxsYmFjaywgdHJ5IGZhbGxiYWNrIGxvY2FsZVxuICAgIGlmICghY291cnNlICYmIHRhcmdldExvY2FsZSAhPT0gRkFMTEJBQ0tfTE9DQUxFKSB7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gQ291cnNlIG5vdCBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgIGNvbnN0IGZhbGxiYWNrUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgICAgLlF1ZXJ5KClcbiAgICAgICAgLndoZXJlKCdzbHVnJywgc2x1ZylcbiAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAgICdhdXRob3InLFxuICAgICAgICAgICdtb2R1bGVzJyxcbiAgICAgICAgICAnbW9kdWxlcy5sZXNzb25zJ1xuICAgICAgICBdKTtcbiAgICAgIGZhbGxiYWNrUXVlcnkubGFuZ3VhZ2UoRkFMTEJBQ0tfTE9DQUxFKTtcbiAgICAgIFxuICAgICAgY29uc3QgZmFsbGJhY2tSZXN1bHQgPSBhd2FpdCBmYWxsYmFja1F1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIGNvdXJzZSA9IGZhbGxiYWNrUmVzdWx0WzBdPy5bMF0gYXMgQ291cnNlRW50cnkgfHwgbnVsbDtcbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIGF1dGhvciByZWZlcmVuY2VzIGFyZSBmdWxseSByZXNvbHZlZFxuICAgIGlmIChjb3Vyc2UpIHtcbiAgICAgIGNvdXJzZSA9IGF3YWl0IHJlc29sdmVBdXRob3JSZWZlcmVuY2VzKGNvdXJzZSk7XG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gQ291cnNlIFwiJHtjb3Vyc2UudGl0bGV9XCIgbG9hZGVkIHdpdGggJHtBcnJheS5pc0FycmF5KGNvdXJzZS5tb2R1bGVzKSA/IGNvdXJzZS5tb2R1bGVzLmxlbmd0aCA6IGNvdXJzZS5tb2R1bGVzID8gMSA6IDB9IG1vZHVsZXNgKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGNvdXJzZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGBFcnJvciBmZXRjaGluZyBjb3Vyc2UgYnkgc2x1ZzogJHtzbHVnfWAsIGVycm9yKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIGNvdXJzZSBieSBVSUQgd2l0aCBhbGwgbmVzdGVkIHJlZmVyZW5jZXNcbiAqIEZhbGxzIGJhY2sgdG8gRW5nbGlzaCBpZiBubyBjb250ZW50IGZvdW5kIGluIHNlbGVjdGVkIGxvY2FsZVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q291cnNlQnlVaWQodWlkOiBzdHJpbmcsIGxvY2FsZT86IHN0cmluZyk6IFByb21pc2U8Q291cnNlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgdGFyZ2V0TG9jYWxlID0gbG9jYWxlIHx8IGdldEN1cnJlbnRMb2NhbGUoKTtcbiAgICBsZXQgY291cnNlOiBDb3Vyc2VFbnRyeSB8IG51bGwgPSBudWxsO1xuICAgIFxuICAgIC8vIEZpcnN0IHRyeSB3aXRoIHNlbGVjdGVkIGxvY2FsZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBxdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ09VUlNFKVxuICAgICAgICAuRW50cnkodWlkKVxuICAgICAgICAuaW5jbHVkZVJlZmVyZW5jZShbXG4gICAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICAgJ21vZHVsZXMnLFxuICAgICAgICAgICdtb2R1bGVzLmxlc3NvbnMnXG4gICAgICAgIF0pO1xuICAgICAgcXVlcnkubGFuZ3VhZ2UodGFyZ2V0TG9jYWxlKTtcbiAgICAgIFxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICAgIGNvdXJzZSA9IHJlc3VsdCBhcyBDb3Vyc2VFbnRyeTtcbiAgICB9IGNhdGNoIChsb2NhbGVFcnJvcikge1xuICAgICAgLy8gSWYgbG9jYWxlIGZldGNoIGZhaWxzIGFuZCB3ZSdyZSBub3QgYWxyZWFkeSB1c2luZyBmYWxsYmFjaywgdHJ5IGZhbGxiYWNrXG4gICAgICBpZiAodGFyZ2V0TG9jYWxlICE9PSBGQUxMQkFDS19MT0NBTEUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFtDTVNdIENvdXJzZSBVSUQgJHt1aWR9IG5vdCBmb3VuZCBpbiAke3RhcmdldExvY2FsZX0sIGZhbGxpbmcgYmFjayB0byAke0ZBTExCQUNLX0xPQ0FMRX1gKTtcbiAgICAgICAgY29uc3QgZmFsbGJhY2tRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuQ09VUlNFKVxuICAgICAgICAgIC5FbnRyeSh1aWQpXG4gICAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoW1xuICAgICAgICAgICAgJ2F1dGhvcicsXG4gICAgICAgICAgICAnbW9kdWxlcycsXG4gICAgICAgICAgICAnbW9kdWxlcy5sZXNzb25zJ1xuICAgICAgICAgIF0pO1xuICAgICAgICBmYWxsYmFja1F1ZXJ5Lmxhbmd1YWdlKEZBTExCQUNLX0xPQ0FMRSk7XG4gICAgICAgIFxuICAgICAgICBjb25zdCBmYWxsYmFja1Jlc3VsdCA9IGF3YWl0IGZhbGxiYWNrUXVlcnkudG9KU09OKCkuZmV0Y2goKTtcbiAgICAgICAgY291cnNlID0gZmFsbGJhY2tSZXN1bHQgYXMgQ291cnNlRW50cnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBsb2NhbGVFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gRW5zdXJlIGF1dGhvciByZWZlcmVuY2VzIGFyZSBmdWxseSByZXNvbHZlZFxuICAgIGlmIChjb3Vyc2UpIHtcbiAgICAgIGNvdXJzZSA9IGF3YWl0IHJlc29sdmVBdXRob3JSZWZlcmVuY2VzKGNvdXJzZSk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjb3Vyc2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgY291cnNlIGJ5IFVJRDogJHt1aWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBNb2R1bGUgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIG1vZHVsZSBieSBVSUQgd2l0aCBsZXNzb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRNb2R1bGVCeVVpZCh1aWQ6IHN0cmluZyk6IFByb21pc2U8TW9kdWxlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5NT0RVTEUpXG4gICAgICAuRW50cnkodWlkKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydsZXNzb25zJ10pXG4gICAgICAudG9KU09OKClcbiAgICAgIC5mZXRjaCgpO1xuICAgIHJldHVybiByZXN1bHQgYXMgTW9kdWxlRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbW9kdWxlIGJ5IFVJRDogJHt1aWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBMZXNzb24gRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGEgc2luZ2xlIGxlc3NvbiBieSBVSURcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExlc3NvbkJ5VWlkKHVpZDogc3RyaW5nKTogUHJvbWlzZTxMZXNzb25FbnRyeSB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkxFU1NPTilcbiAgICAgIC5FbnRyeSh1aWQpXG4gICAgICAudG9KU09OKClcbiAgICAgIC5mZXRjaCgpO1xuICAgIHJldHVybiByZXN1bHQgYXMgTGVzc29uRW50cnk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGVzc29uIGJ5IFVJRDogJHt1aWR9YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmV0Y2ggYSBzaW5nbGUgbGVzc29uIGJ5IHNsdWdcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldExlc3NvbkJ5U2x1ZyhzbHVnOiBzdHJpbmcpOiBQcm9taXNlPExlc3NvbkVudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoQ09OVEVOVF9UWVBFUy5MRVNTT04pXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCdzbHVnJywgc2x1Zyk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBxdWVyeS50b0pTT04oKS5maW5kKCk7XG4gICAgcmV0dXJuIHJlc3VsdFswXT8uWzBdIGFzIExlc3NvbkVudHJ5IHx8IG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgbGVzc29uIGJ5IHNsdWc6ICR7c2x1Z31gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGZXRjaCBjb3Vyc2UgZGF0YSBmb3IgYSBnaXZlbiBsZXNzb24gKHRvIGdldCBjb3Vyc2UgY29udGV4dClcbiAqIFJldHVybnMgdGhlIGNvdXJzZSB0aGF0IGNvbnRhaW5zIHRoaXMgbGVzc29uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRDb3Vyc2VCeUxlc3NvblVpZChsZXNzb25VaWQ6IHN0cmluZyk6IFByb21pc2U8Q291cnNlRW50cnkgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgLy8gRmlyc3QsIGZpbmQgd2hpY2ggbW9kdWxlIGNvbnRhaW5zIHRoaXMgbGVzc29uXG4gICAgY29uc3QgbW9kdWxlc1Jlc3VsdCA9IGF3YWl0IFN0YWNrLkNvbnRlbnRUeXBlKENPTlRFTlRfVFlQRVMuTU9EVUxFKVxuICAgICAgLlF1ZXJ5KClcbiAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsnbGVzc29ucyddKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIFxuICAgIGNvbnN0IG1vZHVsZXMgPSAobW9kdWxlc1Jlc3VsdFswXSB8fCBbXSkgYXMgTW9kdWxlRW50cnlbXTtcbiAgICBsZXQgdGFyZ2V0TW9kdWxlVWlkOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcbiAgICBcbiAgICBmb3IgKGNvbnN0IG1vZHVsZSBvZiBtb2R1bGVzKSB7XG4gICAgICBjb25zdCBsZXNzb25zID0gQXJyYXkuaXNBcnJheShtb2R1bGUubGVzc29ucykgPyBtb2R1bGUubGVzc29ucyA6IG1vZHVsZS5sZXNzb25zID8gW21vZHVsZS5sZXNzb25zXSA6IFtdO1xuICAgICAgaWYgKGxlc3NvbnMuc29tZShsZXNzb24gPT4gbGVzc29uLnVpZCA9PT0gbGVzc29uVWlkKSkge1xuICAgICAgICB0YXJnZXRNb2R1bGVVaWQgPSBtb2R1bGUudWlkO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKCF0YXJnZXRNb2R1bGVVaWQpIHJldHVybiBudWxsO1xuICAgIFxuICAgIC8vIE5vdyBmaW5kIHRoZSBjb3Vyc2UgdGhhdCBjb250YWlucyB0aGlzIG1vZHVsZVxuICAgIGNvbnN0IGNvdXJzZXNSZXN1bHQgPSBhd2FpdCBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkNPVVJTRSlcbiAgICAgIC5RdWVyeSgpXG4gICAgICAuaW5jbHVkZVJlZmVyZW5jZShbJ2F1dGhvcicsICdtb2R1bGVzJywgJ21vZHVsZXMubGVzc29ucyddKVxuICAgICAgLnRvSlNPTigpXG4gICAgICAuZmluZCgpO1xuICAgIFxuICAgIGNvbnN0IGNvdXJzZXMgPSAoY291cnNlc1Jlc3VsdFswXSB8fCBbXSkgYXMgQ291cnNlRW50cnlbXTtcbiAgICBcbiAgICBmb3IgKGNvbnN0IGNvdXJzZSBvZiBjb3Vyc2VzKSB7XG4gICAgICBjb25zdCBjb3Vyc2VNb2R1bGVzID0gQXJyYXkuaXNBcnJheShjb3Vyc2UubW9kdWxlcykgPyBjb3Vyc2UubW9kdWxlcyA6IGNvdXJzZS5tb2R1bGVzID8gW2NvdXJzZS5tb2R1bGVzXSA6IFtdO1xuICAgICAgaWYgKGNvdXJzZU1vZHVsZXMuc29tZShtID0+IG0udWlkID09PSB0YXJnZXRNb2R1bGVVaWQpKSB7XG4gICAgICAgIHJldHVybiBjb3Vyc2U7XG4gICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBudWxsO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGZldGNoaW5nIGNvdXJzZSBieSBsZXNzb24gVUlEOiAke2xlc3NvblVpZH1gLCBlcnJvcik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIE9uYm9hcmRpbmcgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIGFsbCBvbmJvYXJkaW5nIHN0ZXBzXG4gKiBSZXR1cm5zIHN0ZXBzIHNvcnRlZCBieSBjdXJyZW50X3N0ZXBcbiAqIFRyaWVzIG11bHRpcGxlIGNvbnRlbnQgdHlwZSBuYW1lcyBpbiBjYXNlIHRoZSBleGFjdCBuYW1lIGRpZmZlcnNcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFsbE9uYm9hcmRpbmdTdGVwcygpOiBQcm9taXNlPE9uYm9hcmRpbmdCbG9ja0VudHJ5W10+IHtcbiAgLy8gVHJ5IGRpZmZlcmVudCBwb3NzaWJsZSBjb250ZW50IHR5cGUgbmFtZXNcbiAgY29uc3QgcG9zc2libGVDb250ZW50VHlwZXMgPSBbXG4gICAgJ29uYm9hcmRpbmdfYmxvY2snLFxuICAgICdvbmJvYXJkaW5nJyxcbiAgICAnb25ib2FyZGluZ19zdGVwJyxcbiAgICAnb25ib2FyZGluZ19zdGVwcycsXG4gICAgJ21vZHVsYXJfc2VjdGlvbicsICAvLyBNYXliZSBzdG9yZWQgYXMgbW9kdWxhciBzZWN0aW9ucyB3aXRoIHNwZWNpZmljIHBhdHRlcm5cbiAgXTtcblxuICBmb3IgKGNvbnN0IGNvbnRlbnRUeXBlIG9mIHBvc3NpYmxlQ29udGVudFR5cGVzKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJhc2VRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlKS5RdWVyeSgpO1xuICAgICAgXG4gICAgICAvLyBJZiBpdCdzIG1vZHVsYXJfc2VjdGlvbiwgZmlsdGVyIGZvciBvbmJvYXJkaW5nIGVudHJpZXNcbiAgICAgIGlmIChjb250ZW50VHlwZSA9PT0gJ21vZHVsYXJfc2VjdGlvbicpIHtcbiAgICAgICAgYmFzZVF1ZXJ5LndoZXJlKCd0aXRsZScsICdPbmJvYXJkaW5nIFN0ZXAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbmJvYXJkaW5nLXNwZWNpZmljIGNvbnRlbnQgdHlwZXMsIGluY2x1ZGUgb3B0aW9uIHJlZmVyZW5jZXNcbiAgICAgICAgYmFzZVF1ZXJ5LmluY2x1ZGVSZWZlcmVuY2UoJ29wdGlvbicpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBiYXNlUXVlcnkuYXNjZW5kaW5nKCdjdXJyZW50X3N0ZXAnKTsgIC8vIFNvcnQgYnkgc3RlcCBudW1iZXJcblxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYmFzZVF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSAocmVzdWx0WzBdIHx8IFtdKSBhcyBhbnlbXTtcbiAgICAgIFxuICAgICAgY29uc29sZS5sb2coYFtDTVNdIEF0dGVtcHRlZCAke2NvbnRlbnRUeXBlfTogRm91bmQgJHtlbnRyaWVzLmxlbmd0aH0gZW50cmllc2ApO1xuICAgICAgXG4gICAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIC8vIEZpbHRlciBhbmQgdHJhbnNmb3JtIGVudHJpZXNcbiAgICAgICAgY29uc3Qgb25ib2FyZGluZ0VudHJpZXM6IE9uYm9hcmRpbmdCbG9ja0VudHJ5W10gPSBlbnRyaWVzXG4gICAgICAgICAgLmZpbHRlcigoZW50cnk6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZW50cnkgaGFzIG9uYm9hcmRpbmctcmVsYXRlZCBmaWVsZHNcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5jdXJyZW50X3N0ZXAgIT09IHVuZGVmaW5lZCB8fCBcbiAgICAgICAgICAgICAgICAgICBlbnRyeS5sYWJlbF90ZXh0ICE9PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICBlbnRyeS50aXRsZT8udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnb25ib2FyZGluZycpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcCgoZW50cnk6IGFueSkgPT4ge1xuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRvIE9uYm9hcmRpbmdCbG9ja0VudHJ5IGZvcm1hdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdWlkOiBlbnRyeS51aWQgfHwgZW50cnkuX2lkIHx8ICcnLFxuICAgICAgICAgICAgICB0aXRsZTogZW50cnkudGl0bGUsXG4gICAgICAgICAgICAgIGN1cnJlbnRfc3RlcDogZW50cnkuY3VycmVudF9zdGVwIHx8IHBhcnNlSW50KGVudHJ5LnRpdGxlPy5tYXRjaCgvXFxkKy8pPy5bMF0gfHwgJzEnKSxcbiAgICAgICAgICAgICAgdG90YWxfc3RlcHM6IGVudHJ5LnRvdGFsX3N0ZXBzIHx8IDUsXG4gICAgICAgICAgICAgIGxhYmVsX3RleHQ6IGVudHJ5LmxhYmVsX3RleHQgfHwgZW50cnkudGl0bGUgfHwgJycsXG4gICAgICAgICAgICAgIGRpc3BsYXlfdHlwZTogZW50cnkuZGlzcGxheV90eXBlIHx8ICdDYXJkIEdyaWQnLFxuICAgICAgICAgICAgICBvcHRpb246IGVudHJ5Lm9wdGlvbiB8fCBbXSxcbiAgICAgICAgICAgICAgYmFja19idXR0b25fdGV4dDogZW50cnkuYmFja19idXR0b25fdGV4dCB8fCAnQmFjaycsXG4gICAgICAgICAgICAgIG5leHRfYnV0dG9uX3RleHQ6IGVudHJ5Lm5leHRfYnV0dG9uX3RleHQgfHwgJ0NvbnRpbnVlJyxcbiAgICAgICAgICAgIH0gYXMgT25ib2FyZGluZ0Jsb2NrRW50cnk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZiAob25ib2FyZGluZ0VudHJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBTdWNjZXNzZnVsbHkgZmV0Y2hlZCAke29uYm9hcmRpbmdFbnRyaWVzLmxlbmd0aH0gb25ib2FyZGluZyBzdGVwcyBmcm9tICR7Y29udGVudFR5cGV9YCk7XG4gICAgICAgICAgcmV0dXJuIG9uYm9hcmRpbmdFbnRyaWVzLnNvcnQoKGEsIGIpID0+IGEuY3VycmVudF9zdGVwIC0gYi5jdXJyZW50X3N0ZXApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgICAgLy8gTG9nIHRoZSBlcnJvciBidXQgY29udGludWUgdHJ5aW5nIG90aGVyIGNvbnRlbnQgdHlwZXNcbiAgICAgIGNvbnNvbGUubG9nKGBbQ01TXSBDb250ZW50IHR5cGUgJHtjb250ZW50VHlwZX0gZmFpbGVkOmAsIGVycm9yLm1lc3NhZ2UgfHwgZXJyb3IpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgbm8gY29udGVudCB0eXBlIGZvdW5kLCB0cnkgc2VhcmNoaW5nIG1vZHVsYXJfc2VjdGlvbiBmb3IgYW55IG9uYm9hcmRpbmctcmVsYXRlZCBlbnRyaWVzXG4gIHRyeSB7XG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLlBBR0UpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydzZWN0aW9uJ10pO1xuICAgIFxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHF1ZXJ5LnRvSlNPTigpLmZpbmQoKTtcbiAgICBjb25zdCBwYWdlcyA9IChyZXN1bHRbMF0gfHwgW10pIGFzIFBhZ2VFbnRyeVtdO1xuICAgIFxuICAgIC8vIExvb2sgZm9yIHBhZ2VzIHdpdGggXCJPbmJvYXJkaW5nXCIgaW4gdGl0bGVcbiAgICBjb25zdCBvbmJvYXJkaW5nUGFnZXMgPSBwYWdlcy5maWx0ZXIocGFnZSA9PiBcbiAgICAgIHBhZ2UudGl0bGU/LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ29uYm9hcmRpbmcnKVxuICAgICk7XG4gICAgXG4gICAgaWYgKG9uYm9hcmRpbmdQYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnW0NNU10gRm91bmQgb25ib2FyZGluZyBwYWdlKHMpLCBidXQgbmVlZCBwcm9wZXIgY29udGVudCB0eXBlIHN0cnVjdHVyZScpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZWFyY2hpbmcgZm9yIG9uYm9hcmRpbmcgcGFnZTonLCBlcnJvcik7XG4gIH1cblxuICBjb25zb2xlLndhcm4oJ1tDTVNdIE5vIG9uYm9hcmRpbmcgY29udGVudCB0eXBlIGZvdW5kLiBQbGVhc2UgY2hlY2s6Jyk7XG4gIGNvbnNvbGUud2FybignMS4gQ29udGVudCB0eXBlIG5hbWUgaW4gQ29udGVudHN0YWNrIChtaWdodCBiZSBkaWZmZXJlbnQpJyk7XG4gIGNvbnNvbGUud2FybignMi4gRW50cmllcyBhcmUgcHVibGlzaGVkJyk7XG4gIGNvbnNvbGUud2FybignMy4gQVBJIGtleXMgYW5kIGVudmlyb25tZW50IGFyZSBjb3JyZWN0Jyk7XG4gIHJldHVybiBbXTtcbn1cblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEF1dGggQnJhbmRpbmcgRmV0Y2ggRnVuY3Rpb25zXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuXG4vKipcbiAqIEZldGNoIEF1dGggQnJhbmRpbmcgZW50cnkgYnkgcGFnZSB0eXBlIChsb2dpbiBvciBzaWdudXApXG4gKiBNYXRjaGVzIENvbnRlbnRzdGFjayBzY2hlbWE6IHBhZ2VfdHlwZSBpcyBcIlNpZ24gSW5cIiBvciBcIlNpZ24gVXBcIlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aEJyYW5kaW5nKHBhZ2VUeXBlOiAnbG9naW4nIHwgJ3NpZ251cCcpOiBQcm9taXNlPEF1dGhCcmFuZGluZ0VudHJ5IHwgbnVsbD4ge1xuICB0cnkge1xuICAgIC8vIENvbnZlcnQgbG93ZXJjYXNlIHRvIENvbnRlbnRzdGFjayBmb3JtYXRcbiAgICBjb25zdCBwYWdlVHlwZVZhbHVlID0gcGFnZVR5cGUgPT09ICdsb2dpbicgPyAnU2lnbiBJbicgOiAnU2lnbiBVcCc7XG4gICAgXG4gICAgY29uc3QgcXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShDT05URU5UX1RZUEVTLkFVVEhfQlJBTkRJTkcpXG4gICAgICAuUXVlcnkoKVxuICAgICAgLndoZXJlKCdwYWdlX3R5cGUnLCBwYWdlVHlwZVZhbHVlKVxuICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoWydzdGF0cyddKTsgIC8vIHN0YXRzIGlzIHJlZmVyZW5jZSB0byBpY29uIGNvbnRlbnQgdHlwZVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcXVlcnkudG9KU09OKCkuZmluZCgpO1xuICAgIGNvbnN0IGVudHJpZXMgPSAocmVzdWx0WzBdIHx8IFtdKSBhcyBhbnlbXTtcbiAgICBcbiAgICBpZiAoZW50cmllcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBlbnRyeSA9IGVudHJpZXNbMF07XG4gICAgICBcbiAgICAgIC8vIExvZyBmb3IgZGVidWdnaW5nXG4gICAgICBjb25zb2xlLmxvZyhgW0NNU10gQXV0aCBicmFuZGluZyBlbnRyeSBmb3IgJHtwYWdlVHlwZX06YCwge1xuICAgICAgICBoZWFkbGluZTogZW50cnkuaGVhZGxpbmUsXG4gICAgICAgIHN1YnRpdGxlOiBlbnRyeS5zdWJ0aXRsZSxcbiAgICAgICAgYnJhbmRpbmdfY29udGVudDogZW50cnkuYnJhbmRpbmdfY29udGVudCxcbiAgICAgICAgc3RhdHM6IGVudHJ5LnN0YXRzLFxuICAgICAgICBzdGF0c1R5cGU6IEFycmF5LmlzQXJyYXkoZW50cnkuc3RhdHMpID8gJ2FycmF5JyA6IHR5cGVvZiBlbnRyeS5zdGF0cyxcbiAgICAgIH0pO1xuICAgICAgXG4gICAgICByZXR1cm4ge1xuICAgICAgICB1aWQ6IGVudHJ5LnVpZCB8fCBlbnRyeS5faWQgfHwgJycsXG4gICAgICAgIHRpdGxlOiBlbnRyeS50aXRsZSB8fCAnJyxcbiAgICAgICAgcGFnZV90eXBlOiBlbnRyeS5wYWdlX3R5cGUgfHwgcGFnZVR5cGVWYWx1ZSxcbiAgICAgICAgaGVhZGxpbmU6IGVudHJ5LmhlYWRsaW5lLFxuICAgICAgICBzdWJ0aXRsZTogZW50cnkuc3VidGl0bGUsICAvLyBGaWVsZCBuYW1lIGlzIFwic3VidGl0bGVcIiBub3QgXCJkZXNjcmlwdGlvblwiXG4gICAgICAgIGJyYW5kaW5nX2NvbnRlbnQ6IGVudHJ5LmJyYW5kaW5nX2NvbnRlbnQsICAvLyBSaWNoIHRleHQgY29udGVudFxuICAgICAgICBzdGF0czogZW50cnkuc3RhdHMsICAvLyBDYW4gYmUgc2luZ2xlIEljb25FbnRyeSBvciBhcnJheSBvZiBJY29uRW50cnkgKHNob3VsZCBiZSBleHBhbmRlZCBieSBpbmNsdWRlUmVmZXJlbmNlKVxuICAgICAgICBiYWNrZ3JvdW5kX2ltYWdlOiBlbnRyeS5iYWNrZ3JvdW5kX2ltYWdlLFxuICAgICAgfSBhcyBBdXRoQnJhbmRpbmdFbnRyeTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihgRXJyb3IgZmV0Y2hpbmcgYXV0aCBicmFuZGluZyBmb3IgJHtwYWdlVHlwZX06YCwgZXJyb3IpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8vIEV4cG9ydCB0aGUgU3RhY2sgZm9yIGFkdmFuY2VkIHVzYWdlXG5leHBvcnQgeyBTdGFjayB9O1xuIl0sIm5hbWVzIjpbIkNvbnRlbnRzdGFjayIsIlN0YWNrIiwiYXBpX2tleSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfQVBJX0tFWSIsIkNPTlRFTlRTVEFDS19BUElfS0VZIiwiZGVsaXZlcnlfdG9rZW4iLCJORVhUX1BVQkxJQ19DT05URU5UU1RBQ0tfREVMSVZFUllfVE9LRU4iLCJDT05URU5UU1RBQ0tfREVMSVZFUllfVE9LRU4iLCJlbnZpcm9ubWVudCIsIk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19FTlZJUk9OTUVOVCIsIkNPTlRFTlRTVEFDS19FTlZJUk9OTUVOVCIsImJyYW5jaCIsIk5FWFRfUFVCTElDX0NPTlRFTlRTVEFDS19CUkFOQ0giLCJDT05URU5UU1RBQ0tfQlJBTkNIIiwiQ09OVEVOVF9UWVBFUyIsIlBBR0UiLCJCQU5ORVIiLCJIRUFERVIiLCJGT09URVIiLCJORVdTTEVUVEVSIiwiSUNPTiIsIkZBUSIsIkZBUV9RVUVTVElPTiIsIlRFU1RJTU9OSUFMIiwiQVVUSE9SIiwiQ09VUlNFIiwiTU9EVUxFIiwiTEVTU09OIiwiQ0FURUdPUlkiLCJDQVRFR09SWV9CTE9DSyIsIklOU1RSVUNUT1IiLCJPTkJPQVJESU5HIiwiQVVUSF9CUkFORElORyIsImdldEN1cnJlbnRMb2NhbGUiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiRkFMTEJBQ0tfTE9DQUxFIiwiZ2V0RW50cnkiLCJjb250ZW50VHlwZSIsImVudHJ5VWlkIiwicmVmZXJlbmNlRmllbGRzIiwibG9jYWxlIiwicXVlcnkiLCJDb250ZW50VHlwZSIsIkVudHJ5IiwidGFyZ2V0TG9jYWxlIiwibGFuZ3VhZ2UiLCJmb3JFYWNoIiwiZmllbGQiLCJpbmNsdWRlUmVmZXJlbmNlIiwicmVzdWx0IiwidG9KU09OIiwiZmV0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJnZXRFbnRyaWVzIiwib3B0aW9ucyIsIlF1ZXJ5IiwibGltaXQiLCJza2lwIiwib3JkZXJCeSIsIm9yZGVyRGlyZWN0aW9uIiwiZGVzY2VuZGluZyIsImFzY2VuZGluZyIsIndoZXJlIiwiT2JqZWN0IiwiZW50cmllcyIsImtleSIsInZhbHVlIiwiZmluZCIsImdldEVudHJ5QnlVcmwiLCJ1cmwiLCJnZXRQYWdlIiwidGl0bGUiLCJwYWdlRW50cnkiLCJmYWxsYmFja1Jlc3VsdCIsImxvZyIsImZhbGxiYWNrUXVlcnkiLCJzZWN0aW9uIiwibGVuZ3RoIiwiZ2V0UGFnZUJ5VXJsIiwiZ2V0QWxsQ2F0ZWdvcmllcyIsImdldEhlYWRlciIsImhlYWRlciIsImFjY2Vzc2liaWxpdHlfbGFuZ3VhZ2UiLCJnZXRBbGxIZWFkZXJzIiwiZ2V0Rm9vdGVyIiwiZ2V0TmV3c2xldHRlciIsImdldEZBUSIsImZhcUVudHJ5Iiwic2VjdGlvbl90aXRsZSIsImhhc0ljb24iLCJpY29uIiwiZmFxUXVlc3Rpb25UeXBlIiwiQXJyYXkiLCJpc0FycmF5IiwiZmFxX3F1ZXN0aW9uIiwiZ2V0QWxsQmFubmVycyIsImdldEFsbFRlc3RpbW9uaWFscyIsImdldEFsbENvdXJzZXMiLCJjb3Vyc2VzIiwicmVzb2x2ZWRDb3Vyc2VzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImNvdXJzZSIsInJlc29sdmVBdXRob3JSZWZlcmVuY2VzIiwiZ2V0QXV0aG9yQnlVaWQiLCJ1aWQiLCJhdXRob3IiLCJhdXRob3JzIiwicmVzb2x2ZWRBdXRob3JzIiwiZnVsbEF1dGhvciIsInB1c2giLCJ1bmRlZmluZWQiLCJnZXRDb3Vyc2VCeVNsdWciLCJzbHVnIiwibW9kdWxlcyIsImdldENvdXJzZUJ5VWlkIiwibG9jYWxlRXJyb3IiLCJnZXRNb2R1bGVCeVVpZCIsImdldExlc3NvbkJ5VWlkIiwiZ2V0TGVzc29uQnlTbHVnIiwiZ2V0Q291cnNlQnlMZXNzb25VaWQiLCJsZXNzb25VaWQiLCJtb2R1bGVzUmVzdWx0IiwidGFyZ2V0TW9kdWxlVWlkIiwibW9kdWxlIiwibGVzc29ucyIsInNvbWUiLCJsZXNzb24iLCJjb3Vyc2VzUmVzdWx0IiwiY291cnNlTW9kdWxlcyIsIm0iLCJnZXRBbGxPbmJvYXJkaW5nU3RlcHMiLCJwb3NzaWJsZUNvbnRlbnRUeXBlcyIsImJhc2VRdWVyeSIsIm9uYm9hcmRpbmdFbnRyaWVzIiwiZmlsdGVyIiwiZW50cnkiLCJjdXJyZW50X3N0ZXAiLCJsYWJlbF90ZXh0IiwidG9Mb3dlckNhc2UiLCJpbmNsdWRlcyIsIl9pZCIsInBhcnNlSW50IiwibWF0Y2giLCJ0b3RhbF9zdGVwcyIsImRpc3BsYXlfdHlwZSIsIm9wdGlvbiIsImJhY2tfYnV0dG9uX3RleHQiLCJuZXh0X2J1dHRvbl90ZXh0Iiwic29ydCIsImEiLCJiIiwibWVzc2FnZSIsInBhZ2VzIiwib25ib2FyZGluZ1BhZ2VzIiwicGFnZSIsIndhcm4iLCJnZXRBdXRoQnJhbmRpbmciLCJwYWdlVHlwZSIsInBhZ2VUeXBlVmFsdWUiLCJoZWFkbGluZSIsInN1YnRpdGxlIiwiYnJhbmRpbmdfY29udGVudCIsInN0YXRzIiwic3RhdHNUeXBlIiwicGFnZV90eXBlIiwiYmFja2dyb3VuZF9pbWFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/contentstack.ts\n"));

/***/ })

});