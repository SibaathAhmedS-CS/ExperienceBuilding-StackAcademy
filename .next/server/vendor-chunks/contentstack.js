/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/contentstack";
exports.ids = ["vendor-chunks/contentstack"];
exports.modules = {

/***/ "(ssr)/./node_modules/contentstack/dist/node/contentstack.js":
/*!*************************************************************!*\
  !*** ./node_modules/contentstack/dist/node/contentstack.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ 42:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_154__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar Utils = _interopRequireWildcard(__nested_webpack_require_154__(925));\nvar _messages = _interopRequireDefault(__nested_webpack_require_154__(174));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof WeakMap) var r = new WeakMap(),\n    n = new WeakMap();\n  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        \"default\": e\n      };\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);\n    return f;\n  })(e, t);\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * @class\n  Entry\n* @summary Creates an instance of `Entry`.\n* @description An initializer is responsible for creating Entry object.\n* @param {String} uid - uid of the entry\n* @example\n* let Entry = Stack.ContentType('example').Entry('entry_uid');\n* @returns {Entry}\n* @instance\n*/\nvar Entry = exports[\"default\"] = /*#__PURE__*/function () {\n  function Entry() {\n    _classCallCheck(this, Entry);\n    this._query = {};\n    /**\n         * @method only\n         * @memberOf Entry\n         * @description Displays values of only the specified fields of entries or assets in the response\n         * @param {String} [key=BASE] -  Assets: </br>\n         *                                <p>Retrieves specified field of asset</p>\n         * @param {String}            -  Entries:</br>\n         *                                       <p>- retrieves default fields of the schema.</p>\n         *                                       <p>- referenced_content-type-uid : retrieves fields of the referred content type.</p>\n         * @param {Array} values - array of fields that you want to display in the response\n         * @example\n         * <caption> The only function with field_uid will include the data of only the specified fields for each entry and exclude the data of all other fields. </caption>\n         * Stack.ContentType('contentTypeUid').Query().only('title').toJSON().find()\n         * @example\n         * <caption> The only function with an array of field_uids will include multiple fields for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().only(['title','description']).toJSON().find()\n         * @example\n         * <caption> In only, we have the only with a reference parameter, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter to include the data of only the specified field_uid for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').only('reference_field_uid','title').toJSON().find()\n         * @example\n         * <caption> In only, we have the only with a reference parameter with an array, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter with an array of fields to include the data of only the specified array of field_uids for each entry and exclude the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').only('reference_field_uid', ['title', 'description']).toJSON().find()\n         *\n         * @returns {Entry}\n         * @instance\n         */\n    this.only = Utils.transform('only');\n    /**\n         * @method except\n         * @memberOf Entry\n         * @description Displays all data of an entries or assets excluding the data of the specified fields.\n         * @param {String} [key=BASE] - BASE (default value) - retrieves default fields of the schema.\n                                                             - referenced_content-type-uid - retrieves fields of the referred content type.\n         * @param {Array} values - array of fields that you want to skip in the response\n         * @example\n         * <caption> The except function with field_uid will exclude the data of only the specified fields for each entry and includes the data of all other fields. </caption>\n         * Stack.ContentType('contentTypeUid').Query().except('title').toJSON().find()\n         * @example\n         * <caption> The except function with an array of field_uids will except multiple fields for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().except(['title','description']).toJSON().find()\n         * @example\n         * <caption> In except, we have the only with a reference parameter, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter to except the data of only the specified field_uid for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').except('reference_field_uid','title').toJSON().find()\n         * @example\n         * <caption> In except, we have the only with a reference parameter with an array, where you need to enter the UID of the reference field in place of \"reference_field_uid\", and the second parameter with an array of fields to except the data of only the specified array of field_uids for each entry and include the data of all other fields.</caption>\n         * Stack.ContentType('contentTypeUid').Query().includeReference('reference_field_uid').except('reference_field_uid', ['title', 'description']).toJSON().find()\n         * @returns {Entry}\n         * @instance\n         */\n    this.except = Utils.transform('except');\n    return this;\n  }\n  return _createClass(Entry, [{\n    key: \"setCacheProvider\",\n    value: function setCacheProvider(provider) {\n      if (provider && _typeof(provider) === 'object') {\n        this.provider = provider;\n      }\n      return this;\n    }\n  }, {\n    key: \"setCachePolicy\",\n    value: function setCachePolicy(policy) {\n      if (typeof policy === 'number' && policy >= -1 && policy < 4) {\n        if (!this._query) {\n          this.cachePolicy = policy;\n        } else {\n          this.queryCachePolicy = policy;\n        }\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].CACHE_POLICY_INVALID);\n      }\n      return this;\n    }\n\n    /**\n       * @method includeReference\n       * @memberOf Entry\n       * @description Fetches the entire content of referenced entry(ies). <a href='https://www.contentstack.com/docs/developers/apis/content-delivery-api/#include-reference'>Read More</a>\n       * @example\n       * <caption> .includeReference with reference_field_uids as array </caption>\n       * var Query = Stack.ContentType(contentTypes.source).Query();\n              Query\n                  .includeReference(['reference_field_uid', 'other_reference_field_uid'])\n                  .toJSON()\n                  .find()\n                  .then(function success(entries) {\n                      //'entries' is  an object used to retrieve data including reference entries.\n                  })\n       * @example\n       * <caption> .includeReference with reference_field_uids and its children reference </caption>\n       * var Query = Stack.ContentType(contentTypes.source).Query();\n              Query\n                  .includeReference(['reference_field_uid', 'reference_field_uid.child_reference_field_uid'])\n                  .toJSON()\n                  .find()\n                  .then(function success(entries) {\n                      //'entries' is  an object used to retrieve data including reference entries.\n                  })\n       * @example\n       * <caption> .includeReference with reference_field_uids </caption>\n       * var Query = Stack.ContentType(contentTypes.source).Query();\n       Query\n          .includeReference('reference_field_uid')\n          .toJSON()\n          .find()\n          .then(function success(entries) {\n              //'entries' is  an object used to retrieve data including particular reference using reference_uid.\n          })\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"includeReference\",\n    value: function includeReference() {\n      for (var _len = arguments.length, val = new Array(_len), _key = 0; _key < _len; _key++) {\n        val[_key] = arguments[_key];\n      }\n      if (Array.isArray(val) || typeof val === 'string') {\n        if (arguments.length) {\n          for (var i = 0; i < arguments.length; i++) {\n            this._query.include = this._query.include || [];\n            this._query.include = this._query.include.concat(arguments[i]);\n          }\n        }\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].ENTRY_INVALID_ARGUMENT);\n      }\n    }\n\n    /**\n       * Sets the language code of which you want to retrieve data.\n       * @param {String} language_code - language code. e.g. 'en-us', 'ja-jp', etc.\n       * @memberOf Entry\n       * @example\n       * let data = Stack.ContentType(contentTypeUid).Entry(entryUid).language('ja-jp').fetch()\n       * data\n       *      .then(function(result) {\n       *           // 'result' is  an object used to retrieve data of ja-jp language.\n       *      }, function(error) {\n       *           // error function\n       *      })\n       *\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"language\",\n    value: function language(language_code) {\n      if (language_code && typeof language_code === 'string') {\n        this._query.locale = language_code;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].ENTRY_LANGUAGE_INVALID);\n      }\n    }\n\n    /**\n       * @method addQuery\n       * @memberOf Entry\n       * @description Adds query to Entry object\n       * @param {String} key - key of the query\n       * @param {String} value - value of the query\n       * @example Stack.ContentType(contentTypeUid).Entry(entry_uid).addQuery('include_schema',true)\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"addQuery\",\n    value: function addQuery(key, value) {\n      if (key && value && typeof key === 'string') {\n        this._query[key] = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].ENTRY_ADD_QUERY_INVALID);\n      }\n    }\n\n    /**\n       * @method includeEmbeddedItems\n       * @memberOf Entry\n       * @description Include Embedded Objects (Entries and Assets) along with entry/entries details.\n       * @example Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeEmbeddedItems().fetch()\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"includeEmbeddedItems\",\n    value: function includeEmbeddedItems() {\n      this._query.include_embedded_items = ['BASE'];\n      return this;\n    }\n\n    /**\n       * @method includeSchema\n       * @memberOf Entry\n       * @deprecated since version 3.3.0\n       * @description  Include schema of the current content type along with entry/entries details.\n       * @example Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeSchema().fetch()\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"includeSchema\",\n    value: function includeSchema() {\n      this._query.include_schema = true;\n      return this;\n    }\n\n    /**\n       * @method includeReferenceContentTypeUid\n       * @memberOf Entry\n       * @description  This method also includes the content type UIDs of the referenced entries returned in the response.\n       * @example Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeReferenceContentTypeUID().fetch()\n       * @example\n       * Query = Stack.ContentType(\"contentType_uid\").Entry(\"entry_uid\").includeReferenceContentTypeUID().fetch()\n       * Query\n       *      .toJSON()\n       *      .then(function (result) {\n       *          let value = result.get(field_uid)\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"includeReferenceContentTypeUID\",\n    value: function includeReferenceContentTypeUID() {\n      this._query.include_reference_content_type_uid = true;\n      return this;\n    }\n\n    /**\n       * @method includeFallback\n       * @memberOf Entry\n       * @description Include the fallback locale publish content, if specified locale content is not publish.\n       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeFallback().fetch()\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"includeFallback\",\n    value: function includeFallback() {\n      this._query.include_fallback = true;\n      return this;\n    }\n\n    /**\n       * @method includeBranch\n       * @memberOf Entry\n       * @description Include the Branch for publish content.\n       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeBranch().fetch()\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"includeBranch\",\n    value: function includeBranch() {\n      this._query.include_branch = true;\n      return this;\n    }\n\n    /**\n       * @method includeMetadata\n       * @memberOf Entry\n       * @description Include the metadata for getting metadata content for the entry.\n       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeMetadata().fetch()\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"includeMetadata\",\n    value: function includeMetadata() {\n      this._query.include_metadata = true;\n      return this;\n    }\n\n    /**\n       * @method includeContentType\n       * @memberOf Entry\n       * @description Include the details of the content type along with the entry/entries details.\n       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeContentType().fetch()\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"includeContentType\",\n    value: function includeContentType() {\n      this._query.include_content_type = true;\n      return this;\n    }\n\n    /**\n       * @method includeOwner\n       * @memberOf Entry\n       * @description Include the owner details along with the entry/entries details.\n       * @example stack.ContentType(contentType_uid).Entry(entry_uid).includeOwner().fetch()\n       * @returns {Entry}\n       * @deprecated The includeOwner function is deprecated.\n       * @instance\n       */\n  }, {\n    key: \"includeOwner\",\n    value: function includeOwner() {\n      console.warn(_messages[\"default\"].ENTRY_INCLUDE_OWNER_DEPRECATED);\n      this._query.include_owner = true;\n      return this;\n    }\n\n    /**\n       * @method toJSON\n       * @memberOf Entry\n       * @description Converts your response into plain JavasScript object.Supports both entry and asset queries.\n       * @example\n       * Query = Stack.ContentType(contentTypeUid).Entry(entryUid).fetch()\n       * Query\n       *      .toJSON()\n       *      .then(function (result) {\n       *          let value = result.get(field_uid)\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      this.tojson = true;\n      return this;\n    }\n\n    /**\n       * @method addParam\n       * @memberOf Entry\n       * @description Includes query parameters in your queries.\n       * @example var data = Stack.ContentType(contentTypeUid).Entry(entryUid).addParam('include_count', 'true').fetch()\n       *      data.then(function (result) {\n       *          // 'result' is an object which content the data including count in json object form\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"addParam\",\n    value: function addParam(key, value) {\n      if (key && value && typeof key === 'string' && typeof value === 'string') {\n        this._query[key] = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].ENTRY_ADD_PARAM_INVALID);\n      }\n    }\n\n    /**\n       * @method Variants\n       * @memberOf Entry\n       * @param {String} uid - uid of the variants entry\n       * @description An initializer is responsible for creating Variants Entry object\n       * @returns {Variants}\n       * @instance\n       */\n  }, {\n    key: \"variants\",\n    value: function variants(variant_headers) {\n      if (Array.isArray(variant_headers) && variant_headers.length > 0) {\n        this.headers['x-cs-variant-uid'] = variant_headers.join(',');\n      } else {\n        this.headers['x-cs-variant-uid'] = variant_headers;\n      }\n      return this;\n    }\n\n    /**\n       * @method fetch\n       * @memberOf Entry\n       * @description Fetches a particular entry based on the provided entry UID.\n       * @example\n       * Stack.ContentType(contentTypeUid).Entry(entryUid).toJSON().fetch()\n       *\n       * @example\n       * Stack.ContentType(contentTypeUid).Entry(entryUid).toJSON().fetch({\n       *\n       *      })\n       * @returns {promise}\n       * @instance\n       */\n  }, {\n    key: \"fetch\",\n    value: function fetch(fetchOptions) {\n      var host = this.config.host + ':' + this.config.port;\n      if (this.live_preview && this.live_preview.enable === true && this.live_preview.live_preview && this.live_preview.live_preview !== 'init') {\n        host = this.live_preview.host;\n      }\n      if (this.entry_uid) {\n        this.requestParams = {\n          method: 'POST',\n          headers: Utils.mergeDeep({}, this.headers),\n          url: this.config.protocol + '://' + host + '/' + this.config.version + this.config.urls.content_types + this.content_type_uid + this.config.urls.entries + this.entry_uid,\n          body: {\n            _method: 'GET',\n            query: this._query\n          }\n        };\n        var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);\n        return Utils.sendRequest(Utils.mergeDeep({}, this), options);\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].ENTRY_UID_REQUIRED);\n      }\n    }\n  }]);\n}();\n\n/***/ }),\n\n/***/ 94:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_20349__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.get = get;\nexports.getKeys = getKeys;\nexports.getStorage = getStorage;\nexports.set = set;\nvar _localstorage = _interopRequireDefault(__nested_webpack_require_20349__(880));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction get(key) {\n  var data = _localstorage[\"default\"].getItem(key);\n  try {\n    data = JSON.parse(data);\n  } catch (e) {\n    return data;\n  }\n  return data || null;\n}\nfunction set(key, data) {\n  try {\n    if (_typeof(data) === 'object') {\n      _localstorage[\"default\"].setItem(key, JSON.stringify(data));\n    } else {\n      _localstorage[\"default\"].setItem(key, data);\n    }\n  } catch (error) {}\n}\nfunction getStorage() {\n  return _localstorage[\"default\"] || null;\n}\nfunction getKeys() {\n  return _localstorage[\"default\"] ? Object.keys(_localstorage[\"default\"]) : [];\n}\n\n/***/ }),\n\n/***/ 174:\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n/**\n * Centralized error and informational messages for Contentstack JavaScript SDK\n * @module messages\n */\n\nvar MESSAGES = {\n  // Cache Provider Messages\n  CACHE_PROVIDER_MISSING: 'Missing cache provider. Provide a valid provider and try again.',\n  CACHE_POLICY_INVALID: 'Invalid cache policy. Provide a valid policy value and try again.',\n  // Stack Initialization Messages\n  STACK_INVALID_PARAMS_OBJECT: 'Invalid parameters. The specified API Key, Delivery Token, or Environment Name is invalid.',\n  STACK_INVALID_PARAMS_STRING: 'Invalid string parameters. Provide valid API Key, Delivery Token, and Environment Name.',\n  STACK_INVALID_PARAMS_GENERIC: 'Invalid parameters. Provide valid parameters to initialize the Contentstack javascript-SDK Stack.',\n  STACK_OBSOLETE_FUNCTION: \"WARNING! Obsolete function called. Function 'Contentstack.Stack(api_key, delivery_token, environment)' has been deprecated, please use 'Contentstack.Stack({api_key, delivery_token, environment, region, branch, fetchOptions})' function instead!\",\n  // Entry Messages\n  ENTRY_UID_REQUIRED: \"Entry UID required. Provide an entry UID. e.g. .Entry('entry_uid')\",\n  ENTRY_INCLUDE_OWNER_DEPRECATED: 'The includeOwner function is deprecated. This functionality is no longer supported. Please remove this method from your code.',\n  ENTRY_INVALID_ARGUMENT: 'Invalid argument. Argument should be a String or an Array.',\n  ENTRY_LANGUAGE_INVALID: 'Invalid language code. Argument should be a String.',\n  ENTRY_ADD_QUERY_INVALID: 'Invalid query parameters. First argument should be a String.',\n  ENTRY_ADD_PARAM_INVALID: 'Invalid parameters. Both key and value should be strings.',\n  // Query/Transform Messages (only/except)\n  TRANSFORM_INVALID_SINGLE_PARAM: 'Invalid parameters. Expected a string or an array of field names.',\n  TRANSFORM_INVALID_DOUBLE_PARAM: 'Invalid parameters. Expected first parameter as a string (reference field UID) and second parameter as a string or an array of field names.',\n  TRANSFORM_INVALID_PARAM_COUNT: 'Invalid parameters. Provide either one parameter (field name or array) or two parameters (reference field UID and field name or array).',\n  // Request/Error Messages\n  REQUEST_ERROR_OCCURRED: function REQUEST_ERROR_OCCURRED(error) {\n    return \"An error occurred: \".concat(error);\n  }\n};\nvar _default = exports[\"default\"] = MESSAGES;\n\n/***/ }),\n\n/***/ 185:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_24199__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = Request;\nvar Utils = _interopRequireWildcard(__nested_webpack_require_24199__(925));\nvar _http = _interopRequireDefault(__nested_webpack_require_24199__(940));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof WeakMap) var r = new WeakMap(),\n    n = new WeakMap();\n  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        \"default\": e\n      };\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);\n    return f;\n  })(e, t);\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n// JS SDK version\nvar version = '3.26.3';\nvar environment, api_key;\nfunction Request(stack, fetchOptions) {\n  var requestParams = stack.requestParams;\n  return new Promise(function (resolve, reject) {\n    var queryParams;\n    var params = new URLSearchParams();\n    var _serialize = function serialize(obj, prefix) {\n      if (_typeof(obj) === 'object' && obj.length !== undefined) {\n        for (var i = 0, _i = obj.length; i < _i; i++) {\n          params.append(prefix + '[]', obj[i]);\n        }\n      } else {\n        for (var p in obj) {\n          var k = prefix ? prefix + '[' + p + ']' : p;\n          var v = obj[p];\n          v !== null && _typeof(v) === 'object' && p !== 'query' ? _serialize(v, k) : params.append(k, p !== 'query' ? v : JSON.stringify(v));\n        }\n      }\n      return params.toString();\n    };\n\n    // setting headers\n    requestParams.headers['Content-Type'] = 'application/json; charset=UTF-8';\n    requestParams.headers['X-User-Agent'] = 'contentstack-delivery-javascript-nodejs/' + version;\n    if (requestParams.body && _typeof(requestParams.body) === 'object') {\n      delete requestParams.body._method;\n      if (_typeof(requestParams.body.query) === 'object' && Object.keys(requestParams.body.query).length === 0) delete requestParams.body.query;\n      queryParams = _serialize(requestParams.body);\n    }\n    return fetchRetry(stack, queryParams, fetchOptions, resolve, reject, fetchOptions.retryDelay, fetchOptions.retryLimit);\n  });\n}\nfunction wait(retryDelay) {\n  return new Promise(function (resolve) {\n    setTimeout(resolve, retryDelay);\n  });\n}\nfunction fetchRetry(stack, queryParams, fetchOptions, resolve, reject) {\n  var retryDelay = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 300;\n  var retryLimit = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 5;\n  var requestParams = stack.requestParams;\n  var url = requestParams.url + '?' + queryParams;\n  var headers = requestParams.headers;\n  var option = Utils.mergeDeep({\n    method: 'GET',\n    headers: headers,\n    timeout: 30000\n  }, fetchOptions);\n  function onError(error) {\n    if (retryLimit === 0) {\n      if (fetchOptions.debug) fetchOptions.logHandler('error', error);\n      reject(error);\n    } else {\n      var msDelay = retryDelay;\n      retryLimit = retryLimit - 1;\n      var retryCount = fetchOptions.retryLimit - retryLimit;\n      if (fetchOptions.retryDelayOptions) {\n        if (fetchOptions.retryDelayOptions.base) {\n          msDelay = fetchOptions.retryDelayOptions.base * retryCount;\n        } else if (fetchOptions.retryDelayOptions.customBackoff) {\n          msDelay = fetchOptions.retryDelayOptions.customBackoff(retryCount, error);\n        }\n      }\n      wait(msDelay).then(function () {\n        return fetchRetry(stack, queryParams, fetchOptions, resolve, reject, retryDelay, retryLimit);\n      })[\"catch\"](function () {\n        return fetchRetry(stack, queryParams, fetchOptions, resolve, reject, retryDelay, retryLimit);\n      });\n    }\n  }\n  if (fetchOptions.debug) fetchOptions.logHandler('info', {\n    url: url,\n    option: option\n  });\n  var request = {\n    url: url,\n    option: option\n  };\n  var plugins = stack.plugins;\n  if (plugins && plugins !== undefined) {\n    for (var index = 0; index < plugins.length; index++) {\n      if (typeof plugins[index].onRequest === 'function') {\n        request = plugins[index].onRequest(stack, request);\n      }\n    }\n  }\n  (0, _http[\"default\"])(request.url, request.option).then(function (response) {\n    if (fetchOptions.debug) fetchOptions.logHandler('info', response);\n    var data = response.json();\n    if (response.ok && response.status === 200) {\n      data.then(function (json) {\n        for (var _index = 0; _index < plugins.length && typeof plugins[_index].onResponse === 'function'; _index++) {\n          json = plugins[_index].onResponse(stack, request, response, json);\n        }\n        resolve(json);\n      });\n    } else {\n      var status = response.status,\n        statusText = response.statusText;\n      data.then(function (json) {\n        var error_message = json.error_message,\n          error_code = json.error_code,\n          errors = json.errors;\n        var errorDetails = {\n          error_message: error_message,\n          error_code: error_code,\n          errors: errors,\n          status: status,\n          statusText: statusText\n        };\n        if (fetchOptions.retryCondition && fetchOptions.retryCondition(response)) {\n          onError(errorDetails);\n        } else {\n          if (fetchOptions.debug) fetchOptions.logHandler('error', errorDetails);\n          reject(errorDetails);\n        }\n      })[\"catch\"](function () {\n        if (fetchOptions.debug) fetchOptions.logHandler('error', {\n          status: status,\n          statusText: statusText\n        });\n        reject({\n          status: status,\n          statusText: statusText\n        });\n      });\n    }\n  })[\"catch\"](function (error) {\n    if (fetchOptions.debug) fetchOptions.logHandler('error', error);\n    reject(error);\n  });\n}\n\n/***/ }),\n\n/***/ 209:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_30722__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar Utils = _interopRequireWildcard(__nested_webpack_require_30722__(925));\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof WeakMap) var r = new WeakMap(),\n    n = new WeakMap();\n  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        \"default\": e\n      };\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);\n    return f;\n  })(e, t);\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * @class Result\n * @summary Creates an instance of `Result`.\n * @description An initializer is responsible for creating Result object.\n * @param {Object} object - API result object\n * @example\n * blogEntry.then(function (result) {\n *      // success function\n * },function (error) {\n *      // error function\n * })\n * @example\n * assetQuery.then(function (result) {\n *      // success function\n * },function (error) {\n *      // error function\n * })\n * @returns {Result}\n * @instance\n */\nvar Result = exports[\"default\"] = /*#__PURE__*/function () {\n  function Result(object) {\n    _classCallCheck(this, Result);\n    if (object) {\n      this.object = function () {\n        return object;\n      };\n    }\n    return this;\n  }\n\n  /**\n     * @method toJSON\n     * @memberOf Result\n     * @description Converts `Result` to plain javascript object.\n     * @example\n     * blogEntry.then(function (result) {\n     *      result = result[0][0].toJSON()\n     * },function (error) {\n     *      // error function\n     * })\n     * @example\n     * assetQuery.then(function (result) {\n     *      result = result[0][0].toJSON()\n     * },function (error) {\n     *      // error function\n     * })\n     * @returns {object}\n     * @instance\n     */\n  return _createClass(Result, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.object() ? Utils.mergeDeep(JSON.parse(JSON.stringify({})), this.object()) : null;\n    }\n\n    /**\n       * @method get\n       * @memberOf Result\n       * @description Retrieve details of a field based on the UID provided\n       * @param field_uid uid of the field\n       * @example\n       * blogEntry.then(function (result) {\n       *      let value = result[0][0].get(field_uid)\n       * },function (error) {\n       *      // error function\n       * })\n       * @example\n       * assetQuery.then(function (result) {\n       *      let value = result[0][0].get(field_uid)\n       * },function (error) {\n       *      // error function\n       * })\n       * @returns {promise}\n       * @instance\n       */\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      if (this.object() && key) {\n        var fields = key.split('.');\n        var value = fields.reduce(function (prev, field) {\n          return prev[field];\n        }, this.object());\n        return value;\n      }\n    }\n\n    /**\n       * @method getDownloadUrl\n       * @memberOf Result\n       * @description Retrieves the download URL based on the disposition value.\n       * @param {String} string - disposition value\n       * @example\n       * assetQuery.then(function (result) {\n       *      let value = result[0][0].getDownloadUrl(disposition_value)\n       * },function (error) {\n       *      // error function\n       * })\n       * @returns {Object}\n       * @instance\n       */\n  }, {\n    key: \"getDownloadUrl\",\n    value: function getDownloadUrl(disposition) {\n      if (this.object()) {\n        var url = this.object().url ? this.object().url : null;\n        var _disposition = disposition && typeof disposition === 'string' ? disposition : 'attachment';\n        return url ? url + '?disposition=' + _disposition : null;\n      }\n    }\n  }]);\n}();\n\n/***/ }),\n\n/***/ 241:\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar config = {\n  protocol: \"https\",\n  host: \"cdn.contentstack.io\",\n  port: 443,\n  version: \"v3\",\n  urls: {\n    sync: \"/stacks/sync\",\n    content_types: \"/content_types/\",\n    entries: \"/entries/\",\n    assets: \"/assets/\",\n    environments: \"/environments/\",\n    taxonomies: \"/taxonomies/entries\"\n  },\n  live_preview: {\n    enable: false,\n    host: 'rest-preview.contentstack.com'\n  }\n};\nvar _default = exports[\"default\"] = config;\n\n/***/ }),\n\n/***/ 253:\n/***/ ((module) => {\n\nmodule.exports = __webpack_require__(/*! @contentstack/utils */ \"(ssr)/./node_modules/@contentstack/utils/dist/index.es.js\");\n\n/***/ }),\n\n/***/ 275:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_36883__) => {\n\n\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _query = _interopRequireDefault(__nested_webpack_require_36883__(318));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\n// Overrideing compare function to include level\nvar _extend = {\n  compare: function compare(type) {\n    return function (key, value, levels) {\n      if (key && value && typeof key === 'string' && typeof value !== 'undefined') {\n        this._query.query[key] = this._query.query.file_size || {};\n        this._query.query[key][type] = value;\n        if (levels && typeof levels === 'number') {\n          this._query.query[key].levels = levels;\n        }\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    };\n  }\n};\nvar Taxonomy = exports[\"default\"] = /*#__PURE__*/function (_Query) {\n  function Taxonomy() {\n    var _this;\n    _classCallCheck(this, Taxonomy);\n    _this = _callSuper(this, Taxonomy);\n    /**\n     * @method above\n     * @memberOf Query\n     * @description Get all entries for a specific taxonomy that match only the parent term(s) of a specified target term, excluding the target term itself. You can also specify a specific level.\n     * @param {String} key - uid of the taxonomy, specified as `taxonomies.<taxonomy_uid>`\n     * @param {*} value - uid of the term to be matched\n     * @example For taxonomy_uid = taxonomy1, and term_uid = term1\n     * let blogQuery = Stack().ContentType('example').Query();\n     *          let data = blogQuery.above(\"taxonomies.taxonomy1\", \"term1\").toJSON().find() // without levels\n     *          let data = blogQuery.above(\"taxonomies.taxonomy1\", \"term1\", 4).toJSON().find() // with levels\n     *          data.then(function (result) {\n     *          // result = the data which matches only the parent term(s) of the specified term, excluding the term itself\n     *       },function (error) {\n     *          // error function\n     *      })\n     * @returns {Query}\n     * @instance\n     */\n    _this.above = _extend.compare('$above');\n\n    /**\n     * @method equalAndAbove\n     * @memberOf Query\n     * @description Get all entries for a specific taxonomy that match a specific term and all its ancestor terms, requiring only the target term and a specified level.\n     * @param {String} key - uid of the taxonomy, specified as `taxonomies.<taxonomy_uid>`\n     * @param {*} value - uid of the term to be matched\n     * @example For taxonomy_uid = taxonomy1, and term_uid = term1\n     * let blogQuery = Stack().ContentType('example').Query();\n     *          let data = blogQuery.equalAndAbove(\"taxonomies.taxonomy1\", \"term1\").toJSON().find() // without levels\n     *          let data = blogQuery.equalAndAbove(\"taxonomies.taxonomy1\", \"term1\", 4).toJSON().find() // with levels\n     *          data.then(function (result) {\n     *          // result = the data which matches a specific term and all its ancestor terms\n     *       },function (error) {\n     *          // error function\n     *      })\n     * @returns {Query}\n     * @instance\n     */\n    _this.equalAndAbove = _extend.compare('$eq_above');\n\n    /**\n     * @method below\n     * @memberOf Query\n     * @description Get all entries for a specific taxonomy that match all of their descendant terms by specifying only the target term and a specific level.\n     * @param {String} key - uid of the taxonomy, specified as `taxonomies.<taxonomy_uid>`\n     * @param {*} value - uid of the term to be matched\n     * @example For taxonomy_uid = taxonomy1, and term_uid = term1\n     * let blogQuery = Stack().ContentType('example').Query();\n     *          let data = blogQuery.below(\"taxonomies.taxonomy1\", \"term1\").toJSON().find() // without levels\n     *          let data = blogQuery.below(\"taxonomies.taxonomy1\", \"term1\", 4).toJSON().find() // with levels\n     *          data.then(function (result) {\n     *          // result = the data which matches all of the descendant terms.\n     *       },function (error) {\n     *          // error function\n     *      })\n     * @returns {Query}\n     * @instance\n     */\n    _this.below = _extend.compare('$below');\n\n    /**\n     * @method equalAndBelow\n     * @memberOf Query\n     * @description Get all entries for a specific taxonomy that match a specific term and all its descendant terms, requiring only the target term and a specified level.\n     * @param {String} key - uid of the taxonomy, specified as `taxonomies.<taxonomy_uid>`\n     * @param {*} value - uid of the term to be matched\n     * @example For taxonomy_uid = taxonomy1, and term_uid = term1\n     * let blogQuery = Stack().ContentType('example').Query();\n     *          let data = blogQuery.equalAndBelow(\"taxonomies.taxonomy1\", \"term1\").toJSON().find() // without levels\n     *          let data = blogQuery.equalAndBelow(\"taxonomies.taxonomy1\", \"term1\", 4).toJSON().find() // with levels\n     *          data.then(function (result) {\n     *          // result = the data which matches a specific term and all its descendant terms.\n     *       },function (error) {\n     *          // error function\n     *      })\n     * @returns {Query}\n     * @instance\n     */\n    _this.equalAndBelow = _extend.compare('$eq_below');\n    return _this;\n  }\n  _inherits(Taxonomy, _Query);\n  return _createClass(Taxonomy);\n}(_query[\"default\"]);\n\n/***/ }),\n\n/***/ 285:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_45391__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _localstorage = _interopRequireDefault(__nested_webpack_require_45391__(641));\nvar _messages = _interopRequireDefault(__nested_webpack_require_45391__(174));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nvar CacheProvider = {};\nCacheProvider.providers = function (provider) {\n  if (provider) {\n    return _localstorage[\"default\"];\n  } else {\n    console.error(_messages[\"default\"].CACHE_PROVIDER_MISSING);\n  }\n};\nCacheProvider.policies = {\n  IGNORE_CACHE: -1,\n  ONLY_NETWORK: 0,\n  CACHE_ELSE_NETWORK: 1,\n  NETWORK_ELSE_CACHE: 2,\n  CACHE_THEN_NETWORK: 3\n};\nvar _default = exports[\"default\"] = CacheProvider;\n\n/***/ }),\n\n/***/ 318:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_46216__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar Utils = _interopRequireWildcard(__nested_webpack_require_46216__(925));\nvar _entry = _interopRequireDefault(__nested_webpack_require_46216__(42));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof WeakMap) var r = new WeakMap(),\n    n = new WeakMap();\n  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        \"default\": e\n      };\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);\n    return f;\n  })(e, t);\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == _typeof(e) || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nvar _extend = {\n  compare: function compare(type) {\n    return function (key, value) {\n      if (key && value && typeof key === 'string' && typeof value !== 'undefined') {\n        this._query.query[key] = this._query.query.file_size || {};\n        this._query.query[key][type] = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    };\n  },\n  contained: function contained(bool) {\n    var type = bool ? '$in' : '$nin';\n    return function (key, value) {\n      if (key && value && typeof key === 'string' && Array.isArray(value)) {\n        this._query.query[key] = this._query.query[key] || {};\n        this._query.query[key][type] = this._query.query[key][type] || [];\n        this._query.query[key][type] = this._query.query[key][type].concat(value);\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    };\n  },\n  exists: function exists(bool) {\n    return function (key) {\n      if (key && typeof key === 'string') {\n        this._query.query[key] = this._query.query[key] || {};\n        this._query.query[key].$exists = bool;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    };\n  },\n  logical: function logical(type) {\n    return function () {\n      var _query = [];\n      for (var i = 0, _i = arguments.length; i < _i; i++) {\n        if (arguments[i] instanceof Query && arguments[i]._query.query) {\n          _query.push(arguments[i]._query.query);\n        } else if (_typeof(arguments[i]) === 'object') {\n          _query.push(arguments[i]);\n        }\n      }\n      if (this._query.query[type]) {\n        this._query.query[type] = this._query.query[type].concat(_query);\n      } else {\n        this._query.query[type] = _query;\n      }\n      return this;\n    };\n  },\n  sort: function sort(type) {\n    return function (key) {\n      if (key && typeof key === 'string') {\n        this._query[type] = key;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Argument should be a string.');\n      }\n    };\n  },\n  pagination: function pagination(type) {\n    return function (value) {\n      if (typeof value === 'number') {\n        this._query[type] = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Argument should be a number.');\n      }\n    };\n  }\n};\n\n/**\n * @function getRequestUrl\n * @description Returns host url based on this.type\n * @param  {Object} this `this` variable from Query class\n * @return {string} returns the url that will be used to make API calls\n */\nfunction getRequestUrl(type, config, content_type_uid, baseURL) {\n  var url;\n  switch (type) {\n    case 'asset':\n      url = baseURL + config.urls.assets;\n      break;\n    case 'taxonomy':\n      url = baseURL + config.urls.taxonomies;\n      break;\n    case 'contentType':\n    default:\n      url = baseURL + config.urls.content_types + content_type_uid + config.urls.entries;\n      break;\n  }\n  return url;\n}\n\n/**\n * @class\n   Query\n * @description\n * An initializer is responsible for creating Query object.Provides support for all search queries\n * @example\n * <caption>Query instance creation.</caption>\n * let Query = Contentstack.Stack().ContentType('example').Query();\n * let assetQuery =  Contentstack.Stack().Assets().Query();\n * @returns {Query}\n */\nvar Query = exports[\"default\"] = /*#__PURE__*/function (_Entry) {\n  function Query() {\n    var _this;\n    _classCallCheck(this, Query);\n    _this = _callSuper(this, Query);\n    _this._query = _this._query || {};\n    _this._query.query = _this._query.query || {};\n    /**\n         * @method lessThan\n         * @memberOf Query\n         * @description Retrieves entries in which the value of a field is lesser than the provided value\n         * @param {String} key - uid of the field\n         * @param {*} value - Value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.lessThan('created_at','2015-06-22').find()\n         *          data.then(function (result) {\n         *          // result content the data who's 'created_at date' is less than '2015-06-22'\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.lessThan = _extend.compare('$lt');\n\n    /**\n         * @method lessThanOrEqualTo\n         * @memberOf Query\n         * @description Retrieves entries in which the value of a field is lesser than or equal to the provided value.\n         * @param {String} key - uid of the field\n         * @param {*} value - Value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.lessThanOrEqualTo('created_at','2015-06-22').find()\n         *          data.then(function (result) {\n         *          // result contain the data of entries where the 'created_at' date will be less than or equalto '2015-06-22'.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.lessThanOrEqualTo = _extend.compare('$lte');\n    /**\n         * @method greaterThan\n         * @memberOf Query\n         * @description Retrieves entries in which the value for a field is greater than the provided value.\n         * @param {String} key - uid of the field\n         * @param {*} value -  value used to match or compare\n         * @example\n         *          let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.greaterThan('created_at','2015-03-12').find()\n         *                     data.then(function(result) {\n         *                       // result contains the data of entries where the 'created_at' date will be greaterthan '2015-06-22'\n         *                     },function (error) {\n         *                       // error function\n         *                     })\n         * @returns {Query}\n         * @instance\n         */\n    _this.greaterThan = _extend.compare('$gt');\n\n    /**\n         * @method greaterThanOrEqualTo\n         * @memberOf Query\n         * @description Retrieves entries in which the value for a field is greater than or equal to the provided value.\n         * @param {String} key - uid of the field\n         * @param {*} value - Value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.greaterThanOrEqualTo('created_at','2015-03-12').find()\n         *          data.then(function(result) {\n         *          // result contains the data of entries where the 'created_at' date will be greaterThan or equalto '2015-06-22'\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.greaterThanOrEqualTo = _extend.compare('$gte');\n\n    /**\n         * @method notEqualTo\n         * @memberOf Query\n         * @description Retrieves entries in which the value for a field does not match the provided value.\n         * @param {String} key - uid of the field\n         * @param {*} value - Value used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.notEqualTo('title','Demo').find()\n         *          data.then(function(result) {\n         *            // result contains the list of entries where value of the title field will not be 'Demo'.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.notEqualTo = _extend.compare('$ne');\n\n    /**\n         * @method containedIn\n         * @memberOf Query\n         * @description Retrieve entries in which the value of a field matches with any of the provided array of values\n         * @param {String} key - uid of the field\n         * @param {*} value - Array of values that are to be used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.containedIn('title', ['Demo', 'Welcome']).find()\n         *          data.then(function(result) {\n         *          // result contains the list of entries where value of the title field will contain either 'Demo' or Welcome.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.containedIn = _extend.contained(true);\n\n    /**\n         * @method notContainedIn\n         * @memberOf Query\n         * @description Retrieve entries in which the value of a field does not match with any of the provided array of values.\n         * @param {String} key - uid of the field\n         * @param {Array} value - Array of values that are to be used to match or compare\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.notContainedIn('title', ['Demo', 'Welcome']).find()\n         *          data.then(function(result) {\n         *          // 'result' contains the list of entries where value of the title field should not be either \"Demo\" or Welcome\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.notContainedIn = _extend.contained(false);\n\n    /**\n         * @method exists\n         * @memberOf Query\n         * @description Retrieve entries if value of the field, mentioned in the condition, exists.\n         * @param {String} key - uid of the field\n         * @example blogQuery.exists('featured')\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.exists('featured').find()\n         *          data.then(function(result) {\n         *          // result contains the list of entries in which \"featured\" exists.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.exists = _extend.exists(true);\n\n    /**\n         * @method notExists\n         * @memberOf Query\n         * @description Retrieve entries if value of the field, mentioned in the condition, does not exists.\n         * @param {String} key - uid of the field\n         * @example blogQuery.notExists('featured')\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.notExists('featured').find()\n         *          data.then(function(result) {\n         *        // result is the list of non-existingfeatured\" data.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.notExists = _extend.exists(false);\n\n    /**\n         * @method ascending\n         * @memberOf Query\n         * @description Sort fetched entries in the ascending order with respect to a specific field.\n         * @param {String} key - field uid based on which the ordering will be done\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.ascending('created_at').find()\n         *          data.then(function(result) {\n         *           // result contains the list of entries which is sorted in ascending order on the basis of created_at.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.ascending = _extend.sort('asc');\n\n    /**\n         * @method descending\n         * @memberOf Query\n         * @description Sort fetched entries in the descending order with respect to a specific field\n         * @param {String} key - field uid based on which the ordering will be done.\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.descending('created_at').find()\n         *          data.then(function(result) {\n         *           // result contains the list of entries which is sorted in descending order on the basis of created_at.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.descending = _extend.sort('desc');\n\n    /**\n         * @method beforeUid\n         * @memberOf Query\n         * @description Sort fetched entries in the descending order with respect to a specific field\n         * @param {String} uid - field uid based on which the ordering will be done.\n         * @example blogQuery.beforeUid('uid')\n         * @returns {Query}\n         * @instance\n         */\n    _this.beforeUid = _extend.sort('before_uid');\n\n    /**\n         * @method afterUid\n         * @memberOf Query\n         * @description This method provides only the entries after the specified entry id.\n         * @param {String} uid - uid of the entry\n         * @example blogQuery.afterUid('uid')\n         * @returns {Query}\n         * @instance\n         */\n    _this.afterUid = _extend.sort('after_uid');\n\n    /**\n         * @method skip\n         * @memberOf Query\n         * @description Skips at specific number of entries.\n         * @param {Number} skip - number of entries to be skipped\n         * @example blogQuery.skip(5)\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.skip(5).find()\n         *          data.then(function(result) {\n         *          // result contains the list of data which is sorted in descending order on 'created_at' bases.\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.skip = _extend.pagination('skip');\n\n    /**\n         * @method limit\n         * @memberOf Query\n         * @description Returns a specific number of entries based on the set limit\n         * @param {Number} limit - maximum number of entries to be returned\n         * @example let blogQuery = Stack().ContentType('example').Query();\n         *          let data = blogQuery.limit(10).find()\n         *          data.then(function(result) {\n         *          // result contains the limited number of entries\n         *       },function (error) {\n         *          // error function\n         *      })\n         * @returns {Query}\n         * @instance\n         */\n    _this.limit = _extend.pagination('limit');\n\n    /**\n         * @method or\n         * @memberOf Query\n         * @description Retrieves entries that satisfy at least one of the given conditions\n         * @param {object} queries - array of Query objects or raw queries\n         * @example\n         * <caption> .or with Query instances</caption>\n         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').find()\n         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).find()\n         * blogQuery.or(Query1, Query2)\n         * @example\n         * <caption> .or with raw queries</caption>\n         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').getQuery()\n         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).getQuery()\n         * blogQuery.or(Query1, Query2)\n         * @returns {Query}\n         * @instance\n         */\n    _this.or = _extend.logical('$or');\n\n    /**\n         * @method and\n         * @memberOf Query\n         * @description Retrieve entries that satisfy all the provided conditions.\n         * @param {object} queries - array of query objects or raw queries.\n         * @example\n         * <caption> .and with Query instances</caption>\n         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo')\n         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10)\n         * blogQuery.and(Query1, Query2)\n         * @example\n         * <caption> .and with raw queries</caption>\n         * let Query1 = Stack.ContentType('blog').Query().where('title', 'Demo').getQuery()\n         * let Query2 = Stack.ContentType('blog').Query().lessThan('comments', 10).getQuery()\n         * blogQuery.and(Query1, Query2)\n         * @returns {Query}\n         * @instance\n         */\n    _this.and = _extend.logical('$and');\n    return _this;\n  }\n  _inherits(Query, _Entry);\n  return _createClass(Query, [{\n    key: \"equalTo\",\n    value: function equalTo(key, value) {\n      if (key && typeof key === 'string') {\n        this._query.query[key] = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    }\n\n    /**\n       * @method where\n       * @memberOf Query\n       * @description Retrieve entries in which a specific field satisfies the value provided\n       * @param {String} key - uid of the field\n       * @param {*} value - value used to match or compare\n       * @example let blogQuery = Stack().ContentType('example').Query();\n       *          let data = blogQuery.where('title','Demo').find()\n       *          data.then(function(result) {\n       *            // result contains the list of entries where value of title is equal to Demo.\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"where\",\n    value: function where(key, value) {\n      if (key && typeof key === 'string') {\n        this._query.query[key] = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    }\n\n    /**\n       * @method count\n       * @memberOf Query\n       * @description Returns the total number of entries\n       * @example blogQuery.count()\n       * @example let blogQuery = Stack().ContentType('example').Query();\n       *          let data = blogQuery.count().find()\n       *          data.then(function(result) {\n       *           // result contains the total count.\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"count\",\n    value: function count() {\n      var host = this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version;\n      var url = getRequestUrl(this.type, this.config, this.content_type_uid, host);\n      this._query.count = true;\n      this.requestParams = {\n        method: 'POST',\n        headers: Utils.mergeDeep({}, this.headers),\n        url: url,\n        body: {\n          _method: 'GET',\n          query: this._query\n        }\n      };\n      return this;\n    }\n\n    /**\n       * @method query\n       * @memberOf Query\n       * @description Retrieve entries based on raw queries\n       * @param {object} query - RAW (JSON) queries\n       * @returns {Query}\n       * @instance\n       * @example\n       * let blogQuery = Stack().ContentType('example').Query();\n       * let data = blogQuery.query({\"brand\": {\"$nin_query\": {\"title\": \"Apple Inc.\"}}}).find()\n       * data.then(function(result) {\n       *    // result contains the total count.\n       * },function (error) {\n       *    // error function\n       * })\n       */\n  }, {\n    key: \"query\",\n    value: function query(_query2) {\n      if (_typeof(_query2) === 'object') {\n        this._query.query = Utils.mergeDeep(this._query.query, _query2);\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters');\n      }\n    }\n\n    /**\n       * @method referenceIn\n       * @memberOf Query\n       * @description Retrieve entries that satisfy the query conditions made on referenced fields.\n       * @param {Query} query - RAW (JSON) queries\n       * @returns {Query}\n       * @instance\n       * @example\n       * <caption> referenceIn with Query instances</caption>\n       * let blogQuery = Stack().ContentType('example').Query();\n       * let Query = Stack.ContentType('blog').Query().where('title', 'Demo')\n       * let data = blogQuery.referenceIn(\"brand\", Query).find()\n       * data.then(function(result) {\n       *    // result contains the total count.\n       * },function (error) {\n       *    // error function\n       * })\n       *\n       * @example\n       * <caption> referenceIn with raw queries</caption>\n       * let blogQuery = Stack().ContentType('example').Query();\n       * let data = blogQuery.referenceIn(\"brand\", {'title': 'Demo'}).find()\n       * data.then(function(result) {\n       *    // result contains the total count.\n       * },function (error) {\n       *    // error function\n       * })\n       */\n  }, {\n    key: \"referenceIn\",\n    value: function referenceIn(key, query) {\n      var _query = {};\n      if (query instanceof Query && query._query.query) {\n        _query.$in_query = query._query.query;\n      } else if (_typeof(query) === 'object') {\n        _query.$in_query = query;\n      }\n      if (this._query.query[key]) {\n        this._query.query[key] = this._query.query[key].concat(_query);\n      } else {\n        this._query.query[key] = _query;\n      }\n      return this;\n    }\n\n    /**\n       * @method referenceNotIn\n       * @memberOf Query\n       * @description Retrieve entries that does not satisfy the query conditions made on referenced fields.\n       * @param {Query} query - RAW (JSON) queries\n       * @returns {Query}\n       * @instance\n       * @example\n       * <caption> referenceNotIn with Query instances</caption>\n       * let blogQuery = Stack().ContentType('example').Query();\n       * let data = blogQuery.referenceNotIn(\"brand\", {'title': 'Demo'}).find()\n       * data.then(function(result) {\n       *    // result contains the total count.\n       * },function (error) {\n       *    // error function\n       * })\n       *\n       * @example\n       * <caption> referenceNotIn with raw queries</caption>\n       * let blogQuery = Stack().ContentType('example').Query();\n       * let Query = Stack.ContentType('blog').Query().where('title', 'Demo')\n       * let data = blogQuery.referenceNotIn(\"brand\", Query).find()\n       * data.then(function(result) {\n       *    // result contains the total count.\n       * },function (error) {\n       *    // error function\n       * })\n       */\n  }, {\n    key: \"referenceNotIn\",\n    value: function referenceNotIn(key, query) {\n      var _query = {};\n      if (query instanceof Query && query._query.query) {\n        _query.$nin_query = query._query.query;\n      } else if (_typeof(query) === 'object') {\n        _query.$nin_query = query;\n      }\n      if (this._query.query[key]) {\n        this._query.query[key] = this._query.query[key].concat(_query);\n      } else {\n        this._query.query[key] = _query;\n      }\n      return this;\n    }\n\n    /**\n       * @method tags\n       * @memberOf Query\n       * @description Retrieves entries based on the provided tags\n       * @param {Array} values - tags\n       * @example let blogQuery = Stack().ContentType('example').Query();\n       *          let data = blogQuery.tags(['technology', 'business']).find()\n       *          data.then(function(result) {\n       *        // result contains list of entries which have tags \"technology\" and \"business\".\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"tags\",\n    value: function tags(values) {\n      if (Array.isArray(values)) {\n        this._query.tags = values;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters');\n      }\n    }\n\n    /**\n       * @method includeReferenceContentTypeUid\n       * @memberOf Query\n       * @description  This method also includes the content type UIDs of the referenced entries returned in the response.\n       * @example Stack.ContentType(\"contentType_uid\").Query().includeReferenceContentTypeUID().find()\n       * @example\n       * let blogQuery = Stack.ContentType(\"contentType_uid\").Query();\n       *          let data = blogQuery.includeReferenceContentTypeUID().find()\n       *          data.then(function(result) {\n       *         // result contains a list of entries in which content type UIDs is present.\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"includeReferenceContentTypeUID\",\n    value: function includeReferenceContentTypeUID() {\n      this._query.include_reference_content_type_uid = true;\n      return this;\n    }\n\n    /**\n       * @method includeCount\n       * @memberOf Query\n       * @description Includes the total number of entries returned in the response.\n       * @example blogQuery.includeCount()\n       * @example let blogQuery = Stack().ContentType('example').Query();\n       *          let data = blogQuery.includeCount().find()\n       *          data.then(function(result) {\n       *         // result contains a list of entries in which count of object is present at array[1] position.\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"includeCount\",\n    value: function includeCount() {\n      this._query.include_count = true;\n      return this;\n    }\n\n    /**\n       * @method addParam\n       * @description Includes query parameters in your queries.\n       * @memberOf Query\n       * @example var data = blogQuery.addParam('include_count', 'true').fetch()\n       *      data.then(function (result) {\n       *          // 'result' is an object which content the data including count in json object form\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"addParam\",\n    value: function addParam(key, value) {\n      if (key && value && typeof key === 'string' && typeof value === 'string') {\n        this._query[key] = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    }\n\n    /**\n       * @method getQuery\n       * @memberOf Query\n       * @description Returns the raw (JSON) query based on the filters applied on Query object.\n       * @example Stack.ContentType('contentType_uid').Query().where('title','Demo').getQuery().find()\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"getQuery\",\n    value: function getQuery() {\n      return this._query.query || {};\n    }\n\n    /**\n       * @method regex\n       * @memberOf Query\n       * @description Retrieve entries that match the provided regular expressions\n       * @param {String} key - uid of the field\n       * @param {*} value - value used to match or compare\n       * @param {String} [options] - match or compare value in entry\n       * @example\n       * <caption> .regex without options</caption>\n       * blogQuery.regex('title','^Demo')\n       * @example\n       * <caption> .regex with options</caption>\n       * blogQuery.regex('title','^Demo', 'i')\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"regex\",\n    value: function regex(key, value, options) {\n      if (key && value && typeof key === 'string' && typeof value === 'string') {\n        this._query.query[key] = {\n          $regex: value\n        };\n        if (options) this._query.query[key].$options = options;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    }\n\n    /**\n       * @method search\n       * @memberOf Query\n       * @deprecated since version 3.15.0\n       * @description Retrieve entries that have fields which match the provided search value.\n       * @param {string} value - value to search in entries\n       * @example blogQuery.search('Welcome to demo')\n       * @example let blogQuery = Stack().ContentType('example').Query();\n       *          let data = blogQuery.search('welcome to demo').find()\n       *          data.then(function(result) {\n       *         // result contains the object that possess the text \"welcome to demo\".\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"search\",\n    value: function search(value) {\n      if (value && typeof value === 'string') {\n        this._query.typeahead = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide valid parameters.');\n      }\n    }\n\n    /**\n       * @method find\n       * @memberOf Query\n       * @description Retrieves entries that satisfied the specified query\n       * @example let blogQuery = Stack().ContentType('example').Query().find();\n       *          blogQuery.then(function(result) {\n       *          // result contains the list of object.\n       *       },function (error) {\n       *          // error function\n       *      })\n       * blogQuery.find()\n       * @example\n       * let blogQuery = Stack.ContentType(contentTypeUid).Query().find({\n       *\n       *      });\n       * blogQuery.then(function(result) {\n       *          // result contains the list of object.\n       *       },function (error) {\n       *          // error function\n       *      })\n       * blogQuery.find()\n       * @returns {promise}\n       * @instance\n       */\n  }, {\n    key: \"find\",\n    value: function find(fetchOptions) {\n      var host = this.config.host + ':' + this.config.port;\n      if (this.type && this.type !== 'asset' && this.live_preview && this.live_preview.enable === true && this.live_preview.live_preview && this.live_preview.live_preview !== 'init') {\n        host = this.live_preview.host;\n      }\n      var baseURL = this.config.protocol + '://' + host + '/' + this.config.version;\n      var url = getRequestUrl(this.type, this.config, this.content_type_uid, baseURL);\n      this.requestParams = {\n        method: 'POST',\n        headers: Utils.mergeDeep({}, this.headers),\n        url: url,\n        body: {\n          _method: 'GET',\n          query: this._query\n        }\n      };\n      var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);\n      return Utils.sendRequest(Utils.mergeDeep({}, this), options);\n    }\n\n    /**\n       * @method Variants\n       * @memberOf Query\n       * @param {String} uid - uid of the variants entry\n       * @description An initializer is responsible for creating Variants Entry object\n       * @returns {Variants}\n       * @instance\n       */\n  }, {\n    key: \"variants\",\n    value: function variants(variant_headers) {\n      if (Array.isArray(variant_headers) && variant_headers.length > 0) {\n        this.headers['x-cs-variant-uid'] = variant_headers.join(',');\n      } else {\n        this.headers['x-cs-variant-uid'] = variant_headers;\n      }\n      return this;\n    }\n\n    /**\n       * @method findOne\n       * @memberOf Query\n       * @deprecated since version 3.3.0\n       * @description Retrieve a single entry from the result\n       * @example let blogQuery = Stack().ContentType('example').Query().findOne();\n       *          blogQuery.then(function(result) {\n       *          // result contains the single item object.\n       *       },function (error) {\n       *          // error function\n       *      })\n       * blogQuery.findOne()\n       * @returns {promise}\n       * @instance\n       */\n  }, {\n    key: \"findOne\",\n    value: function findOne() {\n      var host = this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version;\n      if (this.type && this.type !== 'asset' && this.live_preview && this.live_preview.enable === true && this.live_preview.live_preview && this.live_preview.live_preview !== 'init') {\n        host = this.config.protocol + '://' + this.live_preview.host + '/' + this.config.version;\n      }\n      var url = getRequestUrl(this.type, this.config, this.content_type_uid, host);\n      this.singleEntry = true;\n      this._query.limit = 1;\n      this.requestParams = {\n        method: 'POST',\n        headers: Utils.mergeDeep({}, this.headers),\n        url: url,\n        body: {\n          _method: 'GET',\n          query: this._query\n        }\n      };\n      var options = Utils.mergeDeep({}, this.fetchOptions);\n      return Utils.sendRequest(Utils.mergeDeep({}, this), options)[\"catch\"](function (error) {\n        // Add HTTP status code to the error object if it exists\n        if (error.status) {\n          return Promise.reject(_objectSpread(_objectSpread({}, error), {}, {\n            http_code: error.status,\n            // Adding the HTTP status code explicitly\n            http_message: error.statusText || 'An error occurred'\n          }));\n        }\n        return Promise.reject(error); // Fallback for other errors\n      });\n    }\n  }]);\n}(_entry[\"default\"]);\n\n/***/ }),\n\n/***/ 348:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_85037__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _config = _interopRequireDefault(__nested_webpack_require_85037__(241));\nvar Utils = _interopRequireWildcard(__nested_webpack_require_85037__(925));\nvar _entry = _interopRequireDefault(__nested_webpack_require_85037__(42));\nvar _assets = _interopRequireDefault(__nested_webpack_require_85037__(537));\nvar _query = _interopRequireDefault(__nested_webpack_require_85037__(318));\nvar _taxonomy = _interopRequireDefault(__nested_webpack_require_85037__(275));\nvar _request = _interopRequireDefault(__nested_webpack_require_85037__(185));\nvar _index = _interopRequireDefault(__nested_webpack_require_85037__(285));\nvar _messages = _interopRequireDefault(__nested_webpack_require_85037__(174));\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof WeakMap) var r = new WeakMap(),\n    n = new WeakMap();\n  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        \"default\": e\n      };\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);\n    return f;\n  })(e, t);\n}\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nvar errorRetry = [408, 429];\n\n/**\n     * @class\n        Stack\n     * @description Initialize an instance of Stack\n     * @param param - Stack configuration.\n     * @param param.api_key - Stack API Key.\n     * @param param.delivery_token - Stack Delivery token.\n     * @param param.environment - Stack Environment name.\n     * @param param.region - DB region for Stack.\n     * @param param.branch - Name of the branch you want to fetch data from\n     * @param param.live_preview - Live preview configuration.\n     * @param param.plugins - List of plugins objects.\n     * @param param.fetchOptions - Custom setting for the request.\n     * @param param.fetchOptions.debug - This will enable debug log. Default is false\n     * @param param.fetchOptions.timeout - Set timeout for the request.\n     * @param param.fetchOptions.retryLimit - The number of retries before failure. Default is 5\n     * @param param.fetchOptions.retryDelay - The number of ms to use for operation retries. Default is 300ms\n     * @param param.fetchOptions.retryCondition - A function to determine if the error can be retried. Default retry is on status codes 408, 429.\n     * @param param.fetchOptions.retryDelayOptions.base - The base number of milliseconds to use in the exponential backoff for operation retries.\n     * @param param.fetchOptions.retryDelayOptions.customBackoff - A custom function that accepts a retry count and error and returns the amount of time to delay in milliseconds.\n     * @param param.fetchOptions.logHandler - A function for logging of requests, responses and errors\n     *\n     * @example\n     * var Stack = Contentstack.Stack({\n     *      'api_key':'api_key',\n     *      'delivery_token':'delivery_token',\n     *      'environment':'environment_name',\n     *      'region': 'us',\n     *      'fetchOptions': {\n     *\n     *      }\n     * });\n     *\n     * @returns {Stack}\n     * @instance\n     */\nvar Stack = exports[\"default\"] = /*#__PURE__*/function () {\n  function Stack() {\n    var _this = this;\n    _classCallCheck(this, Stack);\n    this.fetchOptions = {\n      retryLimit: 5,\n      retryCondition: function retryCondition(error) {\n        if (errorRetry.includes(error.status)) {\n          return true;\n        }\n        return false;\n      },\n      debug: false,\n      logHandler: function logHandler(level, data) {\n        if (level === 'error' && data) {\n          console.error(\"Error: \".concat(data));\n        } else if (level === 'warning' && data) {\n          console.warn(\"Warning: \".concat(data));\n        } else if (level === 'info' && data) {\n          console.info(\"Info: \".concat(data));\n        }\n      }\n    };\n    this.config = JSON.parse(JSON.stringify(_config[\"default\"]));\n    this.plugins = [];\n    for (var _len = arguments.length, stack_arguments = new Array(_len), _key = 0; _key < _len; _key++) {\n      stack_arguments[_key] = arguments[_key];\n    }\n    if (stack_arguments[0].live_preview && stack_arguments[0].live_preview.enable === true && stack_arguments[0].live_preview.management_token !== null) {\n      if (stack_arguments[0].live_preview.management_token) {\n        this.config.live_preview.host = 'api.contentstack.io';\n      }\n    }\n    if (stack_arguments[0].region && stack_arguments[0].region !== undefined && stack_arguments[0].region !== 'us') {\n      this.config.host = stack_arguments[0].region + '-' + 'cdn.contentstack.com';\n      if (stack_arguments[0].live_preview && stack_arguments[0].live_preview.enable === true) {\n        if (stack_arguments[0].live_preview.management_token) {\n          this.config.live_preview.host = stack_arguments[0].region + '-' + 'api.contentstack.com';\n        } else {\n          this.config.live_preview.host = stack_arguments[0].region + '-' + 'rest-preview.contentstack.com';\n        }\n      }\n    }\n    if (stack_arguments[0].fetchOptions && stack_arguments[0].fetchOptions !== undefined) {\n      this.fetchOptions = Utils.mergeDeep(this.fetchOptions, stack_arguments[0].fetchOptions);\n    }\n    if (stack_arguments[0].plugins && stack_arguments[0].plugins !== undefined) {\n      stack_arguments[0].plugins.forEach(function (pluginObj) {\n        _this.plugins.push(pluginObj);\n      });\n    }\n    this.cachePolicy = _index[\"default\"].policies.IGNORE_CACHE;\n    this.provider = _index[\"default\"].providers('localstorage');\n    switch (stack_arguments.length) {\n      case 1:\n        if (_typeof(stack_arguments[0]) === 'object' && typeof stack_arguments[0].api_key === 'string' && typeof stack_arguments[0].delivery_token === 'string' && typeof stack_arguments[0].environment === 'string') {\n          this.headers = {\n            api_key: stack_arguments[0].api_key,\n            access_token: stack_arguments[0].delivery_token\n          };\n          if (_typeof(stack_arguments[0].live_preview) === 'object') {\n            this.live_preview = Utils.mergeDeep(this.config.live_preview, stack_arguments[0].live_preview);\n            this.setLivePreviewTimelinePreviewForClient();\n          }\n          if (typeof stack_arguments[0].branch === 'string' && stack_arguments[0].branch !== undefined) {\n            this.headers.branch = stack_arguments[0].branch;\n          }\n          if (_typeof(stack_arguments[0].early_access) === 'object' && Array.isArray(stack_arguments[0].early_access) && stack_arguments[0].early_access.length > 0) {\n            this.headers['x-header-ea'] = stack_arguments[0].early_access.join(',');\n          }\n          this.environment = stack_arguments[0].environment;\n          return this;\n        } else {\n          if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].STACK_INVALID_PARAMS_OBJECT);\n        }\n      case 3:\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('warning', _messages[\"default\"].STACK_OBSOLETE_FUNCTION);\n        if (typeof stack_arguments[0] === 'string' && typeof stack_arguments[1] === 'string' && typeof stack_arguments[2] === 'string') {\n          this.headers = {\n            api_key: stack_arguments[0],\n            access_token: stack_arguments[1]\n          };\n          this.environment = stack_arguments[2];\n          return this;\n        } else {\n          if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].STACK_INVALID_PARAMS_STRING);\n        }\n      case 4:\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('warning', _messages[\"default\"].STACK_OBSOLETE_FUNCTION);\n        if (typeof stack_arguments[0] === 'string' && typeof stack_arguments[1] === 'string' && typeof stack_arguments[2] === 'string') {\n          this.headers = {\n            api_key: stack_arguments[0],\n            access_token: stack_arguments[1]\n          };\n          this.environment = stack_arguments[2];\n        } else {\n          if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].STACK_INVALID_PARAMS_STRING);\n        }\n        if (stack_arguments[3]) {\n          if (typeof stack_arguments[3] === 'string' && stack_arguments[3] !== undefined && stack_arguments[3] !== 'us') {\n            this.config.host = stack_arguments[3] + '-' + 'cdn.contentstack.com';\n          } else if (_typeof(stack_arguments[3]) === 'object') {\n            this.fetchOptions = Utils.mergeDeep(this.fetchOptions, stack_arguments[3]);\n          }\n        }\n        return this;\n      case 5:\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('warning', _messages[\"default\"].STACK_OBSOLETE_FUNCTION);\n        if (typeof stack_arguments[0] === 'string' && typeof stack_arguments[1] === 'string' && typeof stack_arguments[2] === 'string') {\n          this.headers = {\n            api_key: stack_arguments[0],\n            access_token: stack_arguments[1]\n          };\n          this.environment = stack_arguments[2];\n        } else {\n          if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].STACK_INVALID_PARAMS_STRING);\n        }\n        if (stack_arguments[3]) {\n          if (typeof stack_arguments[3] === 'string' && stack_arguments[3] !== undefined && stack_arguments[3] !== 'us') {\n            this.config.host = stack_arguments[3] + '-' + 'cdn.contentstack.com';\n          } else if (_typeof(stack_arguments[3]) === 'object') {\n            this.fetchOptions = Utils.mergeDeep(this.fetchOptions, stack_arguments[3]);\n          }\n        }\n        if (stack_arguments[4] && _typeof(stack_arguments[4]) === 'object') {\n          this.fetchOptions = Utils.mergeDeep(this.fetchOptions, stack_arguments[4]);\n        }\n        return this;\n      default:\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].STACK_INVALID_PARAMS_GENERIC);\n    }\n  }\n\n  /**\n     * @method setPort\n     * @memberOf Stack\n     * @description Sets the port of the host\n     * @param {Number} port - Port Number\n     * @return {Stack}\n     * @instance\n     * */\n  return _createClass(Stack, [{\n    key: \"setPort\",\n    value: function setPort(port) {\n      if (typeof port === 'number') this.config.port = port;\n      return this;\n    }\n\n    /**\n       * @method setProtocol\n       * @memberOf Stack\n       * @description Sets the protocol for the host\n       * @param {String} protocol - http/https protocol\n       * @return {Stack}\n       * @instance\n       * */\n  }, {\n    key: \"setProtocol\",\n    value: function setProtocol(protocol) {\n      if (typeof protocol === 'string' && ~['https', 'http'].indexOf(protocol)) this.config.protocol = protocol;\n      return this;\n    }\n\n    /**\n       * @method setHost\n       * @memberOf Stack\n       * @description Sets the host of the API server\n       * @param {String} host - valid ip or host\n       * @return {Stack}\n       * @instance\n       * */\n  }, {\n    key: \"setHost\",\n    value: function setHost(host) {\n      if (typeof host === 'string' && host) this.config.host = host;\n      return this;\n    }\n\n    /**\n       * @method setCachePolicy\n       * @memberOf Stack\n       * @description Allows you to set cache policies\n       * @param {Constant} [key=ONLY_NETWORK] - Cache policy to be applied on Stack or Query.\n       * @example\n       * Stack.setCachePolicy(Contentstack.CachePolicy.IGNORE_CACHE)\n       * Stack.setCachePolicy(Contentstack.CachePolicy.ONLY_NETWORK)\n       * Stack.setCachePolicy(Contentstack.CachePolicy.CACHE_ELSE_NETWORK)\n       * Stack.setCachePolicy(Contentstack.CachePolicy.NETWORK_ELSE_CACHE)\n       * Stack.setCachePolicy(Contentstack.CachePolicy.CACHE_THEN_NETWORK)\n       * @returns {Stack}\n       * @instance\n       */\n  }, {\n    key: \"setCachePolicy\",\n    value: function setCachePolicy(policy) {\n      if (typeof policy === 'number' && policy >= -1 && policy < 4) {\n        if (!this._query) {\n          this.cachePolicy = policy;\n        } else {\n          this.queryCachePolicy = policy;\n        }\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', _messages[\"default\"].CACHE_POLICY_INVALID);\n      }\n      return this;\n    }\n  }, {\n    key: \"setLivePreviewTimelinePreviewForClient\",\n    value: function setLivePreviewTimelinePreviewForClient() {\n      if (Utils.isBrowser()) {\n        var params = new URL(document.location.toString()).searchParams;\n        if (params.has('live_preview')) {\n          this.live_preview.live_preview = params.get('live_preview');\n        }\n        if (params.has('release_id')) {\n          this.headers.release_id = params.get('release_id');\n        } else {\n          delete this.headers.release_id;\n        }\n        if (params.has('preview_timestamp')) {\n          this.headers.preview_timestamp = params.get('preview_timestamp');\n        } else {\n          delete this.headers.preview_timestamp;\n        }\n      }\n    }\n  }, {\n    key: \"livePreviewQuery\",\n    value: function livePreviewQuery(query) {\n      if (this.live_preview) {\n        this.live_preview.live_preview = query.live_preview || 'init';\n        this.live_preview.content_type_uid = query.content_type_uid;\n        this.live_preview.entry_uid = query.entry_uid;\n      }\n      if (query.hasOwnProperty('release_id')) {\n        this.headers.release_id = query.release_id;\n      } else {\n        delete this.headers.release_id;\n      }\n      if (query.hasOwnProperty('preview_timestamp')) {\n        this.headers.preview_timestamp = query.preview_timestamp;\n      } else {\n        delete this.headers.preview_timestamp;\n      }\n    }\n\n    /**\n       * @method setCacheProvider\n       * @memberOf Stack\n       * @description Allows you to set an object of the cache provider\n       * @example\n       * Stack\n       *      .setCacheProvider({\n       *          get: function (key, callback) {\n       *              // custom logic\n       *          },\n       *          set: function (key, value, callback) {\n       *              // custom logic\n       *          }\n       *      });\n       * @returns {Stack}\n       * @instance\n       */\n  }, {\n    key: \"setCacheProvider\",\n    value: function setCacheProvider(provider) {\n      if (provider && _typeof(provider) === 'object') {\n        this.provider = provider;\n      }\n      return this;\n    }\n\n    /**\n       * @method clearByQuery\n       * @memberOf Stack\n       * @description 'clearByQuery' function to clear the query from the cache.\n       * @example\n       * Stack.clearQuery(query, callback);\n       * @returns {Stack}\n       * @instance\n       */\n  }, {\n    key: \"clearByQuery\",\n    value: function clearByQuery() {\n      if (this.provider && typeof this.provider.clearByQuery === 'function') {\n        return this.provider.clearByQuery.apply(this.provider, arguments);\n      }\n    }\n\n    /**\n       * @method clearByContentType\n       * @memberOf Stack\n       * @description 'clearByContentType' function to clear the query from the cache by specified content type.\n       * @example\n       * Stack.clearByContentType(content_type_uid, callback);\n       * Stack.clearByContentType(content_type_uid, language_uid, callback);\n       * @returns {Stack}\n       * @instance\n       */\n  }, {\n    key: \"clearByContentType\",\n    value: function clearByContentType() {\n      if (this.provider && typeof this.provider.clearByContentType === 'function') {\n        return this.provider.clearByContentType.apply(this.provider, arguments);\n      }\n    }\n\n    /**\n       * @method clearAll\n       * @memberOf Stack\n       * @description 'clearAll' function to clear all the queries from cache.\n       * @example\n       * Stack.clearAll(callback);\n       * @returns {Stack}\n       * @instance\n       */\n  }, {\n    key: \"clearAll\",\n    value: function clearAll() {\n      if (this.provider && typeof this.provider.clearAll === 'function') {\n        return this.provider.clearAll.apply(this.provider, arguments);\n      }\n    }\n\n    /**\n       * @method getCacheProvider\n       * @memberOf Stack\n       * @description Returns the currently set object of 'CacheProvider'\n       * @example Stack.getCacheProvider();\n       * @returns {object}\n       * @instance\n       */\n  }, {\n    key: \"getCacheProvider\",\n    value: function getCacheProvider() {\n      return this.provider;\n    }\n\n    /**\n       * @method ContentType\n       * @memberOf Stack\n       * @description Set the content type of which you want to retrieve the entries\n       * @param {String} [content_type_uid] - uid of the existing content type\n       * @example\n       * let data = Stack.ContentType('blog').Query().toJSON().find()\n       *      data\n       *      .then(function(result) {\n       *           // 'result' content the list of entries of particular content type blog.\n       *      }, function(error) {\n       *           // error function\n       *      })\n       * @returns {Stack}\n       * @instance\n       */\n  }, {\n    key: \"ContentType\",\n    value: function ContentType(uid) {\n      if (uid && typeof uid === 'string') {\n        this.content_type_uid = uid;\n        this.type = 'contentType';\n      }\n      return this;\n    }\n\n    /**\n       * @method Taxonomies\n       * @memberof Stack\n       * @description A method to set base url to taxonomies endpoint\n       * @returns {Stack}\n       */\n  }, {\n    key: \"Taxonomies\",\n    value: function Taxonomies() {\n      this.type = 'taxonomy';\n      return Utils.merge(new _taxonomy[\"default\"](), this);\n    }\n\n    /**\n       * @method Entry\n       * @memberOf ContentType\n       * @param {String} uid - uid of the entry\n       * @description An initializer is responsible for creating Entry object\n       * @returns {Entry}\n       * @instance\n       */\n  }, {\n    key: \"Entry\",\n    value: function Entry(uid) {\n      var entry = new _entry[\"default\"]();\n      if (uid && typeof uid === 'string') {\n        entry.entry_uid = uid;\n      }\n      return Utils.merge(entry, this);\n    }\n\n    /**\n       * @method fetch\n       * @memberOf ContentType\n       * @description This method returns the complete information of a specific content type.\n       * @example\n       * let single_contenttype = Stack.ContentType(content_type_uid).fetch()\n       *    single_contenttype\n       *    .then(function(result) {\n       *      // 'result' is a single contentType information.\n       *     }).catch((error) => {\n       *        console.error(MESSAGES.REQUEST_ERROR_OCCURRED(error.message || error))\n       *  });\n       * @returns {promise}\n       * @instance\n       */\n  }, {\n    key: \"fetch\",\n    value: function fetch(fetchOptions) {\n      this.requestParams = {\n        method: 'POST',\n        headers: Utils.mergeDeep({}, this.headers),\n        plugins: this.plugins,\n        url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types + this.content_type_uid,\n        body: {\n          _method: 'GET',\n          environment: this.environment\n        }\n      };\n      var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);\n      return (0, _request[\"default\"])(this, options);\n    }\n\n    /**\n       * @method Assets\n       * @memberOf Stack\n       * @param {String} uid - uid of the asset\n       * @description Retrieves all assets of a stack by default. To retrieve a single asset, specify its UID.\n       * @example\n       * // Retrieves all assets\n       * let data = Stack.Assets().Query().toJSON().find()\n       *      data\n       *      .then(function(result) {\n       *          // All the asset with limit of 100\n       *          // Use skip and limit functions to paginate\n       *          // result will display all assets present in stack\n       *      }, function(error) {\n       *           // error function\n       *      })\n       *\n       * @example\n       * let data = Stack.Assets('asset_uid').toJSON().fetch()\n       *      data\n       *        .then(function(result) {\n       *           // result is a single asset object of specified uid\n       *      }, function(error) {\n       *           // error function\n       *      })\n       *\n       * @returns {Assets}\n       * @instance\n       */\n  }, {\n    key: \"Assets\",\n    value: function Assets(uid) {\n      this.type = 'asset';\n      if (uid && typeof uid === 'string') {\n        var asset = new _assets[\"default\"]();\n        asset.asset_uid = uid;\n        return Utils.merge(asset, this);\n      }\n      return this;\n    }\n\n    /**\n       * @method Query\n       * @memberOf Stack\n       * @description An initializer is responsible for creating Query object.Provides support for all search queries\n       * @returns {Query}\n       * @instance\n       */\n  }, {\n    key: \"Query\",\n    value: function Query() {\n      // Taxonomy is a class that extends Query class and adds 4 more helper methods that use levels.\n      // These 4 methods also work on contentType base url, hence Taxonomy instance is returned\n      // Taxonomy instance is Regular Query instance + 4 additional methods (below, eq_below, above, eq_above)\n      var query = this.type === 'contentType' ? new _taxonomy[\"default\"]() : new _query[\"default\"]();\n      return Utils.merge(query, this);\n    }\n\n    /**\n       * @method getLastActivities\n       * @memberOf Stack\n       * @description getLastActivities get all the ContentTypes whose last activity updated.\n       * @example Stack.getLastActivities()\n       * @example\n       * let data = Stack.getLastActivities().toJSON().fetch()\n       *      data\n       *      .then(function(result) {\n       *           // 'result' is list of contentTypes whose last activity updated.\n       *      }, function(error) {\n       *           // error function\n       *      })\n       * @returns {promise}\n       * @instance\n       */\n  }, {\n    key: \"getLastActivities\",\n    value: function getLastActivities() {\n      this.requestParams = {\n        method: 'POST',\n        headers: Utils.mergeDeep({}, this.headers),\n        url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types,\n        body: {\n          _method: 'GET',\n          only_last_activity: true,\n          environment: this.environment\n        }\n      };\n      return (0, _request[\"default\"])(this, this.fetchOptions);\n    }\n\n    /**\n       * @method getContentTypes\n       * @memberOf Stack\n       * @param {String} param - Query on contentTypes\n       * @description This method returns comprehensive information of all the content types of a particular stack in your account.\n       * @example\n       * let data = Stack.getContentTypes({\"include_global_field_schema\": true})\n       *      data\n       *      .then(function(result) {\n       *           // 'result' is list of contentTypes.\n       *      }, function(error) {\n       *           // error function\n       *      })\n       * @returns {promise}\n       * @instance\n       */\n  }, {\n    key: \"getContentTypes\",\n    value: function getContentTypes() {\n      var param = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.requestParams = {\n        method: 'POST',\n        headers: Utils.mergeDeep({}, this.headers),\n        url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.content_types,\n        body: {\n          _method: 'GET',\n          environment: this.environment\n        }\n      };\n      if (param) {\n        for (var key in param) {\n          this.requestParams.body[key] = param[key];\n        }\n      }\n      return (0, _request[\"default\"])(this, this.fetchOptions);\n    }\n\n    /**\n       * @method sync\n       * @memberOf Stack\n       * @description Syncs your Contentstack data with your app and ensures that the data is always up-to-date by providing delta updates\n       * @param {object} params - params is an object that supports locale, start_date, content_type_uid, and type queries.\n       * @example\n       * Stack.sync({'init': true})        // For initializing sync\n       * @example\n       * Stack.sync({'init': true, 'locale': 'en-us'})     //For initializing sync with entries of a specific locale\n       * @example\n       * Stack.sync({'init': true, 'start_date': '2018-10-22'})    //For initializing sync with entries published after a specific date\n       * @example\n       * Stack.sync({'init': true, 'content_type_uid': 'session'})   //For initializing sync with entries of a specific content type\n       * @example\n       * Stack.sync({'init': true, 'type': 'entry_published'})   //Use the type parameter to get a specific type of content.Supports 'asset_published', 'entry_published', 'asset_unpublished', 'entry_unpublished', 'asset_deleted', 'entry_deleted', 'content_type_deleted'.\n       * @example\n       * Stack.sync({'pagination_token': '<page_tkn>'})    // For fetching the next batch of entries using pagination token\n       * @example\n       * Stack.sync({'sync_token': '<sync_tkn>'})    // For performing subsequent sync after initial sync\n       * @returns {promise}\n       * @instance\n       */\n  }, {\n    key: \"sync\",\n    value: function sync(params, fetchOptions) {\n      if (params && _typeof(params) !== 'object') {\n        throw new Error('Invalid parameters: params must be an object.');\n      }\n      this._query = {};\n      if (params) {\n        for (var key in params) {\n          var value = params[key];\n          if (params.hasOwnProperty(key)) {\n            if (typeof value !== 'string' && typeof value !== 'number' && typeof value !== 'boolean' && !(value instanceof RegExp) && (_typeof(value) !== 'object' || value === null)) {\n              throw new Error(\"Invalid parameter value for key \\\"\".concat(key, \"\\\": must be a string, number, object, boolean, or RegExp.\"));\n            }\n            this._query[key] = params[key];\n          }\n        }\n      }\n      this.requestParams = {\n        method: 'POST',\n        headers: Utils.mergeDeep({}, this.headers),\n        url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.sync,\n        body: {\n          _method: 'GET',\n          query: this._query\n        }\n      };\n      var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);\n      return Utils.sendRequest(Utils.mergeDeep({}, this), options);\n    }\n\n    /**\n       * @method imageTransform\n       * @memberOf Stack\n       * @description Performs transformations on images of mentioned url based on transformation parameters\n       * @param {String} url - Image url on which transformations need to be applied.\n       * @param {String} params - Object with transformation parameters\n       * @example\n       * Stack.imageTransform(imageURL, {height: 100, width: 200, disable: \"upscale\"});\n       * @example\n       * Stack.imageTransform(imageURL, {crop: \"150,100\"});\n       * @example\n       * Stack.imageTransform(imageURL, {format: \"png\", crop: \"150,100\"});\n       * @returns {string} [Image url with transformation parameters.]\n       * @instance\n       */\n  }, {\n    key: \"imageTransform\",\n    value: function imageTransform(url, params) {\n      if (url && typeof url === 'string' && _typeof(params) === 'object' && params.length === undefined) {\n        var queryParams = [];\n        for (var operation in params) {\n          var encodedKey = encodeURIComponent(operation);\n          var encodedValue = encodeURIComponent(params[operation]);\n          queryParams.push(encodedKey + '=' + encodedValue);\n        }\n        url += url.indexOf('?') <= -1 ? '?' + queryParams.join('&') : '&' + queryParams.join('&');\n      }\n      return url;\n    }\n  }]);\n}();\n\n/***/ }),\n\n/***/ 537:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_114392__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar Utils = _interopRequireWildcard(__nested_webpack_require_114392__(925));\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof WeakMap) var r = new WeakMap(),\n    n = new WeakMap();\n  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        \"default\": e\n      };\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);\n    return f;\n  })(e, t);\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * @class\n  Assets\n* @summary Creates an instance of `Assets`.\n* @description Retrieves all assets of a stack by default. To retrieve a single asset, specify its UID.\n* @param {String} uid - uid of asset you want to retrieve\n* @example\n* let data = Stack.Assets('asset_uid').toJSON().fetch()\n*      data\n*      .then(function(result) {\n*           // result is a single asset object of specified uid\n*      }, function(error) {\n*           // error function\n*      })\n* @example\n* // Retrieves all assets*\n* let data = Stack.Assets().Query().toJSON().find()\n*      data\n*      .then(function(result) {\n*          // All the asset with limit of 100\n*          // Use skip and limit functions to paginate\n*          // result will display all assets present in stack\n*      }, function(error) {\n*           // error function\n*      })\n* @returns {Assets}\n* @instance\n*/\nvar Assets = exports[\"default\"] = /*#__PURE__*/function () {\n  function Assets() {\n    _classCallCheck(this, Assets);\n    this._query = {};\n    this.only = Utils.transform('only');\n    return this;\n  }\n\n  /**\n   * Converts your response into plain JavasScript object\n   * @memberOf Assets\n   * @example var Query = Stack.ContentType('blog').Query()\n    Query\n         .toJSON()\n         .find()\n         .then(function (result) {\n             // 'result' is an object which content the data in json object form\n          },function (error) {\n             // error function\n     })\n   * @returns {Assets}\n   * @instance\n   */\n  return _createClass(Assets, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      this.tojson = true;\n      return this;\n    }\n\n    /**\n     * Includes query parameters in your queries.\n     * @memberOf Assets\n     * @example var data = Stack.Assets(assetUid).addParam('include_dimension', 'true').toJSON().fetch()\n       *      data.then(function (result) {\n       *          // 'result' is an object which content the data including count in json object form\n       *       },function (error) {\n       *          // error function\n       *      })\n       * @returns {Assets}\n       * @instance\n     */\n  }, {\n    key: \"addParam\",\n    value: function addParam(key, value) {\n      if (key && typeof key === 'string' && value && typeof value === 'string') {\n        this._query[key] = value;\n        return this;\n      } else {\n        if (this.fetchOptions.debug) this.fetchOptions.logHandler('error', 'Kindly provide a valid parameters.');\n      }\n    }\n\n    /**\n       * @method includeFallback\n       * @memberOf Asset\n       * @description Include the fallback locale publish content, if specified locale content is not publish.\n       * @example stack.ContentType(contentType_uid).Assets(assetUid).includeFallback().fetch()\n       * @returns {Asset}\n       * @instance\n       */\n  }, {\n    key: \"includeFallback\",\n    value: function includeFallback() {\n      this._query.include_fallback = true;\n      return this;\n    }\n\n    /**\n       * @method includeMetadata\n       * @memberOf Asset\n       * @description Include the metadata for getting metadata content for the asset.\n       * @example stack.ContentType(contentType_uid).Assets(assetUid).includeMetadata().fetch()\n       * @returns {Asset}\n       * @instance\n       */\n  }, {\n    key: \"includeMetadata\",\n    value: function includeMetadata() {\n      this._query.include_metadata = true;\n      return this;\n    }\n    /**\n     * Fetches a particular asset based on the provided asset UID.\n     * @memberOf Assets\n     * @example\n     * Stack.Assets('assets_uid').toJSON().fetch()\n     * @example\n     * Stack.Assets('assets_uid').toJSON().fetch({\n     *\n     *      })\n     * @returns {promise}\n     * @instance\n     */\n  }, {\n    key: \"fetch\",\n    value: function fetch(fetchOptions) {\n      if (this.asset_uid) {\n        this.requestParams = {\n          method: 'POST',\n          headers: Utils.mergeDeep({}, this.headers),\n          url: this.config.protocol + '://' + this.config.host + ':' + this.config.port + '/' + this.config.version + this.config.urls.assets + this.asset_uid,\n          body: {\n            _method: 'GET',\n            query: this._query\n          }\n        };\n        var options = Utils.mergeDeep(this.fetchOptions, fetchOptions);\n        return Utils.sendRequest(Utils.mergeDeep({}, this), options);\n      } else {\n        if (fetchOptions.debug) fetchOptions.logHandler('error', \"Kindly provide an asset uid. e.g. .Assets('asset_uid')\");\n      }\n    }\n  }]);\n}();\n\n/***/ }),\n\n/***/ 641:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_121170__) => {\n\n\n\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar cache = _interopRequireWildcard(__nested_webpack_require_121170__(94));\nfunction _interopRequireWildcard(e, t) {\n  if (\"function\" == typeof WeakMap) var r = new WeakMap(),\n    n = new WeakMap();\n  return (_interopRequireWildcard = function _interopRequireWildcard(e, t) {\n    if (!t && e && e.__esModule) return e;\n    var o,\n      i,\n      f = {\n        __proto__: null,\n        \"default\": e\n      };\n    if (null === e || \"object\" != _typeof(e) && \"function\" != typeof e) return f;\n    if (o = t ? n : r) {\n      if (o.has(e)) return o.get(e);\n      o.set(e, f);\n    }\n    for (var _t in e) \"default\" !== _t && {}.hasOwnProperty.call(e, _t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, _t)) && (i.get || i.set) ? o(f, _t, i) : f[_t] = e[_t]);\n    return f;\n  })(e, t);\n}\nvar localStorage = {}; // eslint-disable-line\n\nlocalStorage.get = function (key, callback) {\n  try {\n    callback(null, cache.get(key));\n  } catch (e) {\n    callback(e);\n  }\n};\nlocalStorage.set = function (key, value, callback) {\n  try {\n    if (key && value) cache.set(key, value);\n    callback();\n  } catch (e) {\n    callback(e);\n  }\n};\nfunction clearValuesForKey(keyArray, append) {\n  if (!append && keyArray && keyArray.length) keyArray.push('');\n  var _key;\n  var keys = cache.getKeys();\n  var storage = cache.getStorage();\n  if (!keyArray || !keyArray.length) {\n    for (var i = 0, _i = keys.length; i < _i; i++) {\n      delete storage[keys[i]];\n    }\n  } else {\n    _key = keyArray.join('.');\n    for (var _i2 = 0, _i3 = keys.length; _i2 < _i3; _i2++) {\n      if (keys[_i2] && keys[_i2].indexOf(_key) === 0) delete storage[keys[_i2]];\n    }\n  }\n}\nlocalStorage.clearByContentType = function () {\n  try {\n    if (arguments.length === 2 || arguments.length === 3) {\n      var args = Array.prototype.slice.call(arguments);\n      var _callback = args.splice(-1, 1).pop();\n      var valueArray = [];\n      valueArray.push.apply(valueArray, args);\n      clearValuesForKey(valueArray);\n      _callback();\n    }\n  } catch (e) {\n    callback(e);\n  }\n};\nlocalStorage.clearByQuery = function (query, callback) {\n  try {\n    var keys = cache.getKeys();\n    var storage = cache.getStorage();\n    for (var i = 0, _i = keys.length; i < _i; i++) {\n      if (keys[i] && ~keys[i].indexOf(query)) delete storage[keys[i]];\n    }\n    callback();\n  } catch (e) {\n    callback(e);\n  }\n};\nlocalStorage.clearAll = function (callback) {\n  try {\n    clearValuesForKey();\n    callback();\n  } catch (e) {\n    callback(e);\n  }\n};\nvar _default = exports[\"default\"] = localStorage;\n\n/***/ }),\n\n/***/ 696:\n/***/ ((module) => {\n\nmodule.exports = __webpack_require__(/*! localStorage */ \"(ssr)/./node_modules/localStorage/lib/localStorage.js\");\n\n/***/ }),\n\n/***/ 697:\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar ContentstackRegion = {\n  EU: 'eu',\n  US: 'us',\n  AU: 'au',\n  AZURE_NA: 'azure-na',\n  AZURE_EU: 'azure-eu',\n  GCP_NA: 'gcp-na',\n  GCP_EU: 'gcp-eu'\n};\nvar _default = exports[\"default\"] = ContentstackRegion;\n\n/***/ }),\n\n/***/ 722:\n/***/ ((module) => {\n\nmodule.exports = __webpack_require__(/*! es6-promise */ \"(ssr)/./node_modules/es6-promise/dist/es6-promise.js\");\n\n/***/ }),\n\n/***/ 880:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_124796__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _localStorage = _interopRequireDefault(__nested_webpack_require_124796__(696));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nvar _default = exports[\"default\"] = _localStorage[\"default\"];\n\n/***/ }),\n\n/***/ 925:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_125214__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports._type = _type;\nexports.generateHash = generateHash;\nexports.getHash = getHash;\nexports.isBrowser = isBrowser;\nexports.merge = merge;\nexports.mergeDeep = mergeDeep;\nexports.parseQueryFromParams = parseQueryFromParams;\nexports.resultWrapper = resultWrapper;\nexports.sendRequest = sendRequest;\nexports.spreadResult = spreadResult;\nexports.transform = transform;\nvar _request = _interopRequireDefault(__nested_webpack_require_125214__(185));\nvar _result = _interopRequireDefault(__nested_webpack_require_125214__(209));\nvar _messages = _interopRequireDefault(__nested_webpack_require_125214__(174));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nfunction _regenerator() {\n  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/babel/babel/blob/main/packages/babel-helpers/LICENSE */var e,\n    t,\n    r = \"function\" == typeof Symbol ? Symbol : {},\n    n = r.iterator || \"@@iterator\",\n    o = r.toStringTag || \"@@toStringTag\";\n  function i(r, n, o, i) {\n    var c = n && n.prototype instanceof Generator ? n : Generator,\n      u = Object.create(c.prototype);\n    return _regeneratorDefine2(u, \"_invoke\", function (r, n, o) {\n      var i,\n        c,\n        u,\n        f = 0,\n        p = o || [],\n        y = !1,\n        G = {\n          p: 0,\n          n: 0,\n          v: e,\n          a: d,\n          f: d.bind(e, 4),\n          d: function d(t, r) {\n            return i = t, c = 0, u = e, G.n = r, a;\n          }\n        };\n      function d(r, n) {\n        for (c = r, u = n, t = 0; !y && f && !o && t < p.length; t++) {\n          var o,\n            i = p[t],\n            d = G.p,\n            l = i[2];\n          r > 3 ? (o = l === n) && (u = i[(c = i[4]) ? 5 : (c = 3, 3)], i[4] = i[5] = e) : i[0] <= d && ((o = r < 2 && d < i[1]) ? (c = 0, G.v = n, G.n = i[1]) : d < l && (o = r < 3 || i[0] > n || n > l) && (i[4] = r, i[5] = n, G.n = l, c = 0));\n        }\n        if (o || r > 1) return a;\n        throw y = !0, n;\n      }\n      return function (o, p, l) {\n        if (f > 1) throw TypeError(\"Generator is already running\");\n        for (y && 1 === p && d(p, l), c = p, u = l; (t = c < 2 ? e : u) || !y;) {\n          i || (c ? c < 3 ? (c > 1 && (G.n = -1), d(c, u)) : G.n = u : G.v = u);\n          try {\n            if (f = 2, i) {\n              if (c || (o = \"next\"), t = i[o]) {\n                if (!(t = t.call(i, u))) throw TypeError(\"iterator result is not an object\");\n                if (!t.done) return t;\n                u = t.value, c < 2 && (c = 0);\n              } else 1 === c && (t = i[\"return\"]) && t.call(i), c < 2 && (u = TypeError(\"The iterator does not provide a '\" + o + \"' method\"), c = 1);\n              i = e;\n            } else if ((t = (y = G.n < 0) ? u : r.call(n, G)) !== a) break;\n          } catch (t) {\n            i = e, c = 1, u = t;\n          } finally {\n            f = 1;\n          }\n        }\n        return {\n          value: t,\n          done: y\n        };\n      };\n    }(r, o, i), !0), u;\n  }\n  var a = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  t = Object.getPrototypeOf;\n  var c = [][n] ? t(t([][n]())) : (_regeneratorDefine2(t = {}, n, function () {\n      return this;\n    }), t),\n    u = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(c);\n  function f(e) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(e, GeneratorFunctionPrototype) : (e.__proto__ = GeneratorFunctionPrototype, _regeneratorDefine2(e, o, \"GeneratorFunction\")), e.prototype = Object.create(u), e;\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, _regeneratorDefine2(u, \"constructor\", GeneratorFunctionPrototype), _regeneratorDefine2(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction), GeneratorFunction.displayName = \"GeneratorFunction\", _regeneratorDefine2(GeneratorFunctionPrototype, o, \"GeneratorFunction\"), _regeneratorDefine2(u), _regeneratorDefine2(u, o, \"Generator\"), _regeneratorDefine2(u, n, function () {\n    return this;\n  }), _regeneratorDefine2(u, \"toString\", function () {\n    return \"[object Generator]\";\n  }), (_regenerator = function _regenerator() {\n    return {\n      w: i,\n      m: f\n    };\n  })();\n}\nfunction _regeneratorDefine2(e, r, n, t) {\n  var i = Object.defineProperty;\n  try {\n    i({}, \"\", {});\n  } catch (e) {\n    i = 0;\n  }\n  _regeneratorDefine2 = function _regeneratorDefine(e, r, n, t) {\n    if (r) i ? i(e, r, {\n      value: n,\n      enumerable: !t,\n      configurable: !t,\n      writable: !t\n    }) : e[r] = n;else {\n      var o = function o(r, n) {\n        _regeneratorDefine2(e, r, function (e) {\n          return this._invoke(r, n, e);\n        });\n      };\n      o(\"next\", 0), o(\"throw\", 1), o(\"return\", 2);\n    }\n  }, _regeneratorDefine2(e, r, n, t);\n}\nfunction asyncGeneratorStep(n, t, e, r, o, a, c) {\n  try {\n    var i = n[a](c),\n      u = i.value;\n  } catch (n) {\n    return void e(n);\n  }\n  i.done ? t(u) : Promise.resolve(u).then(r, o);\n}\nfunction _asyncToGenerator(n) {\n  return function () {\n    var t = this,\n      e = arguments;\n    return new Promise(function (r, o) {\n      var a = n.apply(t, e);\n      function _next(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"next\", n);\n      }\n      function _throw(n) {\n        asyncGeneratorStep(a, r, o, _next, _throw, \"throw\", n);\n      }\n      _next(void 0);\n    });\n  };\n}\nfunction _typeof2(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof2(o);\n}\n/**\n * @method addSpread\n * @description method to add the spread.\n */\n(function addSpread() {\n  if (Promise.prototype.spread) return;\n  Promise.prototype.spread = function (fn, errFunc) {\n    errFunc = errFunc || function (err) {};\n    return this.then(function (args) {\n      return fn.apply(fn, args);\n    })[\"catch\"](function (err) {\n      errFunc(err);\n    });\n  };\n})();\nfunction transform(type) {\n  return function () {\n    this._query[type] = this._query[type] || {};\n    switch (arguments.length) {\n      case 1:\n        if (Array.isArray(arguments[0]) || typeof arguments[0] === 'string') {\n          var query = this._query[type].BASE || [];\n          query = query.concat(arguments[0]);\n          this._query[type].BASE = query;\n          return this;\n        } else {\n          console.error(_messages[\"default\"].TRANSFORM_INVALID_SINGLE_PARAM);\n        }\n        break;\n      case 2:\n        if (typeof arguments[0] === 'string' && (Array.isArray(arguments[1]) || typeof arguments[1] === 'string')) {\n          var _query2 = this._query[type][arguments[0]] || [];\n          _query2 = _query2.concat(arguments[1]);\n          this._query[type][arguments[0]] = _query2;\n          return this;\n        } else {\n          console.error(_messages[\"default\"].TRANSFORM_INVALID_DOUBLE_PARAM);\n        }\n        break;\n      default:\n        console.error(_messages[\"default\"].TRANSFORM_INVALID_PARAM_COUNT);\n    }\n  };\n}\nfunction _type(val) {\n  var _typeof;\n  var __typeof = _typeof2(val);\n  if (__typeof === 'object') {\n    _typeof = __typeof;\n    if (Array.isArray(val)) {\n      __typeof = 'array';\n    }\n  } else {\n    _typeof = __typeof;\n  }\n  return __typeof;\n}\n\n// merge two objects\nfunction mergeDeep(destination, sourceVar) {\n  var self = this;\n  var _merge_recursive2 = function _merge_recursive(target, source) {\n    for (var key in source) {\n      if (self._type(source[key]) == 'object' && self._type(target[key]) == self._type(source[key])) {\n        _merge_recursive2(target[key], source[key]);\n      } else if (self._type(source[key]) == 'array' && self._type(target[key]) == self._type(source[key])) {\n        target[key] = target[key].concat(source[key]);\n      } else {\n        target[key] = source[key];\n      }\n    }\n  };\n  _merge_recursive2(destination, sourceVar);\n  return destination;\n}\n\n// merge two objects\nfunction merge(target, source) {\n  if (target && source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\n// return true if process is running in browser else false\nfunction isBrowser() {\n  return typeof window !== 'undefined';\n}\n\n// return the query from the params\nfunction parseQueryFromParams(queryObject, single, toJSON) {\n  if (queryObject && queryObject.requestParams) {\n    var _query = merge({}, queryObject.requestParams.body ? queryObject.requestParams.body.query || {} : {});\n    if (_query.environment_uid) {\n      delete _query.environment_uid;\n      _query.environment = queryObject.environment;\n    }\n    _query.environment = queryObject.environment;\n    return {\n      content_type_uid: queryObject.content_type_uid,\n      locale: _query.locale || 'en-us',\n      query: _query,\n      entry_uid: queryObject.entry_uid,\n      asset_uid: queryObject.asset_uid,\n      single: single || 'false',\n      toJSON: toJSON || 'false',\n      api_key: queryObject.requestParams.headers ? queryObject.requestParams.headers.api_key : ''\n    };\n  }\n}\n\n// return the hash value of the query\nfunction getHash(query) {\n  try {\n    var hashValue = generateHash(JSON.stringify(query));\n    var keyArray = [];\n    keyArray.push(query.content_type_uid);\n    keyArray.push(query.locale);\n    if (query.entry_uid) keyArray.push(query.entry_uid);\n    if (query.asset_uid) keyArray.push(query.asset_uid);\n    keyArray.push(hashValue);\n    return keyArray.join('.');\n  } catch (e) {}\n}\n\n// return the hash value of the string\nfunction generateHash(str) {\n  var hash = 0;\n  var i;\n  var chr;\n  var len;\n  if (str.length === 0) return hash;\n  for (i = 0, len = str.length; i < len; i++) {\n    chr = str.charCodeAt(i);\n    hash = (hash << 5) - hash + chr;\n    hash |= 0; // Convert to 32bit integer\n  }\n  return hash < -1 ? hash * -1 : hash;\n}\n\n// generate the Result object\nfunction resultWrapper(result) {\n  if (result && typeof result.entries !== 'undefined') {\n    if (result.entries && result.entries.length) {\n      for (var i = 0, _i = result.entries.length; i < _i; i++) {\n        result.entries[i] = (0, _result[\"default\"])(result.entries[i]);\n      }\n    } else {\n      result.entries = [];\n    }\n  } else if (result && result.assets && typeof result.assets !== 'undefined') {\n    if (result.assets && result.assets.length) {\n      for (var j = 0, _j = result.assets.length; j < _j; j++) {\n        result.assets[j] = (0, _result[\"default\"])(result.assets[j]);\n      }\n    } else {\n      result.assets = [];\n    }\n  } else if (result && typeof result.entry !== 'undefined') {\n    result.entry = (0, _result[\"default\"])(result.entry);\n  } else if (result && typeof result.asset !== 'undefined') {\n    result.asset = (0, _result[\"default\"])(result.asset);\n  } else if (result && typeof result.items !== 'undefined') {\n    result.items = (0, _result[\"default\"])(result.items).toJSON();\n  }\n  return result;\n}\n\n// spread the result object\nfunction spreadResult(result) {\n  var _results = [];\n  if (result && Object.keys(result).length) {\n    if (typeof result.entries !== 'undefined') {\n      _results.push(result.entries);\n      if (result.content_type) {\n        _results.schema = result.content_type;\n      }\n    }\n    if (typeof result.assets !== 'undefined') _results.push(result.assets);\n    if (typeof result.content_type !== 'undefined' || typeof result.schema !== 'undefined') _results.push(result.content_type || result.schema);\n    if (typeof result.count !== 'undefined') _results.push(result.count);\n    if (typeof result.entry !== 'undefined') {\n      _results = result.entry;\n      if (result.schema) {\n        _results.schema = result.schema;\n      }\n      if (result.content_type) {\n        _results.content_type = result.content_type;\n      }\n    }\n    if (typeof result.asset !== 'undefined') _results = result.asset;\n    if (typeof result.items !== 'undefined') _results.push(result);\n  }\n  return _results;\n}\nfunction sendRequest(queryObject, options) {\n  var env_uid = queryObject.environment_uid;\n  if (env_uid) {\n    queryObject._query.environment_uid = env_uid;\n  } else {\n    if (queryObject._query) {\n      queryObject._query.environment = queryObject.environment;\n    } else {\n      queryObject._query = {};\n      queryObject._query.environment = queryObject.environment;\n    }\n  }\n  var self = queryObject;\n  var cachePolicy = typeof self.queryCachePolicy !== 'undefined' ? self.queryCachePolicy : self.cachePolicy;\n  var tojson = typeof self.tojson !== 'undefined' ? self.tojson : false;\n  var isSingle = !!(self.entry_uid || self.singleEntry || self.asset_uid);\n  var hashQuery = getHash(parseQueryFromParams(self, isSingle, tojson));\n\n  /**\n    for new api v3\n    */\n  if (queryObject && queryObject.requestParams && queryObject.requestParams.body && queryObject.requestParams.body.query) {\n    var cloneQueryObj = JSON.parse(JSON.stringify(queryObject.requestParams.body.query));\n    if (_typeof2(cloneQueryObj) !== 'object') {\n      cloneQueryObj = JSON.parse(cloneQueryObj);\n    }\n    delete queryObject.requestParams.body.query;\n    queryObject.requestParams.body = merge(queryObject.requestParams.body, cloneQueryObj);\n    if (queryObject.live_preview && queryObject.live_preview.enable === true && queryObject.live_preview.live_preview && queryObject.live_preview.live_preview !== 'init') {\n      queryObject.requestParams.body = merge(queryObject.requestParams.body, {\n        live_preview: queryObject.live_preview.live_preview || 'init'\n      });\n      cachePolicy = 2; // network else cache\n      if (queryObject.requestParams.body.environment) {\n        delete queryObject.requestParams.body.environment;\n      }\n      if (queryObject.requestParams.headers.access_token) {\n        delete queryObject.requestParams.headers.access_token;\n      }\n      delete queryObject.requestParams.headers.authorization;\n      delete queryObject.requestParams.headers.preview_token;\n      if (queryObject.live_preview.preview_token) {\n        queryObject.requestParams.headers.preview_token = queryObject.live_preview.preview_token;\n        queryObject.requestParams.headers.live_preview = queryObject.live_preview.live_preview;\n      } else if (queryObject.live_preview.management_token) {\n        queryObject.requestParams.headers.authorization = queryObject.live_preview.management_token;\n      }\n    }\n  }\n  var getCacheCallback = function getCacheCallback(resolve, reject) {\n    return function (err, entries) {\n      try {\n        if (err) {\n          return reject(err); // Propagate the error to the parent promise\n        }\n        if (!tojson) entries = resultWrapper(entries);\n        resolve(spreadResult(entries)); // Propagate the result to the parent promise\n      } catch (e) {\n        reject(e); // Handle any synchronous errors\n      }\n    };\n  };\n  var callback = function callback(continueFlag, resolve, reject) {\n    if (continueFlag) {\n      (0, _request[\"default\"])(queryObject, options).then(function (data) {\n        try {\n          self.entry_uid = self.asset_uid = self.tojson = self.queryCachePolicy = undefined;\n          var entries = {};\n          var syncstack = {};\n          if (queryObject.singleEntry) {\n            queryObject.singleEntry = false;\n            if (data.schema) entries.schema = data.schema;\n            if (data.content_type) {\n              entries.content_type = data.content_type;\n              delete entries.schema;\n            }\n            if (data.entries && data.entries.length) {\n              entries.entry = data.entries[0];\n            } else if (data.assets && data.assets.length) {\n              entries.assets = data.assets[0];\n            } else {\n              if (cachePolicy === 2 && self.provider !== null) {\n                self.provider.get(hashQuery, function (err, _data) {\n                  if (err || !_data || _data.entries.length === 0 && _data.assets.length === 0) {\n                    return reject({\n                      error_code: 141,\n                      error_message: 'The requested entry doesn\\'t exist.'\n                    });\n                  }\n                  getCacheCallback(resolve, reject)(err, _data);\n                });\n                return;\n              } else {\n                return reject({\n                  error_code: 141,\n                  error_message: 'The requested entry doesn\\'t exist.'\n                });\n              }\n            }\n          } else if (data.items) {\n            syncstack = {\n              items: data.items,\n              pagination_token: data.pagination_token,\n              sync_token: data.sync_token,\n              total_count: data.total_count\n            };\n          } else {\n            entries = data;\n          }\n          if (cachePolicy !== -1 && self.provider !== null) {\n            self.provider.set(hashQuery, entries, function (err) {\n              try {\n                if (err) reject(err);\n                if (!tojson) entries = resultWrapper(entries);\n                return resolve(spreadResult(entries));\n              } catch (e) {\n                return reject(e);\n              }\n            });\n            return resolve(spreadResult(entries));\n          }\n          if (Object.keys(syncstack).length) {\n            return resolve(syncstack);\n          }\n          if (!tojson) {\n            entries = resultWrapper(entries);\n          }\n          return resolve(spreadResult(entries));\n        } catch (e) {\n          return reject({\n            message: e.message\n          });\n        }\n      })[\"catch\"](function (error) {\n        if (error) {\n          reject(error);\n        } else if (cachePolicy === 2 && self.provider !== null) {\n          self.provider.get(hashQuery, getCacheCallback(resolve, reject));\n        }\n      });\n    }\n  };\n  switch (cachePolicy) {\n    case 1:\n      return new Promise(/*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee2(resolve, reject) {\n          return _regenerator().w(function (_context2) {\n            while (1) switch (_context2.n) {\n              case 0:\n                if (!(self.provider !== null)) {\n                  _context2.n = 2;\n                  break;\n                }\n                _context2.n = 1;\n                return self.provider.get(hashQuery, /*#__PURE__*/function () {\n                  var _ref2 = _asyncToGenerator(/*#__PURE__*/_regenerator().m(function _callee(err, _data) {\n                    var _t;\n                    return _regenerator().w(function (_context) {\n                      while (1) switch (_context.p = _context.n) {\n                        case 0:\n                          _context.p = 0;\n                          if (!(err || !_data)) {\n                            _context.n = 1;\n                            break;\n                          }\n                          callback(true, resolve, reject);\n                          _context.n = 2;\n                          break;\n                        case 1:\n                          if (!tojson) {\n                            _data = resultWrapper(_data);\n                          }\n                          return _context.a(2, resolve(spreadResult(_data)));\n                        case 2:\n                          _context.n = 4;\n                          break;\n                        case 3:\n                          _context.p = 3;\n                          _t = _context.v;\n                          return _context.a(2, reject(_t));\n                        case 4:\n                          return _context.a(2);\n                      }\n                    }, _callee, null, [[0, 3]]);\n                  }));\n                  return function (_x3, _x4) {\n                    return _ref2.apply(this, arguments);\n                  };\n                }());\n              case 1:\n                _context2.n = 3;\n                break;\n              case 2:\n                callback(true, resolve, reject);\n              case 3:\n                return _context2.a(2);\n            }\n          }, _callee2);\n        }));\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    case 2:\n    case 0:\n    case undefined:\n    case -1:\n      return new Promise(function (resolve, reject) {\n        callback(true, resolve, reject);\n      });\n  }\n  if (cachePolicy === 3) {\n    var promise = new Promise(function (resolve, reject) {\n      if (self.provider !== null) {\n        self.provider.get(hashQuery, function (err, _data) {\n          try {\n            if (err || !_data) {\n              reject(err);\n            } else {\n              if (!tojson) {\n                _data = resultWrapper(_data);\n              }\n              resolve(spreadResult(_data));\n            }\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }\n    });\n    return promise.then(function () {\n      return new Promise(function (resolve, reject) {\n        callback(true, resolve, reject);\n      });\n    })[\"catch\"](function (error) {\n      return new Promise(function (resolve, reject) {\n        callback(true, resolve, reject);\n      });\n    });\n  }\n}\n\n/***/ }),\n\n/***/ 940:\n/***/ ((__unused_webpack_module, exports, __nested_webpack_require_146616__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\nvar _es6Promise = _interopRequireDefault(__nested_webpack_require_146616__(722));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\n_es6Promise[\"default\"].polyfill();\nvar _default = exports[\"default\"] = fetch; // fetch API available in Node.js 18 and later\n\n/***/ }),\n\n/***/ 949:\n/***/ ((module, __unused_webpack_exports, __nested_webpack_require_147095__) => {\n\n\n\nvar _stack = _interopRequireDefault(__nested_webpack_require_147095__(348));\nvar _index = _interopRequireDefault(__nested_webpack_require_147095__(285));\nvar _contentstackregion = _interopRequireDefault(__nested_webpack_require_147095__(697));\nfunction _interopRequireDefault(e) {\n  return e && e.__esModule ? e : {\n    \"default\": e\n  };\n}\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\nfunction _createForOfIteratorHelper(r, e) {\n  var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (!t) {\n    if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) {\n      t && (r = t);\n      var _n = 0,\n        F = function F() {};\n      return {\n        s: F,\n        n: function n() {\n          return _n >= r.length ? {\n            done: !0\n          } : {\n            done: !1,\n            value: r[_n++]\n          };\n        },\n        e: function e(r) {\n          throw r;\n        },\n        f: F\n      };\n    }\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n  var o,\n    a = !0,\n    u = !1;\n  return {\n    s: function s() {\n      t = t.call(r);\n    },\n    n: function n() {\n      var r = t.next();\n      return a = r.done, r;\n    },\n    e: function e(r) {\n      u = !0, o = r;\n    },\n    f: function f() {\n      try {\n        a || null == t[\"return\"] || t[\"return\"]();\n      } finally {\n        if (u) throw o;\n      }\n    }\n  };\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction _construct(t, e, r) {\n  if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);\n  var o = [null];\n  o.push.apply(o, e);\n  var p = new (t.bind.apply(t, o))();\n  return r && _setPrototypeOf(p, r.prototype), p;\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {\n    return !!t;\n  })();\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == _typeof(i) ? i : i + \"\";\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != _typeof(t) || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != _typeof(i)) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n/**\n * @class Contentstack\n * @description Creates an instance of `Contentstack`.\n * @instance\n */\nvar Contentstack = /*#__PURE__*/function () {\n  function Contentstack() {\n    _classCallCheck(this, Contentstack);\n    /**\n    * @memberOf Contentstack\n    * @description CachePolicy contains different cache policies constants.\n    * @example\n    * Contentstack.CachePolicy.IGNORE_CACHE\n    * Contentstack.CachePolicy.ONLY_NETWORK\n    * Contentstack.CachePolicy.CACHE_ELSE_NETWORK\n    * Contentstack.CachePolicy.NETWORK_ELSE_CACHE\n    * Contentstack.CachePolicy.CACHE_THEN_NETWORK\n    */\n    this.CachePolicy = _index[\"default\"].policies;\n    this.Region = _contentstackregion[\"default\"];\n    this.Utils = __nested_webpack_require_147095__(253);\n  }\n\n  /**\n  * @memberOf Contentstack\n  */\n  return _createClass(Contentstack, [{\n    key: \"Stack\",\n    value: function Stack() {\n      for (var _len = arguments.length, stack_arguments = new Array(_len), _key = 0; _key < _len; _key++) {\n        stack_arguments[_key] = arguments[_key];\n      }\n      return _construct(_stack[\"default\"], stack_arguments);\n    }\n  }, {\n    key: \"updateAssetURL\",\n    value: function updateAssetURL(entry) {\n      // check if entry consist of _embedded_items object\n      if (entry._embedded_items == undefined) {\n        throw new Error('_embedded_items not present in entry. Call includeEmbeddedItems() before fetching entry.');\n      }\n\n      // Iterate through each object in _embedded_items and update the asset link\n      var _loop = function _loop(key) {\n        var embedded_item = entry._embedded_items[key];\n        if (Array.isArray(embedded_item)) {\n          embedded_item.forEach(function (item) {\n            if (item._content_type_uid == 'sys_assets' && item.filename) {\n              var correspondingAsset;\n              var _x = function x(children) {\n                for (var i = 0; i < children.length; i++) {\n                  if (children[i].children && children[i].children.length) {\n                    _x(children[i].children);\n                  }\n                  if (children[i].attrs && children[i].attrs['asset-uid'] === item.uid) {\n                    correspondingAsset = children[i].attrs;\n                    return;\n                  }\n                }\n              };\n              var _entry = _objectSpread({}, entry);\n              var keys = key.split('.');\n              var unsafeKeys = new Set(['__proto__', 'constructor', 'prototype']);\n              var _iterator = _createForOfIteratorHelper(keys),\n                _step;\n              try {\n                for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                  var k = _step.value;\n                  // Ensure key is safe before accessing it\n                  if (unsafeKeys.has(k)) continue;\n                  if (_entry && _typeof(_entry) === 'object' && _entry !== null && Object.prototype.hasOwnProperty.call(_entry, k)) {\n                    var newEntry = _entry[k];\n                    if (_typeof(newEntry) === 'object' && newEntry !== null) {\n                      _entry = newEntry;\n                    }\n                  } else if (Array.isArray(_entry)) {\n                    var _iterator2 = _createForOfIteratorHelper(_entry),\n                      _step2;\n                    try {\n                      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                        var block = _step2.value;\n                        if (block && _typeof(block) === 'object' && Object.prototype.hasOwnProperty.call(block, k)) {\n                          _entry = block[k];\n                        }\n                      }\n                    } catch (err) {\n                      _iterator2.e(err);\n                    } finally {\n                      _iterator2.f();\n                    }\n                  }\n                }\n              } catch (err) {\n                _iterator.e(err);\n              } finally {\n                _iterator.f();\n              }\n              if (_entry.children) _x(_entry.children);\n              if (correspondingAsset) {\n                correspondingAsset.href = item.url;\n              }\n            }\n          });\n        }\n      };\n      for (var key in entry._embedded_items) {\n        _loop(key);\n      }\n    }\n  }]);\n}();\nmodule.exports = new Contentstack();\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_156635__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_156635__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module is referenced by other modules so it can't be inlined\n/******/ \tvar __nested_webpack_exports__ = __nested_webpack_require_156635__(949);\n/******/ \tmodule.exports = __nested_webpack_exports__;\n/******/ \t\n/******/ })()\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY29udGVudHN0YWNrL2Rpc3Qvbm9kZS9jb250ZW50c3RhY2suanMiLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsOEJBQW1COzs7O0FBSTdEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxvQ0FBb0MsOEJBQW1CO0FBQ3ZELHVDQUF1Qyw4QkFBbUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxRQUFRO0FBQ2xCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQSxtQkFBbUIsT0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGVBQWU7QUFDZixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGVBQWU7QUFDZixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyw4QkFBOEI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsZ0NBQWdDO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7QUFDRDs7QUFFQSxPQUFPOztBQUVQLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlDQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxpQ0FBbUI7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDBCQUFtQixHQUFHLGlDQUFtQjtBQUN2RCwyQkFBMkIsMEJBQW1CO0FBQzlDO0FBQ0EsVUFBVTtBQUNWIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhY2stYWNhZGVteS8uL25vZGVfbW9kdWxlcy9jb250ZW50c3RhY2svZGlzdC9ub2RlL2NvbnRlbnRzdGFjay5qcz84YzQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKHtcblxuLyoqKi8gNDI6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oOTI1KSk7XG52YXIgX21lc3NhZ2VzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NCkpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7XG4gIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgXCJkZWZhdWx0XCI6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgV2Vha01hcCkgdmFyIHIgPSBuZXcgV2Vha01hcCgpLFxuICAgIG4gPSBuZXcgV2Vha01hcCgpO1xuICByZXR1cm4gKF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkID0gZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkge1xuICAgIGlmICghdCAmJiBlICYmIGUuX19lc01vZHVsZSkgcmV0dXJuIGU7XG4gICAgdmFyIG8sXG4gICAgICBpLFxuICAgICAgZiA9IHtcbiAgICAgICAgX19wcm90b19fOiBudWxsLFxuICAgICAgICBcImRlZmF1bHRcIjogZVxuICAgICAgfTtcbiAgICBpZiAobnVsbCA9PT0gZSB8fCBcIm9iamVjdFwiICE9IF90eXBlb2YoZSkgJiYgXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlKSByZXR1cm4gZjtcbiAgICBpZiAobyA9IHQgPyBuIDogcikge1xuICAgICAgaWYgKG8uaGFzKGUpKSByZXR1cm4gby5nZXQoZSk7XG4gICAgICBvLnNldChlLCBmKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX3QgaW4gZSkgXCJkZWZhdWx0XCIgIT09IF90ICYmIHt9Lmhhc093blByb3BlcnR5LmNhbGwoZSwgX3QpICYmICgoaSA9IChvID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KSAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIF90KSkgJiYgKGkuZ2V0IHx8IGkuc2V0KSA/IG8oZiwgX3QsIGkpIDogZltfdF0gPSBlW190XSk7XG4gICAgcmV0dXJuIGY7XG4gIH0pKGUsIHQpO1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuLyoqXG4gKiBAY2xhc3NcbiAgRW50cnlcbiogQHN1bW1hcnkgQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgRW50cnlgLlxuKiBAZGVzY3JpcHRpb24gQW4gaW5pdGlhbGl6ZXIgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIEVudHJ5IG9iamVjdC5cbiogQHBhcmFtIHtTdHJpbmd9IHVpZCAtIHVpZCBvZiB0aGUgZW50cnlcbiogQGV4YW1wbGVcbiogbGV0IEVudHJ5ID0gU3RhY2suQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5FbnRyeSgnZW50cnlfdWlkJyk7XG4qIEByZXR1cm5zIHtFbnRyeX1cbiogQGluc3RhbmNlXG4qL1xudmFyIEVudHJ5ID0gZXhwb3J0c1tcImRlZmF1bHRcIl0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbnRyeSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW50cnkpO1xuICAgIHRoaXMuX3F1ZXJ5ID0ge307XG4gICAgLyoqXG4gICAgICAgICAqIEBtZXRob2Qgb25seVxuICAgICAgICAgKiBAbWVtYmVyT2YgRW50cnlcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIERpc3BsYXlzIHZhbHVlcyBvZiBvbmx5IHRoZSBzcGVjaWZpZWQgZmllbGRzIG9mIGVudHJpZXMgb3IgYXNzZXRzIGluIHRoZSByZXNwb25zZVxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gW2tleT1CQVNFXSAtICBBc3NldHM6IDwvYnI+XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD5SZXRyaWV2ZXMgc3BlY2lmaWVkIGZpZWxkIG9mIGFzc2V0PC9wPlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gICAgICAgICAgICAtICBFbnRyaWVzOjwvYnI+XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+LSByZXRyaWV2ZXMgZGVmYXVsdCBmaWVsZHMgb2YgdGhlIHNjaGVtYS48L3A+XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+LSByZWZlcmVuY2VkX2NvbnRlbnQtdHlwZS11aWQgOiByZXRyaWV2ZXMgZmllbGRzIG9mIHRoZSByZWZlcnJlZCBjb250ZW50IHR5cGUuPC9wPlxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgLSBhcnJheSBvZiBmaWVsZHMgdGhhdCB5b3Ugd2FudCB0byBkaXNwbGF5IGluIHRoZSByZXNwb25zZVxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiA8Y2FwdGlvbj4gVGhlIG9ubHkgZnVuY3Rpb24gd2l0aCBmaWVsZF91aWQgd2lsbCBpbmNsdWRlIHRoZSBkYXRhIG9mIG9ubHkgdGhlIHNwZWNpZmllZCBmaWVsZHMgZm9yIGVhY2ggZW50cnkgYW5kIGV4Y2x1ZGUgdGhlIGRhdGEgb2YgYWxsIG90aGVyIGZpZWxkcy4gPC9jYXB0aW9uPlxuICAgICAgICAgKiBTdGFjay5Db250ZW50VHlwZSgnY29udGVudFR5cGVVaWQnKS5RdWVyeSgpLm9ubHkoJ3RpdGxlJykudG9KU09OKCkuZmluZCgpXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIDxjYXB0aW9uPiBUaGUgb25seSBmdW5jdGlvbiB3aXRoIGFuIGFycmF5IG9mIGZpZWxkX3VpZHMgd2lsbCBpbmNsdWRlIG11bHRpcGxlIGZpZWxkcyBmb3IgZWFjaCBlbnRyeSBhbmQgZXhjbHVkZSB0aGUgZGF0YSBvZiBhbGwgb3RoZXIgZmllbGRzLjwvY2FwdGlvbj5cbiAgICAgICAgICogU3RhY2suQ29udGVudFR5cGUoJ2NvbnRlbnRUeXBlVWlkJykuUXVlcnkoKS5vbmx5KFsndGl0bGUnLCdkZXNjcmlwdGlvbiddKS50b0pTT04oKS5maW5kKClcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogPGNhcHRpb24+IEluIG9ubHksIHdlIGhhdmUgdGhlIG9ubHkgd2l0aCBhIHJlZmVyZW5jZSBwYXJhbWV0ZXIsIHdoZXJlIHlvdSBuZWVkIHRvIGVudGVyIHRoZSBVSUQgb2YgdGhlIHJlZmVyZW5jZSBmaWVsZCBpbiBwbGFjZSBvZiBcInJlZmVyZW5jZV9maWVsZF91aWRcIiwgYW5kIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIGluY2x1ZGUgdGhlIGRhdGEgb2Ygb25seSB0aGUgc3BlY2lmaWVkIGZpZWxkX3VpZCBmb3IgZWFjaCBlbnRyeSBhbmQgZXhjbHVkZSB0aGUgZGF0YSBvZiBhbGwgb3RoZXIgZmllbGRzLjwvY2FwdGlvbj5cbiAgICAgICAgICogU3RhY2suQ29udGVudFR5cGUoJ2NvbnRlbnRUeXBlVWlkJykuUXVlcnkoKS5pbmNsdWRlUmVmZXJlbmNlKCdyZWZlcmVuY2VfZmllbGRfdWlkJykub25seSgncmVmZXJlbmNlX2ZpZWxkX3VpZCcsJ3RpdGxlJykudG9KU09OKCkuZmluZCgpXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIDxjYXB0aW9uPiBJbiBvbmx5LCB3ZSBoYXZlIHRoZSBvbmx5IHdpdGggYSByZWZlcmVuY2UgcGFyYW1ldGVyIHdpdGggYW4gYXJyYXksIHdoZXJlIHlvdSBuZWVkIHRvIGVudGVyIHRoZSBVSUQgb2YgdGhlIHJlZmVyZW5jZSBmaWVsZCBpbiBwbGFjZSBvZiBcInJlZmVyZW5jZV9maWVsZF91aWRcIiwgYW5kIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHdpdGggYW4gYXJyYXkgb2YgZmllbGRzIHRvIGluY2x1ZGUgdGhlIGRhdGEgb2Ygb25seSB0aGUgc3BlY2lmaWVkIGFycmF5IG9mIGZpZWxkX3VpZHMgZm9yIGVhY2ggZW50cnkgYW5kIGV4Y2x1ZGUgdGhlIGRhdGEgb2YgYWxsIG90aGVyIGZpZWxkcy48L2NhcHRpb24+XG4gICAgICAgICAqIFN0YWNrLkNvbnRlbnRUeXBlKCdjb250ZW50VHlwZVVpZCcpLlF1ZXJ5KCkuaW5jbHVkZVJlZmVyZW5jZSgncmVmZXJlbmNlX2ZpZWxkX3VpZCcpLm9ubHkoJ3JlZmVyZW5jZV9maWVsZF91aWQnLCBbJ3RpdGxlJywgJ2Rlc2NyaXB0aW9uJ10pLnRvSlNPTigpLmZpbmQoKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7RW50cnl9XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICB0aGlzLm9ubHkgPSBVdGlscy50cmFuc2Zvcm0oJ29ubHknKTtcbiAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBleGNlcHRcbiAgICAgICAgICogQG1lbWJlck9mIEVudHJ5XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBEaXNwbGF5cyBhbGwgZGF0YSBvZiBhbiBlbnRyaWVzIG9yIGFzc2V0cyBleGNsdWRpbmcgdGhlIGRhdGEgb2YgdGhlIHNwZWNpZmllZCBmaWVsZHMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBba2V5PUJBU0VdIC0gQkFTRSAoZGVmYXVsdCB2YWx1ZSkgLSByZXRyaWV2ZXMgZGVmYXVsdCBmaWVsZHMgb2YgdGhlIHNjaGVtYS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIHJlZmVyZW5jZWRfY29udGVudC10eXBlLXVpZCAtIHJldHJpZXZlcyBmaWVsZHMgb2YgdGhlIHJlZmVycmVkIGNvbnRlbnQgdHlwZS5cbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIC0gYXJyYXkgb2YgZmllbGRzIHRoYXQgeW91IHdhbnQgdG8gc2tpcCBpbiB0aGUgcmVzcG9uc2VcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogPGNhcHRpb24+IFRoZSBleGNlcHQgZnVuY3Rpb24gd2l0aCBmaWVsZF91aWQgd2lsbCBleGNsdWRlIHRoZSBkYXRhIG9mIG9ubHkgdGhlIHNwZWNpZmllZCBmaWVsZHMgZm9yIGVhY2ggZW50cnkgYW5kIGluY2x1ZGVzIHRoZSBkYXRhIG9mIGFsbCBvdGhlciBmaWVsZHMuIDwvY2FwdGlvbj5cbiAgICAgICAgICogU3RhY2suQ29udGVudFR5cGUoJ2NvbnRlbnRUeXBlVWlkJykuUXVlcnkoKS5leGNlcHQoJ3RpdGxlJykudG9KU09OKCkuZmluZCgpXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIDxjYXB0aW9uPiBUaGUgZXhjZXB0IGZ1bmN0aW9uIHdpdGggYW4gYXJyYXkgb2YgZmllbGRfdWlkcyB3aWxsIGV4Y2VwdCBtdWx0aXBsZSBmaWVsZHMgZm9yIGVhY2ggZW50cnkgYW5kIGluY2x1ZGUgdGhlIGRhdGEgb2YgYWxsIG90aGVyIGZpZWxkcy48L2NhcHRpb24+XG4gICAgICAgICAqIFN0YWNrLkNvbnRlbnRUeXBlKCdjb250ZW50VHlwZVVpZCcpLlF1ZXJ5KCkuZXhjZXB0KFsndGl0bGUnLCdkZXNjcmlwdGlvbiddKS50b0pTT04oKS5maW5kKClcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogPGNhcHRpb24+IEluIGV4Y2VwdCwgd2UgaGF2ZSB0aGUgb25seSB3aXRoIGEgcmVmZXJlbmNlIHBhcmFtZXRlciwgd2hlcmUgeW91IG5lZWQgdG8gZW50ZXIgdGhlIFVJRCBvZiB0aGUgcmVmZXJlbmNlIGZpZWxkIGluIHBsYWNlIG9mIFwicmVmZXJlbmNlX2ZpZWxkX3VpZFwiLCBhbmQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gZXhjZXB0IHRoZSBkYXRhIG9mIG9ubHkgdGhlIHNwZWNpZmllZCBmaWVsZF91aWQgZm9yIGVhY2ggZW50cnkgYW5kIGluY2x1ZGUgdGhlIGRhdGEgb2YgYWxsIG90aGVyIGZpZWxkcy48L2NhcHRpb24+XG4gICAgICAgICAqIFN0YWNrLkNvbnRlbnRUeXBlKCdjb250ZW50VHlwZVVpZCcpLlF1ZXJ5KCkuaW5jbHVkZVJlZmVyZW5jZSgncmVmZXJlbmNlX2ZpZWxkX3VpZCcpLmV4Y2VwdCgncmVmZXJlbmNlX2ZpZWxkX3VpZCcsJ3RpdGxlJykudG9KU09OKCkuZmluZCgpXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIDxjYXB0aW9uPiBJbiBleGNlcHQsIHdlIGhhdmUgdGhlIG9ubHkgd2l0aCBhIHJlZmVyZW5jZSBwYXJhbWV0ZXIgd2l0aCBhbiBhcnJheSwgd2hlcmUgeW91IG5lZWQgdG8gZW50ZXIgdGhlIFVJRCBvZiB0aGUgcmVmZXJlbmNlIGZpZWxkIGluIHBsYWNlIG9mIFwicmVmZXJlbmNlX2ZpZWxkX3VpZFwiLCBhbmQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgd2l0aCBhbiBhcnJheSBvZiBmaWVsZHMgdG8gZXhjZXB0IHRoZSBkYXRhIG9mIG9ubHkgdGhlIHNwZWNpZmllZCBhcnJheSBvZiBmaWVsZF91aWRzIGZvciBlYWNoIGVudHJ5IGFuZCBpbmNsdWRlIHRoZSBkYXRhIG9mIGFsbCBvdGhlciBmaWVsZHMuPC9jYXB0aW9uPlxuICAgICAgICAgKiBTdGFjay5Db250ZW50VHlwZSgnY29udGVudFR5cGVVaWQnKS5RdWVyeSgpLmluY2x1ZGVSZWZlcmVuY2UoJ3JlZmVyZW5jZV9maWVsZF91aWQnKS5leGNlcHQoJ3JlZmVyZW5jZV9maWVsZF91aWQnLCBbJ3RpdGxlJywgJ2Rlc2NyaXB0aW9uJ10pLnRvSlNPTigpLmZpbmQoKVxuICAgICAgICAgKiBAcmV0dXJucyB7RW50cnl9XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICB0aGlzLmV4Y2VwdCA9IFV0aWxzLnRyYW5zZm9ybSgnZXhjZXB0Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFbnRyeSwgW3tcbiAgICBrZXk6IFwic2V0Q2FjaGVQcm92aWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYWNoZVByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICBpZiAocHJvdmlkZXIgJiYgX3R5cGVvZihwcm92aWRlcikgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRDYWNoZVBvbGljeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYWNoZVBvbGljeShwb2xpY3kpIHtcbiAgICAgIGlmICh0eXBlb2YgcG9saWN5ID09PSAnbnVtYmVyJyAmJiBwb2xpY3kgPj0gLTEgJiYgcG9saWN5IDwgNCkge1xuICAgICAgICBpZiAoIXRoaXMuX3F1ZXJ5KSB7XG4gICAgICAgICAgdGhpcy5jYWNoZVBvbGljeSA9IHBvbGljeTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5Q2FjaGVQb2xpY3kgPSBwb2xpY3k7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLkNBQ0hFX1BPTElDWV9JTlZBTElEKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBpbmNsdWRlUmVmZXJlbmNlXG4gICAgICAgKiBAbWVtYmVyT2YgRW50cnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBGZXRjaGVzIHRoZSBlbnRpcmUgY29udGVudCBvZiByZWZlcmVuY2VkIGVudHJ5KGllcykuIDxhIGhyZWY9J2h0dHBzOi8vd3d3LmNvbnRlbnRzdGFjay5jb20vZG9jcy9kZXZlbG9wZXJzL2FwaXMvY29udGVudC1kZWxpdmVyeS1hcGkvI2luY2x1ZGUtcmVmZXJlbmNlJz5SZWFkIE1vcmU8L2E+XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogPGNhcHRpb24+IC5pbmNsdWRlUmVmZXJlbmNlIHdpdGggcmVmZXJlbmNlX2ZpZWxkX3VpZHMgYXMgYXJyYXkgPC9jYXB0aW9uPlxuICAgICAgICogdmFyIFF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGVzLnNvdXJjZSkuUXVlcnkoKTtcbiAgICAgICAgICAgICAgUXVlcnlcbiAgICAgICAgICAgICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsncmVmZXJlbmNlX2ZpZWxkX3VpZCcsICdvdGhlcl9yZWZlcmVuY2VfZmllbGRfdWlkJ10pXG4gICAgICAgICAgICAgICAgICAudG9KU09OKClcbiAgICAgICAgICAgICAgICAgIC5maW5kKClcbiAgICAgICAgICAgICAgICAgIC50aGVuKGZ1bmN0aW9uIHN1Y2Nlc3MoZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgIC8vJ2VudHJpZXMnIGlzICBhbiBvYmplY3QgdXNlZCB0byByZXRyaWV2ZSBkYXRhIGluY2x1ZGluZyByZWZlcmVuY2UgZW50cmllcy5cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogPGNhcHRpb24+IC5pbmNsdWRlUmVmZXJlbmNlIHdpdGggcmVmZXJlbmNlX2ZpZWxkX3VpZHMgYW5kIGl0cyBjaGlsZHJlbiByZWZlcmVuY2UgPC9jYXB0aW9uPlxuICAgICAgICogdmFyIFF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGVzLnNvdXJjZSkuUXVlcnkoKTtcbiAgICAgICAgICAgICAgUXVlcnlcbiAgICAgICAgICAgICAgICAgIC5pbmNsdWRlUmVmZXJlbmNlKFsncmVmZXJlbmNlX2ZpZWxkX3VpZCcsICdyZWZlcmVuY2VfZmllbGRfdWlkLmNoaWxkX3JlZmVyZW5jZV9maWVsZF91aWQnXSlcbiAgICAgICAgICAgICAgICAgIC50b0pTT04oKVxuICAgICAgICAgICAgICAgICAgLmZpbmQoKVxuICAgICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gc3VjY2VzcyhlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8nZW50cmllcycgaXMgIGFuIG9iamVjdCB1c2VkIHRvIHJldHJpZXZlIGRhdGEgaW5jbHVkaW5nIHJlZmVyZW5jZSBlbnRyaWVzLlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiA8Y2FwdGlvbj4gLmluY2x1ZGVSZWZlcmVuY2Ugd2l0aCByZWZlcmVuY2VfZmllbGRfdWlkcyA8L2NhcHRpb24+XG4gICAgICAgKiB2YXIgUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZXMuc291cmNlKS5RdWVyeSgpO1xuICAgICAgIFF1ZXJ5XG4gICAgICAgICAgLmluY2x1ZGVSZWZlcmVuY2UoJ3JlZmVyZW5jZV9maWVsZF91aWQnKVxuICAgICAgICAgIC50b0pTT04oKVxuICAgICAgICAgIC5maW5kKClcbiAgICAgICAgICAudGhlbihmdW5jdGlvbiBzdWNjZXNzKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgLy8nZW50cmllcycgaXMgIGFuIG9iamVjdCB1c2VkIHRvIHJldHJpZXZlIGRhdGEgaW5jbHVkaW5nIHBhcnRpY3VsYXIgcmVmZXJlbmNlIHVzaW5nIHJlZmVyZW5jZV91aWQuXG4gICAgICAgICAgfSlcbiAgICAgICAqIEByZXR1cm5zIHtFbnRyeX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5jbHVkZVJlZmVyZW5jZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlUmVmZXJlbmNlKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHZhbCA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgdmFsW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9xdWVyeS5pbmNsdWRlID0gdGhpcy5fcXVlcnkuaW5jbHVkZSB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMuX3F1ZXJ5LmluY2x1ZGUgPSB0aGlzLl9xdWVyeS5pbmNsdWRlLmNvbmNhdChhcmd1bWVudHNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLkVOVFJZX0lOVkFMSURfQVJHVU1FTlQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogU2V0cyB0aGUgbGFuZ3VhZ2UgY29kZSBvZiB3aGljaCB5b3Ugd2FudCB0byByZXRyaWV2ZSBkYXRhLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGxhbmd1YWdlX2NvZGUgLSBsYW5ndWFnZSBjb2RlLiBlLmcuICdlbi11cycsICdqYS1qcCcsIGV0Yy5cbiAgICAgICAqIEBtZW1iZXJPZiBFbnRyeVxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGxldCBkYXRhID0gU3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGVVaWQpLkVudHJ5KGVudHJ5VWlkKS5sYW5ndWFnZSgnamEtanAnKS5mZXRjaCgpXG4gICAgICAgKiBkYXRhXG4gICAgICAgKiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAgICAgIC8vICdyZXN1bHQnIGlzICBhbiBvYmplY3QgdXNlZCB0byByZXRyaWV2ZSBkYXRhIG9mIGphLWpwIGxhbmd1YWdlLlxuICAgICAgICogICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICogICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge0VudHJ5fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsYW5ndWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBsYW5ndWFnZShsYW5ndWFnZV9jb2RlKSB7XG4gICAgICBpZiAobGFuZ3VhZ2VfY29kZSAmJiB0eXBlb2YgbGFuZ3VhZ2VfY29kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fcXVlcnkubG9jYWxlID0gbGFuZ3VhZ2VfY29kZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZXRjaE9wdGlvbnMuZGVidWcpIHRoaXMuZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywgX21lc3NhZ2VzW1wiZGVmYXVsdFwiXS5FTlRSWV9MQU5HVUFHRV9JTlZBTElEKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgYWRkUXVlcnlcbiAgICAgICAqIEBtZW1iZXJPZiBFbnRyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIEFkZHMgcXVlcnkgdG8gRW50cnkgb2JqZWN0XG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0ga2V5IG9mIHRoZSBxdWVyeVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIC0gdmFsdWUgb2YgdGhlIHF1ZXJ5XG4gICAgICAgKiBAZXhhbXBsZSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZVVpZCkuRW50cnkoZW50cnlfdWlkKS5hZGRRdWVyeSgnaW5jbHVkZV9zY2hlbWEnLHRydWUpXG4gICAgICAgKiBAcmV0dXJucyB7RW50cnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFF1ZXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFF1ZXJ5KGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgJiYgdmFsdWUgJiYgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fcXVlcnlba2V5XSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLkVOVFJZX0FERF9RVUVSWV9JTlZBTElEKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgaW5jbHVkZUVtYmVkZGVkSXRlbXNcbiAgICAgICAqIEBtZW1iZXJPZiBFbnRyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIEluY2x1ZGUgRW1iZWRkZWQgT2JqZWN0cyAoRW50cmllcyBhbmQgQXNzZXRzKSBhbG9uZyB3aXRoIGVudHJ5L2VudHJpZXMgZGV0YWlscy5cbiAgICAgICAqIEBleGFtcGxlIFN0YWNrLkNvbnRlbnRUeXBlKFwiY29udGVudFR5cGVfdWlkXCIpLkVudHJ5KFwiZW50cnlfdWlkXCIpLmluY2x1ZGVFbWJlZGRlZEl0ZW1zKCkuZmV0Y2goKVxuICAgICAgICogQHJldHVybnMge0VudHJ5fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbmNsdWRlRW1iZWRkZWRJdGVtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlRW1iZWRkZWRJdGVtcygpIHtcbiAgICAgIHRoaXMuX3F1ZXJ5LmluY2x1ZGVfZW1iZWRkZWRfaXRlbXMgPSBbJ0JBU0UnXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBpbmNsdWRlU2NoZW1hXG4gICAgICAgKiBAbWVtYmVyT2YgRW50cnlcbiAgICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMy4zLjBcbiAgICAgICAqIEBkZXNjcmlwdGlvbiAgSW5jbHVkZSBzY2hlbWEgb2YgdGhlIGN1cnJlbnQgY29udGVudCB0eXBlIGFsb25nIHdpdGggZW50cnkvZW50cmllcyBkZXRhaWxzLlxuICAgICAgICogQGV4YW1wbGUgU3RhY2suQ29udGVudFR5cGUoXCJjb250ZW50VHlwZV91aWRcIikuRW50cnkoXCJlbnRyeV91aWRcIikuaW5jbHVkZVNjaGVtYSgpLmZldGNoKClcbiAgICAgICAqIEByZXR1cm5zIHtFbnRyeX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5jbHVkZVNjaGVtYVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlU2NoZW1hKCkge1xuICAgICAgdGhpcy5fcXVlcnkuaW5jbHVkZV9zY2hlbWEgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGluY2x1ZGVSZWZlcmVuY2VDb250ZW50VHlwZVVpZFxuICAgICAgICogQG1lbWJlck9mIEVudHJ5XG4gICAgICAgKiBAZGVzY3JpcHRpb24gIFRoaXMgbWV0aG9kIGFsc28gaW5jbHVkZXMgdGhlIGNvbnRlbnQgdHlwZSBVSURzIG9mIHRoZSByZWZlcmVuY2VkIGVudHJpZXMgcmV0dXJuZWQgaW4gdGhlIHJlc3BvbnNlLlxuICAgICAgICogQGV4YW1wbGUgU3RhY2suQ29udGVudFR5cGUoXCJjb250ZW50VHlwZV91aWRcIikuRW50cnkoXCJlbnRyeV91aWRcIikuaW5jbHVkZVJlZmVyZW5jZUNvbnRlbnRUeXBlVUlEKCkuZmV0Y2goKVxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIFF1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoXCJjb250ZW50VHlwZV91aWRcIikuRW50cnkoXCJlbnRyeV91aWRcIikuaW5jbHVkZVJlZmVyZW5jZUNvbnRlbnRUeXBlVUlEKCkuZmV0Y2goKVxuICAgICAgICogUXVlcnlcbiAgICAgICAqICAgICAgLnRvSlNPTigpXG4gICAgICAgKiAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAqICAgICAgICAgIGxldCB2YWx1ZSA9IHJlc3VsdC5nZXQoZmllbGRfdWlkKVxuICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7RW50cnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluY2x1ZGVSZWZlcmVuY2VDb250ZW50VHlwZVVJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlUmVmZXJlbmNlQ29udGVudFR5cGVVSUQoKSB7XG4gICAgICB0aGlzLl9xdWVyeS5pbmNsdWRlX3JlZmVyZW5jZV9jb250ZW50X3R5cGVfdWlkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBpbmNsdWRlRmFsbGJhY2tcbiAgICAgICAqIEBtZW1iZXJPZiBFbnRyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIEluY2x1ZGUgdGhlIGZhbGxiYWNrIGxvY2FsZSBwdWJsaXNoIGNvbnRlbnQsIGlmIHNwZWNpZmllZCBsb2NhbGUgY29udGVudCBpcyBub3QgcHVibGlzaC5cbiAgICAgICAqIEBleGFtcGxlIHN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlX3VpZCkuRW50cnkoZW50cnlfdWlkKS5pbmNsdWRlRmFsbGJhY2soKS5mZXRjaCgpXG4gICAgICAgKiBAcmV0dXJucyB7RW50cnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluY2x1ZGVGYWxsYmFja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlRmFsbGJhY2soKSB7XG4gICAgICB0aGlzLl9xdWVyeS5pbmNsdWRlX2ZhbGxiYWNrID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBpbmNsdWRlQnJhbmNoXG4gICAgICAgKiBAbWVtYmVyT2YgRW50cnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBJbmNsdWRlIHRoZSBCcmFuY2ggZm9yIHB1Ymxpc2ggY29udGVudC5cbiAgICAgICAqIEBleGFtcGxlIHN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlX3VpZCkuRW50cnkoZW50cnlfdWlkKS5pbmNsdWRlQnJhbmNoKCkuZmV0Y2goKVxuICAgICAgICogQHJldHVybnMge0VudHJ5fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbmNsdWRlQnJhbmNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluY2x1ZGVCcmFuY2goKSB7XG4gICAgICB0aGlzLl9xdWVyeS5pbmNsdWRlX2JyYW5jaCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgaW5jbHVkZU1ldGFkYXRhXG4gICAgICAgKiBAbWVtYmVyT2YgRW50cnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBJbmNsdWRlIHRoZSBtZXRhZGF0YSBmb3IgZ2V0dGluZyBtZXRhZGF0YSBjb250ZW50IGZvciB0aGUgZW50cnkuXG4gICAgICAgKiBAZXhhbXBsZSBzdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZV91aWQpLkVudHJ5KGVudHJ5X3VpZCkuaW5jbHVkZU1ldGFkYXRhKCkuZmV0Y2goKVxuICAgICAgICogQHJldHVybnMge0VudHJ5fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbmNsdWRlTWV0YWRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jbHVkZU1ldGFkYXRhKCkge1xuICAgICAgdGhpcy5fcXVlcnkuaW5jbHVkZV9tZXRhZGF0YSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgaW5jbHVkZUNvbnRlbnRUeXBlXG4gICAgICAgKiBAbWVtYmVyT2YgRW50cnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBJbmNsdWRlIHRoZSBkZXRhaWxzIG9mIHRoZSBjb250ZW50IHR5cGUgYWxvbmcgd2l0aCB0aGUgZW50cnkvZW50cmllcyBkZXRhaWxzLlxuICAgICAgICogQGV4YW1wbGUgc3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGVfdWlkKS5FbnRyeShlbnRyeV91aWQpLmluY2x1ZGVDb250ZW50VHlwZSgpLmZldGNoKClcbiAgICAgICAqIEByZXR1cm5zIHtFbnRyeX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5jbHVkZUNvbnRlbnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluY2x1ZGVDb250ZW50VHlwZSgpIHtcbiAgICAgIHRoaXMuX3F1ZXJ5LmluY2x1ZGVfY29udGVudF90eXBlID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBpbmNsdWRlT3duZXJcbiAgICAgICAqIEBtZW1iZXJPZiBFbnRyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIEluY2x1ZGUgdGhlIG93bmVyIGRldGFpbHMgYWxvbmcgd2l0aCB0aGUgZW50cnkvZW50cmllcyBkZXRhaWxzLlxuICAgICAgICogQGV4YW1wbGUgc3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGVfdWlkKS5FbnRyeShlbnRyeV91aWQpLmluY2x1ZGVPd25lcigpLmZldGNoKClcbiAgICAgICAqIEByZXR1cm5zIHtFbnRyeX1cbiAgICAgICAqIEBkZXByZWNhdGVkIFRoZSBpbmNsdWRlT3duZXIgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZC5cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5jbHVkZU93bmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluY2x1ZGVPd25lcigpIHtcbiAgICAgIGNvbnNvbGUud2FybihfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLkVOVFJZX0lOQ0xVREVfT1dORVJfREVQUkVDQVRFRCk7XG4gICAgICB0aGlzLl9xdWVyeS5pbmNsdWRlX293bmVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCB0b0pTT05cbiAgICAgICAqIEBtZW1iZXJPZiBFbnRyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIHlvdXIgcmVzcG9uc2UgaW50byBwbGFpbiBKYXZhc1NjcmlwdCBvYmplY3QuU3VwcG9ydHMgYm90aCBlbnRyeSBhbmQgYXNzZXQgcXVlcmllcy5cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlVWlkKS5FbnRyeShlbnRyeVVpZCkuZmV0Y2goKVxuICAgICAgICogUXVlcnlcbiAgICAgICAqICAgICAgLnRvSlNPTigpXG4gICAgICAgKiAgICAgIC50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAqICAgICAgICAgIGxldCB2YWx1ZSA9IHJlc3VsdC5nZXQoZmllbGRfdWlkKVxuICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7RW50cnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICB0aGlzLnRvanNvbiA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgYWRkUGFyYW1cbiAgICAgICAqIEBtZW1iZXJPZiBFbnRyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIEluY2x1ZGVzIHF1ZXJ5IHBhcmFtZXRlcnMgaW4geW91ciBxdWVyaWVzLlxuICAgICAgICogQGV4YW1wbGUgdmFyIGRhdGEgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZVVpZCkuRW50cnkoZW50cnlVaWQpLmFkZFBhcmFtKCdpbmNsdWRlX2NvdW50JywgJ3RydWUnKS5mZXRjaCgpXG4gICAgICAgKiAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgKiAgICAgICAgICAvLyAncmVzdWx0JyBpcyBhbiBvYmplY3Qgd2hpY2ggY29udGVudCB0aGUgZGF0YSBpbmNsdWRpbmcgY291bnQgaW4ganNvbiBvYmplY3QgZm9ybVxuICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7RW50cnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFBhcmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBhcmFtKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgJiYgdmFsdWUgJiYgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9xdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsIF9tZXNzYWdlc1tcImRlZmF1bHRcIl0uRU5UUllfQUREX1BBUkFNX0lOVkFMSUQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBWYXJpYW50c1xuICAgICAgICogQG1lbWJlck9mIEVudHJ5XG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdWlkIC0gdWlkIG9mIHRoZSB2YXJpYW50cyBlbnRyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluaXRpYWxpemVyIGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBWYXJpYW50cyBFbnRyeSBvYmplY3RcbiAgICAgICAqIEByZXR1cm5zIHtWYXJpYW50c31cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmFyaWFudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFyaWFudHModmFyaWFudF9oZWFkZXJzKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YXJpYW50X2hlYWRlcnMpICYmIHZhcmlhbnRfaGVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1sneC1jcy12YXJpYW50LXVpZCddID0gdmFyaWFudF9oZWFkZXJzLmpvaW4oJywnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGVhZGVyc1sneC1jcy12YXJpYW50LXVpZCddID0gdmFyaWFudF9oZWFkZXJzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGZldGNoXG4gICAgICAgKiBAbWVtYmVyT2YgRW50cnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBGZXRjaGVzIGEgcGFydGljdWxhciBlbnRyeSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZW50cnkgVUlELlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIFN0YWNrLkNvbnRlbnRUeXBlKGNvbnRlbnRUeXBlVWlkKS5FbnRyeShlbnRyeVVpZCkudG9KU09OKCkuZmV0Y2goKVxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBTdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZVVpZCkuRW50cnkoZW50cnlVaWQpLnRvSlNPTigpLmZldGNoKHtcbiAgICAgICAqXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7cHJvbWlzZX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2goZmV0Y2hPcHRpb25zKSB7XG4gICAgICB2YXIgaG9zdCA9IHRoaXMuY29uZmlnLmhvc3QgKyAnOicgKyB0aGlzLmNvbmZpZy5wb3J0O1xuICAgICAgaWYgKHRoaXMubGl2ZV9wcmV2aWV3ICYmIHRoaXMubGl2ZV9wcmV2aWV3LmVuYWJsZSA9PT0gdHJ1ZSAmJiB0aGlzLmxpdmVfcHJldmlldy5saXZlX3ByZXZpZXcgJiYgdGhpcy5saXZlX3ByZXZpZXcubGl2ZV9wcmV2aWV3ICE9PSAnaW5pdCcpIHtcbiAgICAgICAgaG9zdCA9IHRoaXMubGl2ZV9wcmV2aWV3Lmhvc3Q7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5lbnRyeV91aWQpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IFV0aWxzLm1lcmdlRGVlcCh7fSwgdGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICB1cmw6IHRoaXMuY29uZmlnLnByb3RvY29sICsgJzovLycgKyBob3N0ICsgJy8nICsgdGhpcy5jb25maWcudmVyc2lvbiArIHRoaXMuY29uZmlnLnVybHMuY29udGVudF90eXBlcyArIHRoaXMuY29udGVudF90eXBlX3VpZCArIHRoaXMuY29uZmlnLnVybHMuZW50cmllcyArIHRoaXMuZW50cnlfdWlkLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIF9tZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcXVlcnk6IHRoaXMuX3F1ZXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IFV0aWxzLm1lcmdlRGVlcCh0aGlzLmZldGNoT3B0aW9ucywgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFV0aWxzLnNlbmRSZXF1ZXN0KFV0aWxzLm1lcmdlRGVlcCh7fSwgdGhpcyksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsIF9tZXNzYWdlc1tcImRlZmF1bHRcIl0uRU5UUllfVUlEX1JFUVVJUkVEKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDk0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5nZXQgPSBnZXQ7XG5leHBvcnRzLmdldEtleXMgPSBnZXRLZXlzO1xuZXhwb3J0cy5nZXRTdG9yYWdlID0gZ2V0U3RvcmFnZTtcbmV4cG9ydHMuc2V0ID0gc2V0O1xudmFyIF9sb2NhbHN0b3JhZ2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oODgwKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICBcImRlZmF1bHRcIjogZVxuICB9O1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSBfbG9jYWxzdG9yYWdlW1wiZGVmYXVsdFwiXS5nZXRJdGVtKGtleSk7XG4gIHRyeSB7XG4gICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuICByZXR1cm4gZGF0YSB8fCBudWxsO1xufVxuZnVuY3Rpb24gc2V0KGtleSwgZGF0YSkge1xuICB0cnkge1xuICAgIGlmIChfdHlwZW9mKGRhdGEpID09PSAnb2JqZWN0Jykge1xuICAgICAgX2xvY2Fsc3RvcmFnZVtcImRlZmF1bHRcIl0uc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2xvY2Fsc3RvcmFnZVtcImRlZmF1bHRcIl0uc2V0SXRlbShrZXksIGRhdGEpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHt9XG59XG5mdW5jdGlvbiBnZXRTdG9yYWdlKCkge1xuICByZXR1cm4gX2xvY2Fsc3RvcmFnZVtcImRlZmF1bHRcIl0gfHwgbnVsbDtcbn1cbmZ1bmN0aW9uIGdldEtleXMoKSB7XG4gIHJldHVybiBfbG9jYWxzdG9yYWdlW1wiZGVmYXVsdFwiXSA/IE9iamVjdC5rZXlzKF9sb2NhbHN0b3JhZ2VbXCJkZWZhdWx0XCJdKSA6IFtdO1xufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTc0OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG4vKipcbiAqIENlbnRyYWxpemVkIGVycm9yIGFuZCBpbmZvcm1hdGlvbmFsIG1lc3NhZ2VzIGZvciBDb250ZW50c3RhY2sgSmF2YVNjcmlwdCBTREtcbiAqIEBtb2R1bGUgbWVzc2FnZXNcbiAqL1xuXG52YXIgTUVTU0FHRVMgPSB7XG4gIC8vIENhY2hlIFByb3ZpZGVyIE1lc3NhZ2VzXG4gIENBQ0hFX1BST1ZJREVSX01JU1NJTkc6ICdNaXNzaW5nIGNhY2hlIHByb3ZpZGVyLiBQcm92aWRlIGEgdmFsaWQgcHJvdmlkZXIgYW5kIHRyeSBhZ2Fpbi4nLFxuICBDQUNIRV9QT0xJQ1lfSU5WQUxJRDogJ0ludmFsaWQgY2FjaGUgcG9saWN5LiBQcm92aWRlIGEgdmFsaWQgcG9saWN5IHZhbHVlIGFuZCB0cnkgYWdhaW4uJyxcbiAgLy8gU3RhY2sgSW5pdGlhbGl6YXRpb24gTWVzc2FnZXNcbiAgU1RBQ0tfSU5WQUxJRF9QQVJBTVNfT0JKRUNUOiAnSW52YWxpZCBwYXJhbWV0ZXJzLiBUaGUgc3BlY2lmaWVkIEFQSSBLZXksIERlbGl2ZXJ5IFRva2VuLCBvciBFbnZpcm9ubWVudCBOYW1lIGlzIGludmFsaWQuJyxcbiAgU1RBQ0tfSU5WQUxJRF9QQVJBTVNfU1RSSU5HOiAnSW52YWxpZCBzdHJpbmcgcGFyYW1ldGVycy4gUHJvdmlkZSB2YWxpZCBBUEkgS2V5LCBEZWxpdmVyeSBUb2tlbiwgYW5kIEVudmlyb25tZW50IE5hbWUuJyxcbiAgU1RBQ0tfSU5WQUxJRF9QQVJBTVNfR0VORVJJQzogJ0ludmFsaWQgcGFyYW1ldGVycy4gUHJvdmlkZSB2YWxpZCBwYXJhbWV0ZXJzIHRvIGluaXRpYWxpemUgdGhlIENvbnRlbnRzdGFjayBqYXZhc2NyaXB0LVNESyBTdGFjay4nLFxuICBTVEFDS19PQlNPTEVURV9GVU5DVElPTjogXCJXQVJOSU5HISBPYnNvbGV0ZSBmdW5jdGlvbiBjYWxsZWQuIEZ1bmN0aW9uICdDb250ZW50c3RhY2suU3RhY2soYXBpX2tleSwgZGVsaXZlcnlfdG9rZW4sIGVudmlyb25tZW50KScgaGFzIGJlZW4gZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSAnQ29udGVudHN0YWNrLlN0YWNrKHthcGlfa2V5LCBkZWxpdmVyeV90b2tlbiwgZW52aXJvbm1lbnQsIHJlZ2lvbiwgYnJhbmNoLCBmZXRjaE9wdGlvbnN9KScgZnVuY3Rpb24gaW5zdGVhZCFcIixcbiAgLy8gRW50cnkgTWVzc2FnZXNcbiAgRU5UUllfVUlEX1JFUVVJUkVEOiBcIkVudHJ5IFVJRCByZXF1aXJlZC4gUHJvdmlkZSBhbiBlbnRyeSBVSUQuIGUuZy4gLkVudHJ5KCdlbnRyeV91aWQnKVwiLFxuICBFTlRSWV9JTkNMVURFX09XTkVSX0RFUFJFQ0FURUQ6ICdUaGUgaW5jbHVkZU93bmVyIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQuIFRoaXMgZnVuY3Rpb25hbGl0eSBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgcmVtb3ZlIHRoaXMgbWV0aG9kIGZyb20geW91ciBjb2RlLicsXG4gIEVOVFJZX0lOVkFMSURfQVJHVU1FTlQ6ICdJbnZhbGlkIGFyZ3VtZW50LiBBcmd1bWVudCBzaG91bGQgYmUgYSBTdHJpbmcgb3IgYW4gQXJyYXkuJyxcbiAgRU5UUllfTEFOR1VBR0VfSU5WQUxJRDogJ0ludmFsaWQgbGFuZ3VhZ2UgY29kZS4gQXJndW1lbnQgc2hvdWxkIGJlIGEgU3RyaW5nLicsXG4gIEVOVFJZX0FERF9RVUVSWV9JTlZBTElEOiAnSW52YWxpZCBxdWVyeSBwYXJhbWV0ZXJzLiBGaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgYSBTdHJpbmcuJyxcbiAgRU5UUllfQUREX1BBUkFNX0lOVkFMSUQ6ICdJbnZhbGlkIHBhcmFtZXRlcnMuIEJvdGgga2V5IGFuZCB2YWx1ZSBzaG91bGQgYmUgc3RyaW5ncy4nLFxuICAvLyBRdWVyeS9UcmFuc2Zvcm0gTWVzc2FnZXMgKG9ubHkvZXhjZXB0KVxuICBUUkFOU0ZPUk1fSU5WQUxJRF9TSU5HTEVfUEFSQU06ICdJbnZhbGlkIHBhcmFtZXRlcnMuIEV4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIGFycmF5IG9mIGZpZWxkIG5hbWVzLicsXG4gIFRSQU5TRk9STV9JTlZBTElEX0RPVUJMRV9QQVJBTTogJ0ludmFsaWQgcGFyYW1ldGVycy4gRXhwZWN0ZWQgZmlyc3QgcGFyYW1ldGVyIGFzIGEgc3RyaW5nIChyZWZlcmVuY2UgZmllbGQgVUlEKSBhbmQgc2Vjb25kIHBhcmFtZXRlciBhcyBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBmaWVsZCBuYW1lcy4nLFxuICBUUkFOU0ZPUk1fSU5WQUxJRF9QQVJBTV9DT1VOVDogJ0ludmFsaWQgcGFyYW1ldGVycy4gUHJvdmlkZSBlaXRoZXIgb25lIHBhcmFtZXRlciAoZmllbGQgbmFtZSBvciBhcnJheSkgb3IgdHdvIHBhcmFtZXRlcnMgKHJlZmVyZW5jZSBmaWVsZCBVSUQgYW5kIGZpZWxkIG5hbWUgb3IgYXJyYXkpLicsXG4gIC8vIFJlcXVlc3QvRXJyb3IgTWVzc2FnZXNcbiAgUkVRVUVTVF9FUlJPUl9PQ0NVUlJFRDogZnVuY3Rpb24gUkVRVUVTVF9FUlJPUl9PQ0NVUlJFRChlcnJvcikge1xuICAgIHJldHVybiBcIkFuIGVycm9yIG9jY3VycmVkOiBcIi5jb25jYXQoZXJyb3IpO1xuICB9XG59O1xudmFyIF9kZWZhdWx0ID0gZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBNRVNTQUdFUztcblxuLyoqKi8gfSksXG5cbi8qKiovIDE4NTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gUmVxdWVzdDtcbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oOTI1KSk7XG52YXIgX2h0dHAgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOTQwKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICBcImRlZmF1bHRcIjogZVxuICB9O1xufVxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkge1xuICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBXZWFrTWFwKSB2YXIgciA9IG5ldyBXZWFrTWFwKCksXG4gICAgbiA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiAoX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7XG4gICAgaWYgKCF0ICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbyxcbiAgICAgIGksXG4gICAgICBmID0ge1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBlXG4gICAgICB9O1xuICAgIGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiBmO1xuICAgIGlmIChvID0gdCA/IG4gOiByKSB7XG4gICAgICBpZiAoby5oYXMoZSkpIHJldHVybiBvLmdldChlKTtcbiAgICAgIG8uc2V0KGUsIGYpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfdCBpbiBlKSBcImRlZmF1bHRcIiAhPT0gX3QgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCBfdCkgJiYgKChpID0gKG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgX3QpKSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gbyhmLCBfdCwgaSkgOiBmW190XSA9IGVbX3RdKTtcbiAgICByZXR1cm4gZjtcbiAgfSkoZSwgdCk7XG59XG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuLy8gSlMgU0RLIHZlcnNpb25cbnZhciB2ZXJzaW9uID0gJzMuMjYuMyc7XG52YXIgZW52aXJvbm1lbnQsIGFwaV9rZXk7XG5mdW5jdGlvbiBSZXF1ZXN0KHN0YWNrLCBmZXRjaE9wdGlvbnMpIHtcbiAgdmFyIHJlcXVlc3RQYXJhbXMgPSBzdGFjay5yZXF1ZXN0UGFyYW1zO1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBxdWVyeVBhcmFtcztcbiAgICB2YXIgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICAgIHZhciBfc2VyaWFsaXplID0gZnVuY3Rpb24gc2VyaWFsaXplKG9iaiwgcHJlZml4KSB7XG4gICAgICBpZiAoX3R5cGVvZihvYmopID09PSAnb2JqZWN0JyAmJiBvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIF9pID0gb2JqLmxlbmd0aDsgaSA8IF9pOyBpKyspIHtcbiAgICAgICAgICBwYXJhbXMuYXBwZW5kKHByZWZpeCArICdbXScsIG9ialtpXSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIHAgaW4gb2JqKSB7XG4gICAgICAgICAgdmFyIGsgPSBwcmVmaXggPyBwcmVmaXggKyAnWycgKyBwICsgJ10nIDogcDtcbiAgICAgICAgICB2YXIgdiA9IG9ialtwXTtcbiAgICAgICAgICB2ICE9PSBudWxsICYmIF90eXBlb2YodikgPT09ICdvYmplY3QnICYmIHAgIT09ICdxdWVyeScgPyBfc2VyaWFsaXplKHYsIGspIDogcGFyYW1zLmFwcGVuZChrLCBwICE9PSAncXVlcnknID8gdiA6IEpTT04uc3RyaW5naWZ5KHYpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcy50b1N0cmluZygpO1xuICAgIH07XG5cbiAgICAvLyBzZXR0aW5nIGhlYWRlcnNcbiAgICByZXF1ZXN0UGFyYW1zLmhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnO1xuICAgIHJlcXVlc3RQYXJhbXMuaGVhZGVyc1snWC1Vc2VyLUFnZW50J10gPSAnY29udGVudHN0YWNrLWRlbGl2ZXJ5LWphdmFzY3JpcHQtbm9kZWpzLycgKyB2ZXJzaW9uO1xuICAgIGlmIChyZXF1ZXN0UGFyYW1zLmJvZHkgJiYgX3R5cGVvZihyZXF1ZXN0UGFyYW1zLmJvZHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgZGVsZXRlIHJlcXVlc3RQYXJhbXMuYm9keS5fbWV0aG9kO1xuICAgICAgaWYgKF90eXBlb2YocmVxdWVzdFBhcmFtcy5ib2R5LnF1ZXJ5KSA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMocmVxdWVzdFBhcmFtcy5ib2R5LnF1ZXJ5KS5sZW5ndGggPT09IDApIGRlbGV0ZSByZXF1ZXN0UGFyYW1zLmJvZHkucXVlcnk7XG4gICAgICBxdWVyeVBhcmFtcyA9IF9zZXJpYWxpemUocmVxdWVzdFBhcmFtcy5ib2R5KTtcbiAgICB9XG4gICAgcmV0dXJuIGZldGNoUmV0cnkoc3RhY2ssIHF1ZXJ5UGFyYW1zLCBmZXRjaE9wdGlvbnMsIHJlc29sdmUsIHJlamVjdCwgZmV0Y2hPcHRpb25zLnJldHJ5RGVsYXksIGZldGNoT3B0aW9ucy5yZXRyeUxpbWl0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiB3YWl0KHJldHJ5RGVsYXkpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBmZXRjaFJldHJ5KHN0YWNrLCBxdWVyeVBhcmFtcywgZmV0Y2hPcHRpb25zLCByZXNvbHZlLCByZWplY3QpIHtcbiAgdmFyIHJldHJ5RGVsYXkgPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IDMwMDtcbiAgdmFyIHJldHJ5TGltaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IDU7XG4gIHZhciByZXF1ZXN0UGFyYW1zID0gc3RhY2sucmVxdWVzdFBhcmFtcztcbiAgdmFyIHVybCA9IHJlcXVlc3RQYXJhbXMudXJsICsgJz8nICsgcXVlcnlQYXJhbXM7XG4gIHZhciBoZWFkZXJzID0gcmVxdWVzdFBhcmFtcy5oZWFkZXJzO1xuICB2YXIgb3B0aW9uID0gVXRpbHMubWVyZ2VEZWVwKHtcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgdGltZW91dDogMzAwMDBcbiAgfSwgZmV0Y2hPcHRpb25zKTtcbiAgZnVuY3Rpb24gb25FcnJvcihlcnJvcikge1xuICAgIGlmIChyZXRyeUxpbWl0ID09PSAwKSB7XG4gICAgICBpZiAoZmV0Y2hPcHRpb25zLmRlYnVnKSBmZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBlcnJvcik7XG4gICAgICByZWplY3QoZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbXNEZWxheSA9IHJldHJ5RGVsYXk7XG4gICAgICByZXRyeUxpbWl0ID0gcmV0cnlMaW1pdCAtIDE7XG4gICAgICB2YXIgcmV0cnlDb3VudCA9IGZldGNoT3B0aW9ucy5yZXRyeUxpbWl0IC0gcmV0cnlMaW1pdDtcbiAgICAgIGlmIChmZXRjaE9wdGlvbnMucmV0cnlEZWxheU9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGZldGNoT3B0aW9ucy5yZXRyeURlbGF5T3B0aW9ucy5iYXNlKSB7XG4gICAgICAgICAgbXNEZWxheSA9IGZldGNoT3B0aW9ucy5yZXRyeURlbGF5T3B0aW9ucy5iYXNlICogcmV0cnlDb3VudDtcbiAgICAgICAgfSBlbHNlIGlmIChmZXRjaE9wdGlvbnMucmV0cnlEZWxheU9wdGlvbnMuY3VzdG9tQmFja29mZikge1xuICAgICAgICAgIG1zRGVsYXkgPSBmZXRjaE9wdGlvbnMucmV0cnlEZWxheU9wdGlvbnMuY3VzdG9tQmFja29mZihyZXRyeUNvdW50LCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdhaXQobXNEZWxheSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmZXRjaFJldHJ5KHN0YWNrLCBxdWVyeVBhcmFtcywgZmV0Y2hPcHRpb25zLCByZXNvbHZlLCByZWplY3QsIHJldHJ5RGVsYXksIHJldHJ5TGltaXQpO1xuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmZXRjaFJldHJ5KHN0YWNrLCBxdWVyeVBhcmFtcywgZmV0Y2hPcHRpb25zLCByZXNvbHZlLCByZWplY3QsIHJldHJ5RGVsYXksIHJldHJ5TGltaXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmZXRjaE9wdGlvbnMuZGVidWcpIGZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdpbmZvJywge1xuICAgIHVybDogdXJsLFxuICAgIG9wdGlvbjogb3B0aW9uXG4gIH0pO1xuICB2YXIgcmVxdWVzdCA9IHtcbiAgICB1cmw6IHVybCxcbiAgICBvcHRpb246IG9wdGlvblxuICB9O1xuICB2YXIgcGx1Z2lucyA9IHN0YWNrLnBsdWdpbnM7XG4gIGlmIChwbHVnaW5zICYmIHBsdWdpbnMgIT09IHVuZGVmaW5lZCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBwbHVnaW5zLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW5zW2luZGV4XS5vblJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVxdWVzdCA9IHBsdWdpbnNbaW5kZXhdLm9uUmVxdWVzdChzdGFjaywgcmVxdWVzdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICgwLCBfaHR0cFtcImRlZmF1bHRcIl0pKHJlcXVlc3QudXJsLCByZXF1ZXN0Lm9wdGlvbikudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBpZiAoZmV0Y2hPcHRpb25zLmRlYnVnKSBmZXRjaE9wdGlvbnMubG9nSGFuZGxlcignaW5mbycsIHJlc3BvbnNlKTtcbiAgICB2YXIgZGF0YSA9IHJlc3BvbnNlLmpzb24oKTtcbiAgICBpZiAocmVzcG9uc2Uub2sgJiYgcmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAoanNvbikge1xuICAgICAgICBmb3IgKHZhciBfaW5kZXggPSAwOyBfaW5kZXggPCBwbHVnaW5zLmxlbmd0aCAmJiB0eXBlb2YgcGx1Z2luc1tfaW5kZXhdLm9uUmVzcG9uc2UgPT09ICdmdW5jdGlvbic7IF9pbmRleCsrKSB7XG4gICAgICAgICAganNvbiA9IHBsdWdpbnNbX2luZGV4XS5vblJlc3BvbnNlKHN0YWNrLCByZXF1ZXN0LCByZXNwb25zZSwganNvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShqc29uKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgc3RhdHVzID0gcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdHVzVGV4dDtcbiAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAoanNvbikge1xuICAgICAgICB2YXIgZXJyb3JfbWVzc2FnZSA9IGpzb24uZXJyb3JfbWVzc2FnZSxcbiAgICAgICAgICBlcnJvcl9jb2RlID0ganNvbi5lcnJvcl9jb2RlLFxuICAgICAgICAgIGVycm9ycyA9IGpzb24uZXJyb3JzO1xuICAgICAgICB2YXIgZXJyb3JEZXRhaWxzID0ge1xuICAgICAgICAgIGVycm9yX21lc3NhZ2U6IGVycm9yX21lc3NhZ2UsXG4gICAgICAgICAgZXJyb3JfY29kZTogZXJyb3JfY29kZSxcbiAgICAgICAgICBlcnJvcnM6IGVycm9ycyxcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBzdGF0dXNUZXh0XG4gICAgICAgIH07XG4gICAgICAgIGlmIChmZXRjaE9wdGlvbnMucmV0cnlDb25kaXRpb24gJiYgZmV0Y2hPcHRpb25zLnJldHJ5Q29uZGl0aW9uKHJlc3BvbnNlKSkge1xuICAgICAgICAgIG9uRXJyb3IoZXJyb3JEZXRhaWxzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoZmV0Y2hPcHRpb25zLmRlYnVnKSBmZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBlcnJvckRldGFpbHMpO1xuICAgICAgICAgIHJlamVjdChlcnJvckRldGFpbHMpO1xuICAgICAgICB9XG4gICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGZldGNoT3B0aW9ucy5kZWJ1ZykgZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywge1xuICAgICAgICAgIHN0YXR1czogc3RhdHVzLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IHN0YXR1c1RleHRcbiAgICAgICAgfSk7XG4gICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXMsXG4gICAgICAgICAgc3RhdHVzVGV4dDogc3RhdHVzVGV4dFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICBpZiAoZmV0Y2hPcHRpb25zLmRlYnVnKSBmZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBlcnJvcik7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgfSk7XG59XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyMDk6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oOTI1KSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFdlYWtNYXApIHZhciByID0gbmV3IFdlYWtNYXAoKSxcbiAgICBuID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIChfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHtcbiAgICBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBvLFxuICAgICAgaSxcbiAgICAgIGYgPSB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgXCJkZWZhdWx0XCI6IGVcbiAgICAgIH07XG4gICAgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIGY7XG4gICAgaWYgKG8gPSB0ID8gbiA6IHIpIHtcbiAgICAgIGlmIChvLmhhcyhlKSkgcmV0dXJuIG8uZ2V0KGUpO1xuICAgICAgby5zZXQoZSwgZik7XG4gICAgfVxuICAgIGZvciAodmFyIF90IGluIGUpIFwiZGVmYXVsdFwiICE9PSBfdCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIF90KSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBfdCkpICYmIChpLmdldCB8fCBpLnNldCkgPyBvKGYsIF90LCBpKSA6IGZbX3RdID0gZVtfdF0pO1xuICAgIHJldHVybiBmO1xuICB9KShlLCB0KTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbi8qKlxuICogQGNsYXNzIFJlc3VsdFxuICogQHN1bW1hcnkgQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBgUmVzdWx0YC5cbiAqIEBkZXNjcmlwdGlvbiBBbiBpbml0aWFsaXplciBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgUmVzdWx0IG9iamVjdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBBUEkgcmVzdWx0IG9iamVjdFxuICogQGV4YW1wbGVcbiAqIGJsb2dFbnRyeS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAqICAgICAgLy8gc3VjY2VzcyBmdW5jdGlvblxuICogfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAqICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAqIH0pXG4gKiBAZXhhbXBsZVxuICogYXNzZXRRdWVyeS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAqICAgICAgLy8gc3VjY2VzcyBmdW5jdGlvblxuICogfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAqICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAqIH0pXG4gKiBAcmV0dXJucyB7UmVzdWx0fVxuICogQGluc3RhbmNlXG4gKi9cbnZhciBSZXN1bHQgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlc3VsdChvYmplY3QpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmVzdWx0KTtcbiAgICBpZiAob2JqZWN0KSB7XG4gICAgICB0aGlzLm9iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAgICogQG1ldGhvZCB0b0pTT05cbiAgICAgKiBAbWVtYmVyT2YgUmVzdWx0XG4gICAgICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIGBSZXN1bHRgIHRvIHBsYWluIGphdmFzY3JpcHQgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYmxvZ0VudHJ5LnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAqICAgICAgcmVzdWx0ID0gcmVzdWx0WzBdWzBdLnRvSlNPTigpXG4gICAgICogfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgKiAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICogfSlcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGFzc2V0UXVlcnkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICogICAgICByZXN1bHQgPSByZXN1bHRbMF1bMF0udG9KU09OKClcbiAgICAgKiB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAqICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgKiB9KVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoUmVzdWx0LCBbe1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMub2JqZWN0KCkgPyBVdGlscy5tZXJnZURlZXAoSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh7fSkpLCB0aGlzLm9iamVjdCgpKSA6IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGdldFxuICAgICAgICogQG1lbWJlck9mIFJlc3VsdFxuICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlIGRldGFpbHMgb2YgYSBmaWVsZCBiYXNlZCBvbiB0aGUgVUlEIHByb3ZpZGVkXG4gICAgICAgKiBAcGFyYW0gZmllbGRfdWlkIHVpZCBvZiB0aGUgZmllbGRcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBibG9nRW50cnkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgKiAgICAgIGxldCB2YWx1ZSA9IHJlc3VsdFswXVswXS5nZXQoZmllbGRfdWlkKVxuICAgICAgICogfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqIH0pXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogYXNzZXRRdWVyeS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAqICAgICAgbGV0IHZhbHVlID0gcmVzdWx0WzBdWzBdLmdldChmaWVsZF91aWQpXG4gICAgICAgKiB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICogICAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICogfSlcbiAgICAgICAqIEByZXR1cm5zIHtwcm9taXNlfVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKHRoaXMub2JqZWN0KCkgJiYga2V5KSB7XG4gICAgICAgIHZhciBmaWVsZHMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgdmFyIHZhbHVlID0gZmllbGRzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgZmllbGQpIHtcbiAgICAgICAgICByZXR1cm4gcHJldltmaWVsZF07XG4gICAgICAgIH0sIHRoaXMub2JqZWN0KCkpO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGdldERvd25sb2FkVXJsXG4gICAgICAgKiBAbWVtYmVyT2YgUmVzdWx0XG4gICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBkb3dubG9hZCBVUkwgYmFzZWQgb24gdGhlIGRpc3Bvc2l0aW9uIHZhbHVlLlxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyAtIGRpc3Bvc2l0aW9uIHZhbHVlXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogYXNzZXRRdWVyeS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAqICAgICAgbGV0IHZhbHVlID0gcmVzdWx0WzBdWzBdLmdldERvd25sb2FkVXJsKGRpc3Bvc2l0aW9uX3ZhbHVlKVxuICAgICAgICogfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqIH0pXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXREb3dubG9hZFVybFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREb3dubG9hZFVybChkaXNwb3NpdGlvbikge1xuICAgICAgaWYgKHRoaXMub2JqZWN0KCkpIHtcbiAgICAgICAgdmFyIHVybCA9IHRoaXMub2JqZWN0KCkudXJsID8gdGhpcy5vYmplY3QoKS51cmwgOiBudWxsO1xuICAgICAgICB2YXIgX2Rpc3Bvc2l0aW9uID0gZGlzcG9zaXRpb24gJiYgdHlwZW9mIGRpc3Bvc2l0aW9uID09PSAnc3RyaW5nJyA/IGRpc3Bvc2l0aW9uIDogJ2F0dGFjaG1lbnQnO1xuICAgICAgICByZXR1cm4gdXJsID8gdXJsICsgJz9kaXNwb3NpdGlvbj0nICsgX2Rpc3Bvc2l0aW9uIDogbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbn0oKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDI0MTpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIGNvbmZpZyA9IHtcbiAgcHJvdG9jb2w6IFwiaHR0cHNcIixcbiAgaG9zdDogXCJjZG4uY29udGVudHN0YWNrLmlvXCIsXG4gIHBvcnQ6IDQ0MyxcbiAgdmVyc2lvbjogXCJ2M1wiLFxuICB1cmxzOiB7XG4gICAgc3luYzogXCIvc3RhY2tzL3N5bmNcIixcbiAgICBjb250ZW50X3R5cGVzOiBcIi9jb250ZW50X3R5cGVzL1wiLFxuICAgIGVudHJpZXM6IFwiL2VudHJpZXMvXCIsXG4gICAgYXNzZXRzOiBcIi9hc3NldHMvXCIsXG4gICAgZW52aXJvbm1lbnRzOiBcIi9lbnZpcm9ubWVudHMvXCIsXG4gICAgdGF4b25vbWllczogXCIvdGF4b25vbWllcy9lbnRyaWVzXCJcbiAgfSxcbiAgbGl2ZV9wcmV2aWV3OiB7XG4gICAgZW5hYmxlOiBmYWxzZSxcbiAgICBob3N0OiAncmVzdC1wcmV2aWV3LmNvbnRlbnRzdGFjay5jb20nXG4gIH1cbn07XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGNvbmZpZztcblxuLyoqKi8gfSksXG5cbi8qKiovIDI1Mzpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIkBjb250ZW50c3RhY2svdXRpbHNcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyNzU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgX3F1ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMxOCkpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7XG4gIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgXCJkZWZhdWx0XCI6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7XG59XG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBlKSB7XG4gIGlmIChlICYmIChcIm9iamVjdFwiID09IF90eXBlb2YoZSkgfHwgXCJmdW5jdGlvblwiID09IHR5cGVvZiBlKSkgcmV0dXJuIGU7XG4gIGlmICh2b2lkIDAgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgcmV0dXJuIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQodCk7XG59XG5mdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKGUpIHtcbiAgaWYgKHZvaWQgMCA9PT0gZSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2YodCkge1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mID0gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LmdldFByb3RvdHlwZU9mLmJpbmQoKSA6IGZ1bmN0aW9uICh0KSB7XG4gICAgcmV0dXJuIHQuX19wcm90b19fIHx8IE9iamVjdC5nZXRQcm90b3R5cGVPZih0KTtcbiAgfSwgX2dldFByb3RvdHlwZU9mKHQpO1xufVxuZnVuY3Rpb24gX2luaGVyaXRzKHQsIGUpIHtcbiAgaWYgKFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSAmJiBudWxsICE9PSBlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIHQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShlICYmIGUucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiB0LFxuICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgIH1cbiAgfSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlICYmIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZih0LCBlKSB7XG4gIHJldHVybiBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gPSBlLCB0O1xuICB9LCBfc2V0UHJvdG90eXBlT2YodCwgZSk7XG59XG4vLyBPdmVycmlkZWluZyBjb21wYXJlIGZ1bmN0aW9uIHRvIGluY2x1ZGUgbGV2ZWxcbnZhciBfZXh0ZW5kID0ge1xuICBjb21wYXJlOiBmdW5jdGlvbiBjb21wYXJlKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGtleSwgdmFsdWUsIGxldmVscykge1xuICAgICAgaWYgKGtleSAmJiB2YWx1ZSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV0gPSB0aGlzLl9xdWVyeS5xdWVyeS5maWxlX3NpemUgfHwge307XG4gICAgICAgIHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV1bdHlwZV0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKGxldmVscyAmJiB0eXBlb2YgbGV2ZWxzID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV0ubGV2ZWxzID0gbGV2ZWxzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsICdLaW5kbHkgcHJvdmlkZSB2YWxpZCBwYXJhbWV0ZXJzLicpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG52YXIgVGF4b25vbXkgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1F1ZXJ5KSB7XG4gIGZ1bmN0aW9uIFRheG9ub215KCkge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVGF4b25vbXkpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBUYXhvbm9teSk7XG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBhYm92ZVxuICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgYWxsIGVudHJpZXMgZm9yIGEgc3BlY2lmaWMgdGF4b25vbXkgdGhhdCBtYXRjaCBvbmx5IHRoZSBwYXJlbnQgdGVybShzKSBvZiBhIHNwZWNpZmllZCB0YXJnZXQgdGVybSwgZXhjbHVkaW5nIHRoZSB0YXJnZXQgdGVybSBpdHNlbGYuIFlvdSBjYW4gYWxzbyBzcGVjaWZ5IGEgc3BlY2lmaWMgbGV2ZWwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIHVpZCBvZiB0aGUgdGF4b25vbXksIHNwZWNpZmllZCBhcyBgdGF4b25vbWllcy48dGF4b25vbXlfdWlkPmBcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdWlkIG9mIHRoZSB0ZXJtIHRvIGJlIG1hdGNoZWRcbiAgICAgKiBAZXhhbXBsZSBGb3IgdGF4b25vbXlfdWlkID0gdGF4b25vbXkxLCBhbmQgdGVybV91aWQgPSB0ZXJtMVxuICAgICAqIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5hYm92ZShcInRheG9ub21pZXMudGF4b25vbXkxXCIsIFwidGVybTFcIikudG9KU09OKCkuZmluZCgpIC8vIHdpdGhvdXQgbGV2ZWxzXG4gICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuYWJvdmUoXCJ0YXhvbm9taWVzLnRheG9ub215MVwiLCBcInRlcm0xXCIsIDQpLnRvSlNPTigpLmZpbmQoKSAvLyB3aXRoIGxldmVsc1xuICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICogICAgICAgICAgLy8gcmVzdWx0ID0gdGhlIGRhdGEgd2hpY2ggbWF0Y2hlcyBvbmx5IHRoZSBwYXJlbnQgdGVybShzKSBvZiB0aGUgc3BlY2lmaWVkIHRlcm0sIGV4Y2x1ZGluZyB0aGUgdGVybSBpdHNlbGZcbiAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICogICAgICB9KVxuICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdGhpcy5hYm92ZSA9IF9leHRlbmQuY29tcGFyZSgnJGFib3ZlJyk7XG5cbiAgICAvKipcbiAgICAgKiBAbWV0aG9kIGVxdWFsQW5kQWJvdmVcbiAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IGFsbCBlbnRyaWVzIGZvciBhIHNwZWNpZmljIHRheG9ub215IHRoYXQgbWF0Y2ggYSBzcGVjaWZpYyB0ZXJtIGFuZCBhbGwgaXRzIGFuY2VzdG9yIHRlcm1zLCByZXF1aXJpbmcgb25seSB0aGUgdGFyZ2V0IHRlcm0gYW5kIGEgc3BlY2lmaWVkIGxldmVsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB1aWQgb2YgdGhlIHRheG9ub215LCBzcGVjaWZpZWQgYXMgYHRheG9ub21pZXMuPHRheG9ub215X3VpZD5gXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIHVpZCBvZiB0aGUgdGVybSB0byBiZSBtYXRjaGVkXG4gICAgICogQGV4YW1wbGUgRm9yIHRheG9ub215X3VpZCA9IHRheG9ub215MSwgYW5kIHRlcm1fdWlkID0gdGVybTFcbiAgICAgKiBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2soKS5Db250ZW50VHlwZSgnZXhhbXBsZScpLlF1ZXJ5KCk7XG4gICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuZXF1YWxBbmRBYm92ZShcInRheG9ub21pZXMudGF4b25vbXkxXCIsIFwidGVybTFcIikudG9KU09OKCkuZmluZCgpIC8vIHdpdGhvdXQgbGV2ZWxzXG4gICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuZXF1YWxBbmRBYm92ZShcInRheG9ub21pZXMudGF4b25vbXkxXCIsIFwidGVybTFcIiwgNCkudG9KU09OKCkuZmluZCgpIC8vIHdpdGggbGV2ZWxzXG4gICAgICogICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgKiAgICAgICAgICAvLyByZXN1bHQgPSB0aGUgZGF0YSB3aGljaCBtYXRjaGVzIGEgc3BlY2lmaWMgdGVybSBhbmQgYWxsIGl0cyBhbmNlc3RvciB0ZXJtc1xuICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgKiAgICAgIH0pXG4gICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90aGlzLmVxdWFsQW5kQWJvdmUgPSBfZXh0ZW5kLmNvbXBhcmUoJyRlcV9hYm92ZScpO1xuXG4gICAgLyoqXG4gICAgICogQG1ldGhvZCBiZWxvd1xuICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgYWxsIGVudHJpZXMgZm9yIGEgc3BlY2lmaWMgdGF4b25vbXkgdGhhdCBtYXRjaCBhbGwgb2YgdGhlaXIgZGVzY2VuZGFudCB0ZXJtcyBieSBzcGVjaWZ5aW5nIG9ubHkgdGhlIHRhcmdldCB0ZXJtIGFuZCBhIHNwZWNpZmljIGxldmVsLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB1aWQgb2YgdGhlIHRheG9ub215LCBzcGVjaWZpZWQgYXMgYHRheG9ub21pZXMuPHRheG9ub215X3VpZD5gXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIHVpZCBvZiB0aGUgdGVybSB0byBiZSBtYXRjaGVkXG4gICAgICogQGV4YW1wbGUgRm9yIHRheG9ub215X3VpZCA9IHRheG9ub215MSwgYW5kIHRlcm1fdWlkID0gdGVybTFcbiAgICAgKiBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2soKS5Db250ZW50VHlwZSgnZXhhbXBsZScpLlF1ZXJ5KCk7XG4gICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuYmVsb3coXCJ0YXhvbm9taWVzLnRheG9ub215MVwiLCBcInRlcm0xXCIpLnRvSlNPTigpLmZpbmQoKSAvLyB3aXRob3V0IGxldmVsc1xuICAgICAqICAgICAgICAgIGxldCBkYXRhID0gYmxvZ1F1ZXJ5LmJlbG93KFwidGF4b25vbWllcy50YXhvbm9teTFcIiwgXCJ0ZXJtMVwiLCA0KS50b0pTT04oKS5maW5kKCkgLy8gd2l0aCBsZXZlbHNcbiAgICAgKiAgICAgICAgICBkYXRhLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAqICAgICAgICAgIC8vIHJlc3VsdCA9IHRoZSBkYXRhIHdoaWNoIG1hdGNoZXMgYWxsIG9mIHRoZSBkZXNjZW5kYW50IHRlcm1zLlxuICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgKiAgICAgIH0pXG4gICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAqIEBpbnN0YW5jZVxuICAgICAqL1xuICAgIF90aGlzLmJlbG93ID0gX2V4dGVuZC5jb21wYXJlKCckYmVsb3cnKTtcblxuICAgIC8qKlxuICAgICAqIEBtZXRob2QgZXF1YWxBbmRCZWxvd1xuICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgYWxsIGVudHJpZXMgZm9yIGEgc3BlY2lmaWMgdGF4b25vbXkgdGhhdCBtYXRjaCBhIHNwZWNpZmljIHRlcm0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudCB0ZXJtcywgcmVxdWlyaW5nIG9ubHkgdGhlIHRhcmdldCB0ZXJtIGFuZCBhIHNwZWNpZmllZCBsZXZlbC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdWlkIG9mIHRoZSB0YXhvbm9teSwgc3BlY2lmaWVkIGFzIGB0YXhvbm9taWVzLjx0YXhvbm9teV91aWQ+YFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB1aWQgb2YgdGhlIHRlcm0gdG8gYmUgbWF0Y2hlZFxuICAgICAqIEBleGFtcGxlIEZvciB0YXhvbm9teV91aWQgPSB0YXhvbm9teTEsIGFuZCB0ZXJtX3VpZCA9IHRlcm0xXG4gICAgICogbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAqICAgICAgICAgIGxldCBkYXRhID0gYmxvZ1F1ZXJ5LmVxdWFsQW5kQmVsb3coXCJ0YXhvbm9taWVzLnRheG9ub215MVwiLCBcInRlcm0xXCIpLnRvSlNPTigpLmZpbmQoKSAvLyB3aXRob3V0IGxldmVsc1xuICAgICAqICAgICAgICAgIGxldCBkYXRhID0gYmxvZ1F1ZXJ5LmVxdWFsQW5kQmVsb3coXCJ0YXhvbm9taWVzLnRheG9ub215MVwiLCBcInRlcm0xXCIsIDQpLnRvSlNPTigpLmZpbmQoKSAvLyB3aXRoIGxldmVsc1xuICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICogICAgICAgICAgLy8gcmVzdWx0ID0gdGhlIGRhdGEgd2hpY2ggbWF0Y2hlcyBhIHNwZWNpZmljIHRlcm0gYW5kIGFsbCBpdHMgZGVzY2VuZGFudCB0ZXJtcy5cbiAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICogICAgICB9KVxuICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfdGhpcy5lcXVhbEFuZEJlbG93ID0gX2V4dGVuZC5jb21wYXJlKCckZXFfYmVsb3cnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKFRheG9ub215LCBfUXVlcnkpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFRheG9ub215KTtcbn0oX3F1ZXJ5W1wiZGVmYXVsdFwiXSk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyAyODU6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBfbG9jYWxzdG9yYWdlID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY0MSkpO1xudmFyIF9tZXNzYWdlcyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNzQpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkge1xuICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgIFwiZGVmYXVsdFwiOiBlXG4gIH07XG59XG52YXIgQ2FjaGVQcm92aWRlciA9IHt9O1xuQ2FjaGVQcm92aWRlci5wcm92aWRlcnMgPSBmdW5jdGlvbiAocHJvdmlkZXIpIHtcbiAgaWYgKHByb3ZpZGVyKSB7XG4gICAgcmV0dXJuIF9sb2NhbHN0b3JhZ2VbXCJkZWZhdWx0XCJdO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUuZXJyb3IoX21lc3NhZ2VzW1wiZGVmYXVsdFwiXS5DQUNIRV9QUk9WSURFUl9NSVNTSU5HKTtcbiAgfVxufTtcbkNhY2hlUHJvdmlkZXIucG9saWNpZXMgPSB7XG4gIElHTk9SRV9DQUNIRTogLTEsXG4gIE9OTFlfTkVUV09SSzogMCxcbiAgQ0FDSEVfRUxTRV9ORVRXT1JLOiAxLFxuICBORVRXT1JLX0VMU0VfQ0FDSEU6IDIsXG4gIENBQ0hFX1RIRU5fTkVUV09SSzogM1xufTtcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ2FjaGVQcm92aWRlcjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDMxODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIFV0aWxzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoX193ZWJwYWNrX3JlcXVpcmVfXyg5MjUpKTtcbnZhciBfZW50cnkgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDIpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkge1xuICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgIFwiZGVmYXVsdFwiOiBlXG4gIH07XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFdlYWtNYXApIHZhciByID0gbmV3IFdlYWtNYXAoKSxcbiAgICBuID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIChfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHtcbiAgICBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBvLFxuICAgICAgaSxcbiAgICAgIGYgPSB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgXCJkZWZhdWx0XCI6IGVcbiAgICAgIH07XG4gICAgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIGY7XG4gICAgaWYgKG8gPSB0ID8gbiA6IHIpIHtcbiAgICAgIGlmIChvLmhhcyhlKSkgcmV0dXJuIG8uZ2V0KGUpO1xuICAgICAgby5zZXQoZSwgZik7XG4gICAgfVxuICAgIGZvciAodmFyIF90IGluIGUpIFwiZGVmYXVsdFwiICE9PSBfdCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIF90KSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBfdCkpICYmIChpLmdldCB8fCBpLnNldCkgPyBvKGYsIF90LCBpKSA6IGZbX3RdID0gZVtfdF0pO1xuICAgIHJldHVybiBmO1xuICB9KShlLCB0KTtcbn1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGEsIG4pIHtcbiAgaWYgKCEoYSBpbnN0YW5jZW9mIG4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXMoZSwgcikge1xuICBmb3IgKHZhciB0ID0gMDsgdCA8IHIubGVuZ3RoOyB0KyspIHtcbiAgICB2YXIgbyA9IHJbdF07XG4gICAgby5lbnVtZXJhYmxlID0gby5lbnVtZXJhYmxlIHx8ICExLCBvLmNvbmZpZ3VyYWJsZSA9ICEwLCBcInZhbHVlXCIgaW4gbyAmJiAoby53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIF90b1Byb3BlcnR5S2V5KG8ua2V5KSwgbyk7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhlLCByLCB0KSB7XG4gIHJldHVybiByICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUucHJvdG90eXBlLCByKSwgdCAmJiBfZGVmaW5lUHJvcGVydGllcyhlLCB0KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGU7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSBfdHlwZW9mKGkpID8gaSA6IGkgKyBcIlwiO1xufVxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZih0KSB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gX3R5cGVvZihpKSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHtcbiAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbn1cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIGUpIHtcbiAgaWYgKGUgJiYgKFwib2JqZWN0XCIgPT0gX3R5cGVvZihlKSB8fCBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUpKSByZXR1cm4gZTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZCh0KTtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoZSkge1xuICBpZiAodm9pZCAwID09PSBlKSB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgdHJ5IHtcbiAgICB2YXIgdCA9ICFCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7XG4gIH0gY2F0Y2ggKHQpIHt9XG4gIHJldHVybiAoX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IGZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZih0KSB7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4gdC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHQpO1xuICB9LCBfZ2V0UHJvdG90eXBlT2YodCk7XG59XG5mdW5jdGlvbiBfaW5oZXJpdHModCwgZSkge1xuICBpZiAoXCJmdW5jdGlvblwiICE9IHR5cGVvZiBlICYmIG51bGwgIT09IGUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGUgJiYgZS5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHQsXG4gICAgICB3cml0YWJsZTogITAsXG4gICAgICBjb25maWd1cmFibGU6ICEwXG4gICAgfVxuICB9KSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogITFcbiAgfSksIGUgJiYgX3NldFByb3RvdHlwZU9mKHQsIGUpO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG52YXIgX2V4dGVuZCA9IHtcbiAgY29tcGFyZTogZnVuY3Rpb24gY29tcGFyZSh0eXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ICYmIHZhbHVlICYmIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhpcy5fcXVlcnkucXVlcnlba2V5XSA9IHRoaXMuX3F1ZXJ5LnF1ZXJ5LmZpbGVfc2l6ZSB8fCB7fTtcbiAgICAgICAgdGhpcy5fcXVlcnkucXVlcnlba2V5XVt0eXBlXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCAnS2luZGx5IHByb3ZpZGUgdmFsaWQgcGFyYW1ldGVycy4nKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBjb250YWluZWQ6IGZ1bmN0aW9uIGNvbnRhaW5lZChib29sKSB7XG4gICAgdmFyIHR5cGUgPSBib29sID8gJyRpbicgOiAnJG5pbic7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoa2V5ICYmIHZhbHVlICYmIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV0gPSB0aGlzLl9xdWVyeS5xdWVyeVtrZXldIHx8IHt9O1xuICAgICAgICB0aGlzLl9xdWVyeS5xdWVyeVtrZXldW3R5cGVdID0gdGhpcy5fcXVlcnkucXVlcnlba2V5XVt0eXBlXSB8fCBbXTtcbiAgICAgICAgdGhpcy5fcXVlcnkucXVlcnlba2V5XVt0eXBlXSA9IHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV1bdHlwZV0uY29uY2F0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZXRjaE9wdGlvbnMuZGVidWcpIHRoaXMuZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywgJ0tpbmRseSBwcm92aWRlIHZhbGlkIHBhcmFtZXRlcnMuJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZXhpc3RzOiBmdW5jdGlvbiBleGlzdHMoYm9vbCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoa2V5ICYmIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV0gPSB0aGlzLl9xdWVyeS5xdWVyeVtrZXldIHx8IHt9O1xuICAgICAgICB0aGlzLl9xdWVyeS5xdWVyeVtrZXldLiRleGlzdHMgPSBib29sO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCAnS2luZGx5IHByb3ZpZGUgdmFsaWQgcGFyYW1ldGVycy4nKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBsb2dpY2FsOiBmdW5jdGlvbiBsb2dpY2FsKHR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9xdWVyeSA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIF9pID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IF9pOyBpKyspIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50c1tpXSBpbnN0YW5jZW9mIFF1ZXJ5ICYmIGFyZ3VtZW50c1tpXS5fcXVlcnkucXVlcnkpIHtcbiAgICAgICAgICBfcXVlcnkucHVzaChhcmd1bWVudHNbaV0uX3F1ZXJ5LnF1ZXJ5KTtcbiAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKGFyZ3VtZW50c1tpXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgX3F1ZXJ5LnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3F1ZXJ5LnF1ZXJ5W3R5cGVdKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5LnF1ZXJ5W3R5cGVdID0gdGhpcy5fcXVlcnkucXVlcnlbdHlwZV0uY29uY2F0KF9xdWVyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWVyeS5xdWVyeVt0eXBlXSA9IF9xdWVyeTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH0sXG4gIHNvcnQ6IGZ1bmN0aW9uIHNvcnQodHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBpZiAoa2V5ICYmIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5W3R5cGVdID0ga2V5O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCAnQXJndW1lbnQgc2hvdWxkIGJlIGEgc3RyaW5nLicpO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHBhZ2luYXRpb246IGZ1bmN0aW9uIHBhZ2luYXRpb24odHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5W3R5cGVdID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsICdBcmd1bWVudCBzaG91bGQgYmUgYSBudW1iZXIuJyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gZ2V0UmVxdWVzdFVybFxuICogQGRlc2NyaXB0aW9uIFJldHVybnMgaG9zdCB1cmwgYmFzZWQgb24gdGhpcy50eXBlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHRoaXMgYHRoaXNgIHZhcmlhYmxlIGZyb20gUXVlcnkgY2xhc3NcbiAqIEByZXR1cm4ge3N0cmluZ30gcmV0dXJucyB0aGUgdXJsIHRoYXQgd2lsbCBiZSB1c2VkIHRvIG1ha2UgQVBJIGNhbGxzXG4gKi9cbmZ1bmN0aW9uIGdldFJlcXVlc3RVcmwodHlwZSwgY29uZmlnLCBjb250ZW50X3R5cGVfdWlkLCBiYXNlVVJMKSB7XG4gIHZhciB1cmw7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2Fzc2V0JzpcbiAgICAgIHVybCA9IGJhc2VVUkwgKyBjb25maWcudXJscy5hc3NldHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0YXhvbm9teSc6XG4gICAgICB1cmwgPSBiYXNlVVJMICsgY29uZmlnLnVybHMudGF4b25vbWllcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbnRlbnRUeXBlJzpcbiAgICBkZWZhdWx0OlxuICAgICAgdXJsID0gYmFzZVVSTCArIGNvbmZpZy51cmxzLmNvbnRlbnRfdHlwZXMgKyBjb250ZW50X3R5cGVfdWlkICsgY29uZmlnLnVybHMuZW50cmllcztcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogQGNsYXNzXG4gICBRdWVyeVxuICogQGRlc2NyaXB0aW9uXG4gKiBBbiBpbml0aWFsaXplciBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgUXVlcnkgb2JqZWN0LlByb3ZpZGVzIHN1cHBvcnQgZm9yIGFsbCBzZWFyY2ggcXVlcmllc1xuICogQGV4YW1wbGVcbiAqIDxjYXB0aW9uPlF1ZXJ5IGluc3RhbmNlIGNyZWF0aW9uLjwvY2FwdGlvbj5cbiAqIGxldCBRdWVyeSA9IENvbnRlbnRzdGFjay5TdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAqIGxldCBhc3NldFF1ZXJ5ID0gIENvbnRlbnRzdGFjay5TdGFjaygpLkFzc2V0cygpLlF1ZXJ5KCk7XG4gKiBAcmV0dXJucyB7UXVlcnl9XG4gKi9cbnZhciBRdWVyeSA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRW50cnkpIHtcbiAgZnVuY3Rpb24gUXVlcnkoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBRdWVyeSk7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFF1ZXJ5KTtcbiAgICBfdGhpcy5fcXVlcnkgPSBfdGhpcy5fcXVlcnkgfHwge307XG4gICAgX3RoaXMuX3F1ZXJ5LnF1ZXJ5ID0gX3RoaXMuX3F1ZXJ5LnF1ZXJ5IHx8IHt9O1xuICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kIGxlc3NUaGFuXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIGVudHJpZXMgaW4gd2hpY2ggdGhlIHZhbHVlIG9mIGEgZmllbGQgaXMgbGVzc2VyIHRoYW4gdGhlIHByb3ZpZGVkIHZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB1aWQgb2YgdGhlIGZpZWxkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB1c2VkIHRvIG1hdGNoIG9yIGNvbXBhcmVcbiAgICAgICAgICogQGV4YW1wbGUgbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5sZXNzVGhhbignY3JlYXRlZF9hdCcsJzIwMTUtMDYtMjInKS5maW5kKClcbiAgICAgICAgICogICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICogICAgICAgICAgLy8gcmVzdWx0IGNvbnRlbnQgdGhlIGRhdGEgd2hvJ3MgJ2NyZWF0ZWRfYXQgZGF0ZScgaXMgbGVzcyB0aGFuICcyMDE1LTA2LTIyJ1xuICAgICAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgKiAgICAgICAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICAgKiAgICAgIH0pXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgIF90aGlzLmxlc3NUaGFuID0gX2V4dGVuZC5jb21wYXJlKCckbHQnKTtcblxuICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kIGxlc3NUaGFuT3JFcXVhbFRvXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIGVudHJpZXMgaW4gd2hpY2ggdGhlIHZhbHVlIG9mIGEgZmllbGQgaXMgbGVzc2VyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdWlkIG9mIHRoZSBmaWVsZFxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdXNlZCB0byBtYXRjaCBvciBjb21wYXJlXG4gICAgICAgICAqIEBleGFtcGxlIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkubGVzc1RoYW5PckVxdWFsVG8oJ2NyZWF0ZWRfYXQnLCcyMDE1LTA2LTIyJykuZmluZCgpXG4gICAgICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAqICAgICAgICAgIC8vIHJlc3VsdCBjb250YWluIHRoZSBkYXRhIG9mIGVudHJpZXMgd2hlcmUgdGhlICdjcmVhdGVkX2F0JyBkYXRlIHdpbGwgYmUgbGVzcyB0aGFuIG9yIGVxdWFsdG8gJzIwMTUtMDYtMjInLlxuICAgICAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgKiAgICAgICAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICAgKiAgICAgIH0pXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgIF90aGlzLmxlc3NUaGFuT3JFcXVhbFRvID0gX2V4dGVuZC5jb21wYXJlKCckbHRlJyk7XG4gICAgLyoqXG4gICAgICAgICAqIEBtZXRob2QgZ3JlYXRlclRoYW5cbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgZW50cmllcyBpbiB3aGljaCB0aGUgdmFsdWUgZm9yIGEgZmllbGQgaXMgZ3JlYXRlciB0aGFuIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIHVpZCBvZiB0aGUgZmllbGRcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSAtICB2YWx1ZSB1c2VkIHRvIG1hdGNoIG9yIGNvbXBhcmVcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogICAgICAgICAgbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5ncmVhdGVyVGhhbignY3JlYXRlZF9hdCcsJzIwMTUtMDMtMTInKS5maW5kKClcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICBkYXRhLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgY29udGFpbnMgdGhlIGRhdGEgb2YgZW50cmllcyB3aGVyZSB0aGUgJ2NyZWF0ZWRfYXQnIGRhdGUgd2lsbCBiZSBncmVhdGVydGhhbiAnMjAxNS0wNi0yMidcbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAgICogICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICBfdGhpcy5ncmVhdGVyVGhhbiA9IF9leHRlbmQuY29tcGFyZSgnJGd0Jyk7XG5cbiAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBncmVhdGVyVGhhbk9yRXF1YWxUb1xuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBlbnRyaWVzIGluIHdoaWNoIHRoZSB2YWx1ZSBmb3IgYSBmaWVsZCBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdWlkIG9mIHRoZSBmaWVsZFxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gVmFsdWUgdXNlZCB0byBtYXRjaCBvciBjb21wYXJlXG4gICAgICAgICAqIEBleGFtcGxlIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuZ3JlYXRlclRoYW5PckVxdWFsVG8oJ2NyZWF0ZWRfYXQnLCcyMDE1LTAzLTEyJykuZmluZCgpXG4gICAgICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICogICAgICAgICAgLy8gcmVzdWx0IGNvbnRhaW5zIHRoZSBkYXRhIG9mIGVudHJpZXMgd2hlcmUgdGhlICdjcmVhdGVkX2F0JyBkYXRlIHdpbGwgYmUgZ3JlYXRlclRoYW4gb3IgZXF1YWx0byAnMjAxNS0wNi0yMidcbiAgICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAgICogICAgICB9KVxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICBfdGhpcy5ncmVhdGVyVGhhbk9yRXF1YWxUbyA9IF9leHRlbmQuY29tcGFyZSgnJGd0ZScpO1xuXG4gICAgLyoqXG4gICAgICAgICAqIEBtZXRob2Qgbm90RXF1YWxUb1xuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBlbnRyaWVzIGluIHdoaWNoIHRoZSB2YWx1ZSBmb3IgYSBmaWVsZCBkb2VzIG5vdCBtYXRjaCB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB1aWQgb2YgdGhlIGZpZWxkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBWYWx1ZSB1c2VkIHRvIG1hdGNoIG9yIGNvbXBhcmVcbiAgICAgICAgICogQGV4YW1wbGUgbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5ub3RFcXVhbFRvKCd0aXRsZScsJ0RlbW8nKS5maW5kKClcbiAgICAgICAgICogICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgKiAgICAgICAgICAgIC8vIOKAmHJlc3VsdOKAmSBjb250YWlucyB0aGUgbGlzdCBvZiBlbnRyaWVzIHdoZXJlIHZhbHVlIG9mIHRoZSDigJh0aXRsZeKAmSBmaWVsZCB3aWxsIG5vdCBiZSAnRGVtbycuXG4gICAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAqICAgICAgfSlcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgX3RoaXMubm90RXF1YWxUbyA9IF9leHRlbmQuY29tcGFyZSgnJG5lJyk7XG5cbiAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBjb250YWluZWRJblxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlIGVudHJpZXMgaW4gd2hpY2ggdGhlIHZhbHVlIG9mIGEgZmllbGQgbWF0Y2hlcyB3aXRoIGFueSBvZiB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgdmFsdWVzXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB1aWQgb2YgdGhlIGZpZWxkXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBBcnJheSBvZiB2YWx1ZXMgdGhhdCBhcmUgdG8gYmUgdXNlZCB0byBtYXRjaCBvciBjb21wYXJlXG4gICAgICAgICAqIEBleGFtcGxlIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuY29udGFpbmVkSW4oJ3RpdGxlJywgWydEZW1vJywgJ1dlbGNvbWUnXSkuZmluZCgpXG4gICAgICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICogICAgICAgICAgLy8g4oCYcmVzdWx04oCZIGNvbnRhaW5zIHRoZSBsaXN0IG9mIGVudHJpZXMgd2hlcmUgdmFsdWUgb2YgdGhlIOKAmHRpdGxl4oCZIGZpZWxkIHdpbGwgY29udGFpbiBlaXRoZXIgJ0RlbW8nIG9yIOKAmFdlbGNvbWXigJkuXG4gICAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAqICAgICAgfSlcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgX3RoaXMuY29udGFpbmVkSW4gPSBfZXh0ZW5kLmNvbnRhaW5lZCh0cnVlKTtcblxuICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kIG5vdENvbnRhaW5lZEluXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgZW50cmllcyBpbiB3aGljaCB0aGUgdmFsdWUgb2YgYSBmaWVsZCBkb2VzIG5vdCBtYXRjaCB3aXRoIGFueSBvZiB0aGUgcHJvdmlkZWQgYXJyYXkgb2YgdmFsdWVzLlxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gdWlkIG9mIHRoZSBmaWVsZFxuICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZSAtIEFycmF5IG9mIHZhbHVlcyB0aGF0IGFyZSB0byBiZSB1c2VkIHRvIG1hdGNoIG9yIGNvbXBhcmVcbiAgICAgICAgICogQGV4YW1wbGUgbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5ub3RDb250YWluZWRJbigndGl0bGUnLCBbJ0RlbW8nLCAnV2VsY29tZSddKS5maW5kKClcbiAgICAgICAgICogICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgKiAgICAgICAgICAvLyAncmVzdWx0JyBjb250YWlucyB0aGUgbGlzdCBvZiBlbnRyaWVzIHdoZXJlIHZhbHVlIG9mIHRoZSB0aXRsZSBmaWVsZCBzaG91bGQgbm90IGJlIGVpdGhlciBcIkRlbW9cIiBvciDigJhXZWxjb21l4oCZXG4gICAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAqICAgICAgfSlcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgX3RoaXMubm90Q29udGFpbmVkSW4gPSBfZXh0ZW5kLmNvbnRhaW5lZChmYWxzZSk7XG5cbiAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBleGlzdHNcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZSBlbnRyaWVzIGlmIHZhbHVlIG9mIHRoZSBmaWVsZCwgbWVudGlvbmVkIGluIHRoZSBjb25kaXRpb24sIGV4aXN0cy5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIHVpZCBvZiB0aGUgZmllbGRcbiAgICAgICAgICogQGV4YW1wbGUgYmxvZ1F1ZXJ5LmV4aXN0cygnZmVhdHVyZWQnKVxuICAgICAgICAgKiBAZXhhbXBsZSBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2soKS5Db250ZW50VHlwZSgnZXhhbXBsZScpLlF1ZXJ5KCk7XG4gICAgICAgICAqICAgICAgICAgIGxldCBkYXRhID0gYmxvZ1F1ZXJ5LmV4aXN0cygnZmVhdHVyZWQnKS5maW5kKClcbiAgICAgICAgICogICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgKiAgICAgICAgICAvLyDigJhyZXN1bHTigJkgY29udGFpbnMgdGhlIGxpc3Qgb2YgZW50cmllcyBpbiB3aGljaCBcImZlYXR1cmVkXCIgZXhpc3RzLlxuICAgICAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgKiAgICAgICAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICAgKiAgICAgIH0pXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgIF90aGlzLmV4aXN0cyA9IF9leHRlbmQuZXhpc3RzKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICAgICAqIEBtZXRob2Qgbm90RXhpc3RzXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgZW50cmllcyBpZiB2YWx1ZSBvZiB0aGUgZmllbGQsIG1lbnRpb25lZCBpbiB0aGUgY29uZGl0aW9uLCBkb2VzIG5vdCBleGlzdHMuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB1aWQgb2YgdGhlIGZpZWxkXG4gICAgICAgICAqIEBleGFtcGxlIGJsb2dRdWVyeS5ub3RFeGlzdHMoJ2ZlYXR1cmVkJylcbiAgICAgICAgICogQGV4YW1wbGUgbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5ub3RFeGlzdHMoJ2ZlYXR1cmVkJykuZmluZCgpXG4gICAgICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICogICAgICAgIC8vIHJlc3VsdCBpcyB0aGUgbGlzdCBvZiBub24tZXhpc3RpbmfigJlmZWF0dXJlZOKAmVwiIGRhdGEuXG4gICAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAqICAgICAgfSlcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgX3RoaXMubm90RXhpc3RzID0gX2V4dGVuZC5leGlzdHMoZmFsc2UpO1xuXG4gICAgLyoqXG4gICAgICAgICAqIEBtZXRob2QgYXNjZW5kaW5nXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gU29ydCBmZXRjaGVkIGVudHJpZXMgaW4gdGhlIGFzY2VuZGluZyBvcmRlciB3aXRoIHJlc3BlY3QgdG8gYSBzcGVjaWZpYyBmaWVsZC5cbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIGZpZWxkIHVpZCBiYXNlZCBvbiB3aGljaCB0aGUgb3JkZXJpbmcgd2lsbCBiZSBkb25lXG4gICAgICAgICAqIEBleGFtcGxlIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuYXNjZW5kaW5nKCdjcmVhdGVkX2F0JykuZmluZCgpXG4gICAgICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICogICAgICAgICAgIC8vIOKAmHJlc3VsdOKAmSBjb250YWlucyB0aGUgbGlzdCBvZiBlbnRyaWVzIHdoaWNoIGlzIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgb24gdGhlIGJhc2lzIG9mIOKAmGNyZWF0ZWRfYXTigJkuXG4gICAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAqICAgICAgfSlcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgX3RoaXMuYXNjZW5kaW5nID0gX2V4dGVuZC5zb3J0KCdhc2MnKTtcblxuICAgIC8qKlxuICAgICAgICAgKiBAbWV0aG9kIGRlc2NlbmRpbmdcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBTb3J0IGZldGNoZWQgZW50cmllcyBpbiB0aGUgZGVzY2VuZGluZyBvcmRlciB3aXRoIHJlc3BlY3QgdG8gYSBzcGVjaWZpYyBmaWVsZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IC0gZmllbGQgdWlkIGJhc2VkIG9uIHdoaWNoIHRoZSBvcmRlcmluZyB3aWxsIGJlIGRvbmUuXG4gICAgICAgICAqIEBleGFtcGxlIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuZGVzY2VuZGluZygnY3JlYXRlZF9hdCcpLmZpbmQoKVxuICAgICAgICAgKiAgICAgICAgICBkYXRhLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAqICAgICAgICAgICAvLyDigJhyZXN1bHTigJkgY29udGFpbnMgdGhlIGxpc3Qgb2YgZW50cmllcyB3aGljaCBpcyBzb3J0ZWQgaW4gZGVzY2VuZGluZyBvcmRlciBvbiB0aGUgYmFzaXMgb2Yg4oCYY3JlYXRlZF9hdOKAmS5cbiAgICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAgICogICAgICB9KVxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICBfdGhpcy5kZXNjZW5kaW5nID0gX2V4dGVuZC5zb3J0KCdkZXNjJyk7XG5cbiAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBiZWZvcmVVaWRcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBTb3J0IGZldGNoZWQgZW50cmllcyBpbiB0aGUgZGVzY2VuZGluZyBvcmRlciB3aXRoIHJlc3BlY3QgdG8gYSBzcGVjaWZpYyBmaWVsZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdWlkIC0gZmllbGQgdWlkIGJhc2VkIG9uIHdoaWNoIHRoZSBvcmRlcmluZyB3aWxsIGJlIGRvbmUuXG4gICAgICAgICAqIEBleGFtcGxlIGJsb2dRdWVyeS5iZWZvcmVVaWQoJ3VpZCcpXG4gICAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAgICogQGluc3RhbmNlXG4gICAgICAgICAqL1xuICAgIF90aGlzLmJlZm9yZVVpZCA9IF9leHRlbmQuc29ydCgnYmVmb3JlX3VpZCcpO1xuXG4gICAgLyoqXG4gICAgICAgICAqIEBtZXRob2QgYWZ0ZXJVaWRcbiAgICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIG1ldGhvZCBwcm92aWRlcyBvbmx5IHRoZSBlbnRyaWVzIGFmdGVyIHRoZSBzcGVjaWZpZWQgZW50cnkgaWQuXG4gICAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1aWQgLSB1aWQgb2YgdGhlIGVudHJ5XG4gICAgICAgICAqIEBleGFtcGxlIGJsb2dRdWVyeS5hZnRlclVpZCgndWlkJylcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgX3RoaXMuYWZ0ZXJVaWQgPSBfZXh0ZW5kLnNvcnQoJ2FmdGVyX3VpZCcpO1xuXG4gICAgLyoqXG4gICAgICAgICAqIEBtZXRob2Qgc2tpcFxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFNraXBzIGF0IHNwZWNpZmljIG51bWJlciBvZiBlbnRyaWVzLlxuICAgICAgICAgKiBAcGFyYW0ge051bWJlcn0gc2tpcCAtIG51bWJlciBvZiBlbnRyaWVzIHRvIGJlIHNraXBwZWRcbiAgICAgICAgICogQGV4YW1wbGUgYmxvZ1F1ZXJ5LnNraXAoNSlcbiAgICAgICAgICogQGV4YW1wbGUgbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5za2lwKDUpLmZpbmQoKVxuICAgICAgICAgKiAgICAgICAgICBkYXRhLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAqICAgICAgICAgIC8vIHJlc3VsdCBjb250YWlucyB0aGUgbGlzdCBvZiBkYXRhIHdoaWNoIGlzIHNvcnRlZCBpbiBkZXNjZW5kaW5nIG9yZGVyIG9uICdjcmVhdGVkX2F0JyBiYXNlcy5cbiAgICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAgICogICAgICB9KVxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICBfdGhpcy5za2lwID0gX2V4dGVuZC5wYWdpbmF0aW9uKCdza2lwJyk7XG5cbiAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBsaW1pdFxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBzcGVjaWZpYyBudW1iZXIgb2YgZW50cmllcyBiYXNlZCBvbiB0aGUgc2V0IGxpbWl0XG4gICAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBsaW1pdCAtIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gYmUgcmV0dXJuZWRcbiAgICAgICAgICogQGV4YW1wbGUgbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5saW1pdCgxMCkuZmluZCgpXG4gICAgICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICogICAgICAgICAgLy8gcmVzdWx0IGNvbnRhaW5zIHRoZSBsaW1pdGVkIG51bWJlciBvZiBlbnRyaWVzXG4gICAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgICAqICAgICAgfSlcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgX3RoaXMubGltaXQgPSBfZXh0ZW5kLnBhZ2luYXRpb24oJ2xpbWl0Jyk7XG5cbiAgICAvKipcbiAgICAgICAgICogQG1ldGhvZCBvclxuICAgICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBlbnRyaWVzIHRoYXQgc2F0aXNmeSBhdCBsZWFzdCBvbmUgb2YgdGhlIGdpdmVuIGNvbmRpdGlvbnNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IHF1ZXJpZXMgLSBhcnJheSBvZiBRdWVyeSBvYmplY3RzIG9yIHJhdyBxdWVyaWVzXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIDxjYXB0aW9uPiAub3Igd2l0aCBRdWVyeSBpbnN0YW5jZXM8L2NhcHRpb24+XG4gICAgICAgICAqIGxldCBRdWVyeTEgPSBTdGFjay5Db250ZW50VHlwZSgnYmxvZycpLlF1ZXJ5KCkud2hlcmUoJ3RpdGxlJywgJ0RlbW8nKS5maW5kKClcbiAgICAgICAgICogbGV0IFF1ZXJ5MiA9IFN0YWNrLkNvbnRlbnRUeXBlKCdibG9nJykuUXVlcnkoKS5sZXNzVGhhbignY29tbWVudHMnLCAxMCkuZmluZCgpXG4gICAgICAgICAqIGJsb2dRdWVyeS5vcihRdWVyeTEsIFF1ZXJ5MilcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogPGNhcHRpb24+IC5vciB3aXRoIHJhdyBxdWVyaWVzPC9jYXB0aW9uPlxuICAgICAgICAgKiBsZXQgUXVlcnkxID0gU3RhY2suQ29udGVudFR5cGUoJ2Jsb2cnKS5RdWVyeSgpLndoZXJlKCd0aXRsZScsICdEZW1vJykuZ2V0UXVlcnkoKVxuICAgICAgICAgKiBsZXQgUXVlcnkyID0gU3RhY2suQ29udGVudFR5cGUoJ2Jsb2cnKS5RdWVyeSgpLmxlc3NUaGFuKCdjb21tZW50cycsIDEwKS5nZXRRdWVyeSgpXG4gICAgICAgICAqIGJsb2dRdWVyeS5vcihRdWVyeTEsIFF1ZXJ5MilcbiAgICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAgICovXG4gICAgX3RoaXMub3IgPSBfZXh0ZW5kLmxvZ2ljYWwoJyRvcicpO1xuXG4gICAgLyoqXG4gICAgICAgICAqIEBtZXRob2QgYW5kXG4gICAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgZW50cmllcyB0aGF0IHNhdGlzZnkgYWxsIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcmllcyAtIGFycmF5IG9mIHF1ZXJ5IG9iamVjdHMgb3IgcmF3IHF1ZXJpZXMuXG4gICAgICAgICAqIEBleGFtcGxlXG4gICAgICAgICAqIDxjYXB0aW9uPiAuYW5kIHdpdGggUXVlcnkgaW5zdGFuY2VzPC9jYXB0aW9uPlxuICAgICAgICAgKiBsZXQgUXVlcnkxID0gU3RhY2suQ29udGVudFR5cGUoJ2Jsb2cnKS5RdWVyeSgpLndoZXJlKCd0aXRsZScsICdEZW1vJylcbiAgICAgICAgICogbGV0IFF1ZXJ5MiA9IFN0YWNrLkNvbnRlbnRUeXBlKCdibG9nJykuUXVlcnkoKS5sZXNzVGhhbignY29tbWVudHMnLCAxMClcbiAgICAgICAgICogYmxvZ1F1ZXJ5LmFuZChRdWVyeTEsIFF1ZXJ5MilcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogPGNhcHRpb24+IC5hbmQgd2l0aCByYXcgcXVlcmllczwvY2FwdGlvbj5cbiAgICAgICAgICogbGV0IFF1ZXJ5MSA9IFN0YWNrLkNvbnRlbnRUeXBlKCdibG9nJykuUXVlcnkoKS53aGVyZSgndGl0bGUnLCAnRGVtbycpLmdldFF1ZXJ5KClcbiAgICAgICAgICogbGV0IFF1ZXJ5MiA9IFN0YWNrLkNvbnRlbnRUeXBlKCdibG9nJykuUXVlcnkoKS5sZXNzVGhhbignY29tbWVudHMnLCAxMCkuZ2V0UXVlcnkoKVxuICAgICAgICAgKiBibG9nUXVlcnkuYW5kKFF1ZXJ5MSwgUXVlcnkyKVxuICAgICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICAgKi9cbiAgICBfdGhpcy5hbmQgPSBfZXh0ZW5kLmxvZ2ljYWwoJyRhbmQnKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2luaGVyaXRzKFF1ZXJ5LCBfRW50cnkpO1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFF1ZXJ5LCBbe1xuICAgIGtleTogXCJlcXVhbFRvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVxdWFsVG8oa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9xdWVyeS5xdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsICdLaW5kbHkgcHJvdmlkZSB2YWxpZCBwYXJhbWV0ZXJzLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCB3aGVyZVxuICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgZW50cmllcyBpbiB3aGljaCBhIHNwZWNpZmljIGZpZWxkIHNhdGlzZmllcyB0aGUgdmFsdWUgcHJvdmlkZWRcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgLSB1aWQgb2YgdGhlIGZpZWxkXG4gICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIC0gdmFsdWUgdXNlZCB0byBtYXRjaCBvciBjb21wYXJlXG4gICAgICAgKiBAZXhhbXBsZSBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2soKS5Db250ZW50VHlwZSgnZXhhbXBsZScpLlF1ZXJ5KCk7XG4gICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS53aGVyZSgndGl0bGUnLCdEZW1vJykuZmluZCgpXG4gICAgICAgKiAgICAgICAgICBkYXRhLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgKiAgICAgICAgICAgIC8vIOKAmHJlc3VsdOKAmSBjb250YWlucyB0aGUgbGlzdCBvZiBlbnRyaWVzIHdoZXJlIHZhbHVlIG9mIOKAmHRpdGxl4oCZIGlzIGVxdWFsIHRvIOKAmERlbW/igJkuXG4gICAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqICAgICAgfSlcbiAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwid2hlcmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gd2hlcmUoa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9xdWVyeS5xdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsICdLaW5kbHkgcHJvdmlkZSB2YWxpZCBwYXJhbWV0ZXJzLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBjb3VudFxuICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGVudHJpZXNcbiAgICAgICAqIEBleGFtcGxlIGJsb2dRdWVyeS5jb3VudCgpXG4gICAgICAgKiBAZXhhbXBsZSBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2soKS5Db250ZW50VHlwZSgnZXhhbXBsZScpLlF1ZXJ5KCk7XG4gICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5jb3VudCgpLmZpbmQoKVxuICAgICAgICogICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAgICAgIC8vIOKAmHJlc3VsdOKAmSBjb250YWlucyB0aGUgdG90YWwgY291bnQuXG4gICAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqICAgICAgfSlcbiAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY291bnQoKSB7XG4gICAgICB2YXIgaG9zdCA9IHRoaXMuY29uZmlnLnByb3RvY29sICsgJzovLycgKyB0aGlzLmNvbmZpZy5ob3N0ICsgJzonICsgdGhpcy5jb25maWcucG9ydCArICcvJyArIHRoaXMuY29uZmlnLnZlcnNpb247XG4gICAgICB2YXIgdXJsID0gZ2V0UmVxdWVzdFVybCh0aGlzLnR5cGUsIHRoaXMuY29uZmlnLCB0aGlzLmNvbnRlbnRfdHlwZV91aWQsIGhvc3QpO1xuICAgICAgdGhpcy5fcXVlcnkuY291bnQgPSB0cnVlO1xuICAgICAgdGhpcy5yZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogVXRpbHMubWVyZ2VEZWVwKHt9LCB0aGlzLmhlYWRlcnMpLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIF9tZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIHF1ZXJ5OiB0aGlzLl9xdWVyeVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIHF1ZXJ5XG4gICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZSBlbnRyaWVzIGJhc2VkIG9uIHJhdyBxdWVyaWVzXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gcXVlcnkgLSBSQVcgKEpTT04pIHF1ZXJpZXNcbiAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAqIGxldCBkYXRhID0gYmxvZ1F1ZXJ5LnF1ZXJ5KHtcImJyYW5kXCI6IHtcIiRuaW5fcXVlcnlcIjoge1widGl0bGVcIjogXCJBcHBsZSBJbmMuXCJ9fX0pLmZpbmQoKVxuICAgICAgICogZGF0YS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgLy8g4oCYcmVzdWx04oCZIGNvbnRhaW5zIHRoZSB0b3RhbCBjb3VudC5cbiAgICAgICAqIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgKiAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICogfSlcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInF1ZXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHF1ZXJ5KF9xdWVyeTIpIHtcbiAgICAgIGlmIChfdHlwZW9mKF9xdWVyeTIpID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLl9xdWVyeS5xdWVyeSA9IFV0aWxzLm1lcmdlRGVlcCh0aGlzLl9xdWVyeS5xdWVyeSwgX3F1ZXJ5Mik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsICdLaW5kbHkgcHJvdmlkZSB2YWxpZCBwYXJhbWV0ZXJzJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIHJlZmVyZW5jZUluXG4gICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZSBlbnRyaWVzIHRoYXQgc2F0aXNmeSB0aGUgcXVlcnkgY29uZGl0aW9ucyBtYWRlIG9uIHJlZmVyZW5jZWQgZmllbGRzLlxuICAgICAgICogQHBhcmFtIHtRdWVyeX0gcXVlcnkgLSBSQVcgKEpTT04pIHF1ZXJpZXNcbiAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIDxjYXB0aW9uPiByZWZlcmVuY2VJbiB3aXRoIFF1ZXJ5IGluc3RhbmNlczwvY2FwdGlvbj5cbiAgICAgICAqIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAqIGxldCBRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKCdibG9nJykuUXVlcnkoKS53aGVyZSgndGl0bGUnLCAnRGVtbycpXG4gICAgICAgKiBsZXQgZGF0YSA9IGJsb2dRdWVyeS5yZWZlcmVuY2VJbihcImJyYW5kXCIsIFF1ZXJ5KS5maW5kKClcbiAgICAgICAqIGRhdGEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAqICAgIC8vIOKAmHJlc3VsdOKAmSBjb250YWlucyB0aGUgdG90YWwgY291bnQuXG4gICAgICAgKiB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICogICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqIH0pXG4gICAgICAgKlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIDxjYXB0aW9uPiByZWZlcmVuY2VJbiB3aXRoIHJhdyBxdWVyaWVzPC9jYXB0aW9uPlxuICAgICAgICogbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICogbGV0IGRhdGEgPSBibG9nUXVlcnkucmVmZXJlbmNlSW4oXCJicmFuZFwiLCB7J3RpdGxlJzogJ0RlbW8nfSkuZmluZCgpXG4gICAgICAgKiBkYXRhLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgKiAgICAvLyDigJhyZXN1bHTigJkgY29udGFpbnMgdGhlIHRvdGFsIGNvdW50LlxuICAgICAgICogfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiB9KVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmZXJlbmNlSW5cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVmZXJlbmNlSW4oa2V5LCBxdWVyeSkge1xuICAgICAgdmFyIF9xdWVyeSA9IHt9O1xuICAgICAgaWYgKHF1ZXJ5IGluc3RhbmNlb2YgUXVlcnkgJiYgcXVlcnkuX3F1ZXJ5LnF1ZXJ5KSB7XG4gICAgICAgIF9xdWVyeS4kaW5fcXVlcnkgPSBxdWVyeS5fcXVlcnkucXVlcnk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YocXVlcnkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBfcXVlcnkuJGluX3F1ZXJ5ID0gcXVlcnk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcXVlcnkucXVlcnlba2V5XSkge1xuICAgICAgICB0aGlzLl9xdWVyeS5xdWVyeVtrZXldID0gdGhpcy5fcXVlcnkucXVlcnlba2V5XS5jb25jYXQoX3F1ZXJ5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV0gPSBfcXVlcnk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgcmVmZXJlbmNlTm90SW5cbiAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlIGVudHJpZXMgdGhhdCBkb2VzIG5vdCBzYXRpc2Z5IHRoZSBxdWVyeSBjb25kaXRpb25zIG1hZGUgb24gcmVmZXJlbmNlZCBmaWVsZHMuXG4gICAgICAgKiBAcGFyYW0ge1F1ZXJ5fSBxdWVyeSAtIFJBVyAoSlNPTikgcXVlcmllc1xuICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogPGNhcHRpb24+IHJlZmVyZW5jZU5vdEluIHdpdGggUXVlcnkgaW5zdGFuY2VzPC9jYXB0aW9uPlxuICAgICAgICogbGV0IGJsb2dRdWVyeSA9IFN0YWNrKCkuQ29udGVudFR5cGUoJ2V4YW1wbGUnKS5RdWVyeSgpO1xuICAgICAgICogbGV0IGRhdGEgPSBibG9nUXVlcnkucmVmZXJlbmNlTm90SW4oXCJicmFuZFwiLCB7J3RpdGxlJzogJ0RlbW8nfSkuZmluZCgpXG4gICAgICAgKiBkYXRhLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgKiAgICAvLyDigJhyZXN1bHTigJkgY29udGFpbnMgdGhlIHRvdGFsIGNvdW50LlxuICAgICAgICogfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiB9KVxuICAgICAgICpcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiA8Y2FwdGlvbj4gcmVmZXJlbmNlTm90SW4gd2l0aCByYXcgcXVlcmllczwvY2FwdGlvbj5cbiAgICAgICAqIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAqIGxldCBRdWVyeSA9IFN0YWNrLkNvbnRlbnRUeXBlKCdibG9nJykuUXVlcnkoKS53aGVyZSgndGl0bGUnLCAnRGVtbycpXG4gICAgICAgKiBsZXQgZGF0YSA9IGJsb2dRdWVyeS5yZWZlcmVuY2VOb3RJbihcImJyYW5kXCIsIFF1ZXJ5KS5maW5kKClcbiAgICAgICAqIGRhdGEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAqICAgIC8vIOKAmHJlc3VsdOKAmSBjb250YWlucyB0aGUgdG90YWwgY291bnQuXG4gICAgICAgKiB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICogICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqIH0pXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWZlcmVuY2VOb3RJblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZlcmVuY2VOb3RJbihrZXksIHF1ZXJ5KSB7XG4gICAgICB2YXIgX3F1ZXJ5ID0ge307XG4gICAgICBpZiAocXVlcnkgaW5zdGFuY2VvZiBRdWVyeSAmJiBxdWVyeS5fcXVlcnkucXVlcnkpIHtcbiAgICAgICAgX3F1ZXJ5LiRuaW5fcXVlcnkgPSBxdWVyeS5fcXVlcnkucXVlcnk7XG4gICAgICB9IGVsc2UgaWYgKF90eXBlb2YocXVlcnkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICBfcXVlcnkuJG5pbl9xdWVyeSA9IHF1ZXJ5O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV0pIHtcbiAgICAgICAgdGhpcy5fcXVlcnkucXVlcnlba2V5XSA9IHRoaXMuX3F1ZXJ5LnF1ZXJ5W2tleV0uY29uY2F0KF9xdWVyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWVyeS5xdWVyeVtrZXldID0gX3F1ZXJ5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIHRhZ3NcbiAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBlbnRyaWVzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0YWdzXG4gICAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgLSB0YWdzXG4gICAgICAgKiBAZXhhbXBsZSBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2soKS5Db250ZW50VHlwZSgnZXhhbXBsZScpLlF1ZXJ5KCk7XG4gICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS50YWdzKFsndGVjaG5vbG9neScsICdidXNpbmVzcyddKS5maW5kKClcbiAgICAgICAqICAgICAgICAgIGRhdGEudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAqICAgICAgICAvLyDigJhyZXN1bHTigJkgY29udGFpbnMgbGlzdCBvZiBlbnRyaWVzIHdoaWNoIGhhdmUgdGFncyBcIuKAmXRlY2hub2xvZ3nigJlcIiBhbmQg4oCYXCJidXNpbmVzc+KAmVwiLlxuICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRhZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdGFncyh2YWx1ZXMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgdGhpcy5fcXVlcnkudGFncyA9IHZhbHVlcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZXRjaE9wdGlvbnMuZGVidWcpIHRoaXMuZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywgJ0tpbmRseSBwcm92aWRlIHZhbGlkIHBhcmFtZXRlcnMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgaW5jbHVkZVJlZmVyZW5jZUNvbnRlbnRUeXBlVWlkXG4gICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiAgVGhpcyBtZXRob2QgYWxzbyBpbmNsdWRlcyB0aGUgY29udGVudCB0eXBlIFVJRHMgb2YgdGhlIHJlZmVyZW5jZWQgZW50cmllcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICAgKiBAZXhhbXBsZSBTdGFjay5Db250ZW50VHlwZShcImNvbnRlbnRUeXBlX3VpZFwiKS5RdWVyeSgpLmluY2x1ZGVSZWZlcmVuY2VDb250ZW50VHlwZVVJRCgpLmZpbmQoKVxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGxldCBibG9nUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZShcImNvbnRlbnRUeXBlX3VpZFwiKS5RdWVyeSgpO1xuICAgICAgICogICAgICAgICAgbGV0IGRhdGEgPSBibG9nUXVlcnkuaW5jbHVkZVJlZmVyZW5jZUNvbnRlbnRUeXBlVUlEKCkuZmluZCgpXG4gICAgICAgKiAgICAgICAgICBkYXRhLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgKiAgICAgICAgIC8vIOKAmHJlc3VsdOKAmSBjb250YWlucyBhIGxpc3Qgb2YgZW50cmllcyBpbiB3aGljaCBjb250ZW50IHR5cGUgVUlEcyBpcyBwcmVzZW50LlxuICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImluY2x1ZGVSZWZlcmVuY2VDb250ZW50VHlwZVVJRFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbmNsdWRlUmVmZXJlbmNlQ29udGVudFR5cGVVSUQoKSB7XG4gICAgICB0aGlzLl9xdWVyeS5pbmNsdWRlX3JlZmVyZW5jZV9jb250ZW50X3R5cGVfdWlkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBpbmNsdWRlQ291bnRcbiAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIEluY2x1ZGVzIHRoZSB0b3RhbCBudW1iZXIgb2YgZW50cmllcyByZXR1cm5lZCBpbiB0aGUgcmVzcG9uc2UuXG4gICAgICAgKiBAZXhhbXBsZSBibG9nUXVlcnkuaW5jbHVkZUNvdW50KClcbiAgICAgICAqIEBleGFtcGxlIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKTtcbiAgICAgICAqICAgICAgICAgIGxldCBkYXRhID0gYmxvZ1F1ZXJ5LmluY2x1ZGVDb3VudCgpLmZpbmQoKVxuICAgICAgICogICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAgICAvLyDigJhyZXN1bHTigJkgY29udGFpbnMgYSBsaXN0IG9mIGVudHJpZXMgaW4gd2hpY2ggY291bnQgb2Ygb2JqZWN0IGlzIHByZXNlbnQgYXQgYXJyYXlbMV0gcG9zaXRpb24uXG4gICAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqICAgICAgfSlcbiAgICAgICAqIEByZXR1cm5zIHtRdWVyeX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaW5jbHVkZUNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluY2x1ZGVDb3VudCgpIHtcbiAgICAgIHRoaXMuX3F1ZXJ5LmluY2x1ZGVfY291bnQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGFkZFBhcmFtXG4gICAgICAgKiBAZGVzY3JpcHRpb24gSW5jbHVkZXMgcXVlcnkgcGFyYW1ldGVycyBpbiB5b3VyIHF1ZXJpZXMuXG4gICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAqIEBleGFtcGxlIHZhciBkYXRhID0gYmxvZ1F1ZXJ5LmFkZFBhcmFtKCdpbmNsdWRlX2NvdW50JywgJ3RydWUnKS5mZXRjaCgpXG4gICAgICAgKiAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgKiAgICAgICAgICAvLyAncmVzdWx0JyBpcyBhbiBvYmplY3Qgd2hpY2ggY29udGVudCB0aGUgZGF0YSBpbmNsdWRpbmcgY291bnQgaW4ganNvbiBvYmplY3QgZm9ybVxuICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZFBhcmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFBhcmFtKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChrZXkgJiYgdmFsdWUgJiYgdHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9xdWVyeVtrZXldID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsICdLaW5kbHkgcHJvdmlkZSB2YWxpZCBwYXJhbWV0ZXJzLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBnZXRRdWVyeVxuICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgcmF3IChKU09OKSBxdWVyeSBiYXNlZCBvbiB0aGUgZmlsdGVycyBhcHBsaWVkIG9uIFF1ZXJ5IG9iamVjdC5cbiAgICAgICAqIEBleGFtcGxlIFN0YWNrLkNvbnRlbnRUeXBlKCdjb250ZW50VHlwZV91aWQnKS5RdWVyeSgpLndoZXJlKCd0aXRsZScsJ0RlbW8nKS5nZXRRdWVyeSgpLmZpbmQoKVxuICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRRdWVyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRRdWVyeSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9xdWVyeS5xdWVyeSB8fCB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgcmVnZXhcbiAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlIGVudHJpZXMgdGhhdCBtYXRjaCB0aGUgcHJvdmlkZWQgcmVndWxhciBleHByZXNzaW9uc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSAtIHVpZCBvZiB0aGUgZmllbGRcbiAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSB2YWx1ZSB1c2VkIHRvIG1hdGNoIG9yIGNvbXBhcmVcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9uc10gLSBtYXRjaCBvciBjb21wYXJlIHZhbHVlIGluIGVudHJ5XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogPGNhcHRpb24+IC5yZWdleCB3aXRob3V0IG9wdGlvbnM8L2NhcHRpb24+XG4gICAgICAgKiBibG9nUXVlcnkucmVnZXgoJ3RpdGxlJywnXkRlbW8nKVxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIDxjYXB0aW9uPiAucmVnZXggd2l0aCBvcHRpb25zPC9jYXB0aW9uPlxuICAgICAgICogYmxvZ1F1ZXJ5LnJlZ2V4KCd0aXRsZScsJ15EZW1vJywgJ2knKVxuICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZWdleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWdleChrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5ICYmIHZhbHVlICYmIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5fcXVlcnkucXVlcnlba2V5XSA9IHtcbiAgICAgICAgICAkcmVnZXg6IHZhbHVlXG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zKSB0aGlzLl9xdWVyeS5xdWVyeVtrZXldLiRvcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZXRjaE9wdGlvbnMuZGVidWcpIHRoaXMuZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywgJ0tpbmRseSBwcm92aWRlIHZhbGlkIHBhcmFtZXRlcnMuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIHNlYXJjaFxuICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMTUuMFxuICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlIGVudHJpZXMgdGhhdCBoYXZlIGZpZWxkcyB3aGljaCBtYXRjaCB0aGUgcHJvdmlkZWQgc2VhcmNoIHZhbHVlLlxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIC0gdmFsdWUgdG8gc2VhcmNoIGluIGVudHJpZXNcbiAgICAgICAqIEBleGFtcGxlIGJsb2dRdWVyeS5zZWFyY2goJ1dlbGNvbWUgdG8gZGVtbycpXG4gICAgICAgKiBAZXhhbXBsZSBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2soKS5Db250ZW50VHlwZSgnZXhhbXBsZScpLlF1ZXJ5KCk7XG4gICAgICAgKiAgICAgICAgICBsZXQgZGF0YSA9IGJsb2dRdWVyeS5zZWFyY2goJ3dlbGNvbWUgdG8gZGVtbycpLmZpbmQoKVxuICAgICAgICogICAgICAgICAgZGF0YS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAgICAvLyDigJhyZXN1bHTigJkgY29udGFpbnMgdGhlIG9iamVjdCB0aGF0IHBvc3Nlc3MgdGhlIHRleHQgXCLigJl3ZWxjb21lIHRvIGRlbW/igJlcIi5cbiAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgKiAgICAgICAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICogICAgICB9KVxuICAgICAgICogQHJldHVybnMge1F1ZXJ5fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZWFyY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VhcmNoKHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICB0aGlzLl9xdWVyeS50eXBlYWhlYWQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZXRjaE9wdGlvbnMuZGVidWcpIHRoaXMuZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywgJ0tpbmRseSBwcm92aWRlIHZhbGlkIHBhcmFtZXRlcnMuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGZpbmRcbiAgICAgICAqIEBtZW1iZXJPZiBRdWVyeVxuICAgICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBlbnRyaWVzIHRoYXQgc2F0aXNmaWVkIHRoZSBzcGVjaWZpZWQgcXVlcnlcbiAgICAgICAqIEBleGFtcGxlIGxldCBibG9nUXVlcnkgPSBTdGFjaygpLkNvbnRlbnRUeXBlKCdleGFtcGxlJykuUXVlcnkoKS5maW5kKCk7XG4gICAgICAgKiAgICAgICAgICBibG9nUXVlcnkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAqICAgICAgICAgIC8vIHJlc3VsdCBjb250YWlucyB0aGUgbGlzdCBvZiBvYmplY3QuXG4gICAgICAgKiAgICAgICB9LGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICogICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqICAgICAgfSlcbiAgICAgICAqIGJsb2dRdWVyeS5maW5kKClcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2suQ29udGVudFR5cGUoY29udGVudFR5cGVVaWQpLlF1ZXJ5KCkuZmluZCh7XG4gICAgICAgKlxuICAgICAgICogICAgICB9KTtcbiAgICAgICAqIGJsb2dRdWVyeS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAgICAgLy8gcmVzdWx0IGNvbnRhaW5zIHRoZSBsaXN0IG9mIG9iamVjdC5cbiAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgKiAgICAgICAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICogICAgICB9KVxuICAgICAgICogYmxvZ1F1ZXJ5LmZpbmQoKVxuICAgICAgICogQHJldHVybnMge3Byb21pc2V9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpbmRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZChmZXRjaE9wdGlvbnMpIHtcbiAgICAgIHZhciBob3N0ID0gdGhpcy5jb25maWcuaG9zdCArICc6JyArIHRoaXMuY29uZmlnLnBvcnQ7XG4gICAgICBpZiAodGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gJ2Fzc2V0JyAmJiB0aGlzLmxpdmVfcHJldmlldyAmJiB0aGlzLmxpdmVfcHJldmlldy5lbmFibGUgPT09IHRydWUgJiYgdGhpcy5saXZlX3ByZXZpZXcubGl2ZV9wcmV2aWV3ICYmIHRoaXMubGl2ZV9wcmV2aWV3LmxpdmVfcHJldmlldyAhPT0gJ2luaXQnKSB7XG4gICAgICAgIGhvc3QgPSB0aGlzLmxpdmVfcHJldmlldy5ob3N0O1xuICAgICAgfVxuICAgICAgdmFyIGJhc2VVUkwgPSB0aGlzLmNvbmZpZy5wcm90b2NvbCArICc6Ly8nICsgaG9zdCArICcvJyArIHRoaXMuY29uZmlnLnZlcnNpb247XG4gICAgICB2YXIgdXJsID0gZ2V0UmVxdWVzdFVybCh0aGlzLnR5cGUsIHRoaXMuY29uZmlnLCB0aGlzLmNvbnRlbnRfdHlwZV91aWQsIGJhc2VVUkwpO1xuICAgICAgdGhpcy5yZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogVXRpbHMubWVyZ2VEZWVwKHt9LCB0aGlzLmhlYWRlcnMpLFxuICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIF9tZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIHF1ZXJ5OiB0aGlzLl9xdWVyeVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIG9wdGlvbnMgPSBVdGlscy5tZXJnZURlZXAodGhpcy5mZXRjaE9wdGlvbnMsIGZldGNoT3B0aW9ucyk7XG4gICAgICByZXR1cm4gVXRpbHMuc2VuZFJlcXVlc3QoVXRpbHMubWVyZ2VEZWVwKHt9LCB0aGlzKSwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIFZhcmlhbnRzXG4gICAgICAgKiBAbWVtYmVyT2YgUXVlcnlcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1aWQgLSB1aWQgb2YgdGhlIHZhcmlhbnRzIGVudHJ5XG4gICAgICAgKiBAZGVzY3JpcHRpb24gQW4gaW5pdGlhbGl6ZXIgaXMgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIFZhcmlhbnRzIEVudHJ5IG9iamVjdFxuICAgICAgICogQHJldHVybnMge1ZhcmlhbnRzfVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ2YXJpYW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YXJpYW50cyh2YXJpYW50X2hlYWRlcnMpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhcmlhbnRfaGVhZGVycykgJiYgdmFyaWFudF9oZWFkZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWyd4LWNzLXZhcmlhbnQtdWlkJ10gPSB2YXJpYW50X2hlYWRlcnMuam9pbignLCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWyd4LWNzLXZhcmlhbnQtdWlkJ10gPSB2YXJpYW50X2hlYWRlcnM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgZmluZE9uZVxuICAgICAgICogQG1lbWJlck9mIFF1ZXJ5XG4gICAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDMuMy4wXG4gICAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgYSBzaW5nbGUgZW50cnkgZnJvbSB0aGUgcmVzdWx0XG4gICAgICAgKiBAZXhhbXBsZSBsZXQgYmxvZ1F1ZXJ5ID0gU3RhY2soKS5Db250ZW50VHlwZSgnZXhhbXBsZScpLlF1ZXJ5KCkuZmluZE9uZSgpO1xuICAgICAgICogICAgICAgICAgYmxvZ1F1ZXJ5LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgKiAgICAgICAgICAvLyByZXN1bHQgY29udGFpbnMgdGhlIHNpbmdsZSBpdGVtIG9iamVjdC5cbiAgICAgICAqICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgKiAgICAgICAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICogICAgICB9KVxuICAgICAgICogYmxvZ1F1ZXJ5LmZpbmRPbmUoKVxuICAgICAgICogQHJldHVybnMge3Byb21pc2V9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZpbmRPbmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmluZE9uZSgpIHtcbiAgICAgIHZhciBob3N0ID0gdGhpcy5jb25maWcucHJvdG9jb2wgKyAnOi8vJyArIHRoaXMuY29uZmlnLmhvc3QgKyAnOicgKyB0aGlzLmNvbmZpZy5wb3J0ICsgJy8nICsgdGhpcy5jb25maWcudmVyc2lvbjtcbiAgICAgIGlmICh0aGlzLnR5cGUgJiYgdGhpcy50eXBlICE9PSAnYXNzZXQnICYmIHRoaXMubGl2ZV9wcmV2aWV3ICYmIHRoaXMubGl2ZV9wcmV2aWV3LmVuYWJsZSA9PT0gdHJ1ZSAmJiB0aGlzLmxpdmVfcHJldmlldy5saXZlX3ByZXZpZXcgJiYgdGhpcy5saXZlX3ByZXZpZXcubGl2ZV9wcmV2aWV3ICE9PSAnaW5pdCcpIHtcbiAgICAgICAgaG9zdCA9IHRoaXMuY29uZmlnLnByb3RvY29sICsgJzovLycgKyB0aGlzLmxpdmVfcHJldmlldy5ob3N0ICsgJy8nICsgdGhpcy5jb25maWcudmVyc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciB1cmwgPSBnZXRSZXF1ZXN0VXJsKHRoaXMudHlwZSwgdGhpcy5jb25maWcsIHRoaXMuY29udGVudF90eXBlX3VpZCwgaG9zdCk7XG4gICAgICB0aGlzLnNpbmdsZUVudHJ5ID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3F1ZXJ5LmxpbWl0ID0gMTtcbiAgICAgIHRoaXMucmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IFV0aWxzLm1lcmdlRGVlcCh7fSwgdGhpcy5oZWFkZXJzKSxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBfbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBxdWVyeTogdGhpcy5fcXVlcnlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBvcHRpb25zID0gVXRpbHMubWVyZ2VEZWVwKHt9LCB0aGlzLmZldGNoT3B0aW9ucyk7XG4gICAgICByZXR1cm4gVXRpbHMuc2VuZFJlcXVlc3QoVXRpbHMubWVyZ2VEZWVwKHt9LCB0aGlzKSwgb3B0aW9ucylbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgLy8gQWRkIEhUVFAgc3RhdHVzIGNvZGUgdG8gdGhlIGVycm9yIG9iamVjdCBpZiBpdCBleGlzdHNcbiAgICAgICAgaWYgKGVycm9yLnN0YXR1cykge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGVycm9yKSwge30sIHtcbiAgICAgICAgICAgIGh0dHBfY29kZTogZXJyb3Iuc3RhdHVzLFxuICAgICAgICAgICAgLy8gQWRkaW5nIHRoZSBIVFRQIHN0YXR1cyBjb2RlIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIGh0dHBfbWVzc2FnZTogZXJyb3Iuc3RhdHVzVGV4dCB8fCAnQW4gZXJyb3Igb2NjdXJyZWQnXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7IC8vIEZhbGxiYWNrIGZvciBvdGhlciBlcnJvcnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xufShfZW50cnlbXCJkZWZhdWx0XCJdKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDM0ODpcbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xudmFyIF9jb25maWcgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjQxKSk7XG52YXIgVXRpbHMgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKDkyNSkpO1xudmFyIF9lbnRyeSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0MikpO1xudmFyIF9hc3NldHMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTM3KSk7XG52YXIgX3F1ZXJ5ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMxOCkpO1xudmFyIF90YXhvbm9teSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNzUpKTtcbnZhciBfcmVxdWVzdCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxODUpKTtcbnZhciBfaW5kZXggPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjg1KSk7XG52YXIgX21lc3NhZ2VzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NCkpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQoZSwgdCkge1xuICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBXZWFrTWFwKSB2YXIgciA9IG5ldyBXZWFrTWFwKCksXG4gICAgbiA9IG5ldyBXZWFrTWFwKCk7XG4gIHJldHVybiAoX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQgPSBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7XG4gICAgaWYgKCF0ICYmIGUgJiYgZS5fX2VzTW9kdWxlKSByZXR1cm4gZTtcbiAgICB2YXIgbyxcbiAgICAgIGksXG4gICAgICBmID0ge1xuICAgICAgICBfX3Byb3RvX186IG51bGwsXG4gICAgICAgIFwiZGVmYXVsdFwiOiBlXG4gICAgICB9O1xuICAgIGlmIChudWxsID09PSBlIHx8IFwib2JqZWN0XCIgIT0gX3R5cGVvZihlKSAmJiBcImZ1bmN0aW9uXCIgIT0gdHlwZW9mIGUpIHJldHVybiBmO1xuICAgIGlmIChvID0gdCA/IG4gOiByKSB7XG4gICAgICBpZiAoby5oYXMoZSkpIHJldHVybiBvLmdldChlKTtcbiAgICAgIG8uc2V0KGUsIGYpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfdCBpbiBlKSBcImRlZmF1bHRcIiAhPT0gX3QgJiYge30uaGFzT3duUHJvcGVydHkuY2FsbChlLCBfdCkgJiYgKChpID0gKG8gPSBPYmplY3QuZGVmaW5lUHJvcGVydHkpICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgX3QpKSAmJiAoaS5nZXQgfHwgaS5zZXQpID8gbyhmLCBfdCwgaSkgOiBmW190XSA9IGVbX3RdKTtcbiAgICByZXR1cm4gZjtcbiAgfSkoZSwgdCk7XG59XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICBcImRlZmF1bHRcIjogZVxuICB9O1xufVxuZnVuY3Rpb24gX3R5cGVvZihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvO1xuICB9IDogZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbztcbiAgfSwgX3R5cGVvZihvKTtcbn1cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhhLCBuKSB7XG4gIGlmICghKGEgaW5zdGFuY2VvZiBuKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHIpIHtcbiAgZm9yICh2YXIgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKSB7XG4gICAgdmFyIG8gPSByW3RdO1xuICAgIG8uZW51bWVyYWJsZSA9IG8uZW51bWVyYWJsZSB8fCAhMSwgby5jb25maWd1cmFibGUgPSAhMCwgXCJ2YWx1ZVwiIGluIG8gJiYgKG8ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBfdG9Qcm9wZXJ0eUtleShvLmtleSksIG8pO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoZSwgciwgdCkge1xuICByZXR1cm4gciAmJiBfZGVmaW5lUHJvcGVydGllcyhlLnByb3RvdHlwZSwgciksIHQgJiYgX2RlZmluZVByb3BlcnRpZXMoZSwgdCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6ICExXG4gIH0pLCBlO1xufVxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkodCkge1xuICB2YXIgaSA9IF90b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gX3R5cGVvZihpKSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YodCkgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IF90eXBlb2YoaSkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxudmFyIGVycm9yUmV0cnkgPSBbNDA4LCA0MjldO1xuXG4vKipcbiAgICAgKiBAY2xhc3NcbiAgICAgICAgU3RhY2tcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZSBhbiBpbnN0YW5jZSBvZiDigJhTdGFja+KAmVxuICAgICAqIEBwYXJhbSBwYXJhbSAtIFN0YWNrIGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHBhcmFtLmFwaV9rZXkgLSBTdGFjayBBUEkgS2V5LlxuICAgICAqIEBwYXJhbSBwYXJhbS5kZWxpdmVyeV90b2tlbiAtIFN0YWNrIERlbGl2ZXJ5IHRva2VuLlxuICAgICAqIEBwYXJhbSBwYXJhbS5lbnZpcm9ubWVudCAtIFN0YWNrIEVudmlyb25tZW50IG5hbWUuXG4gICAgICogQHBhcmFtIHBhcmFtLnJlZ2lvbiAtIERCIHJlZ2lvbiBmb3IgU3RhY2suXG4gICAgICogQHBhcmFtIHBhcmFtLmJyYW5jaCAtIE5hbWUgb2YgdGhlIGJyYW5jaCB5b3Ugd2FudCB0byBmZXRjaCBkYXRhIGZyb21cbiAgICAgKiBAcGFyYW0gcGFyYW0ubGl2ZV9wcmV2aWV3IC0gTGl2ZSBwcmV2aWV3IGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHBhcmFtIHBhcmFtLnBsdWdpbnMgLSBMaXN0IG9mIHBsdWdpbnMgb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0gcGFyYW0uZmV0Y2hPcHRpb25zIC0gQ3VzdG9tIHNldHRpbmcgZm9yIHRoZSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBwYXJhbS5mZXRjaE9wdGlvbnMuZGVidWcgLSBUaGlzIHdpbGwgZW5hYmxlIGRlYnVnIGxvZy4gRGVmYXVsdCBpcyBmYWxzZVxuICAgICAqIEBwYXJhbSBwYXJhbS5mZXRjaE9wdGlvbnMudGltZW91dCAtIFNldCB0aW1lb3V0IGZvciB0aGUgcmVxdWVzdC5cbiAgICAgKiBAcGFyYW0gcGFyYW0uZmV0Y2hPcHRpb25zLnJldHJ5TGltaXQgLSBUaGUgbnVtYmVyIG9mIHJldHJpZXMgYmVmb3JlIGZhaWx1cmUuIERlZmF1bHQgaXMgNVxuICAgICAqIEBwYXJhbSBwYXJhbS5mZXRjaE9wdGlvbnMucmV0cnlEZWxheSAtIFRoZSBudW1iZXIgb2YgbXMgdG8gdXNlIGZvciBvcGVyYXRpb24gcmV0cmllcy4gRGVmYXVsdCBpcyAzMDBtc1xuICAgICAqIEBwYXJhbSBwYXJhbS5mZXRjaE9wdGlvbnMucmV0cnlDb25kaXRpb24gLSBBIGZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IgY2FuIGJlIHJldHJpZWQuIERlZmF1bHQgcmV0cnkgaXMgb24gc3RhdHVzIGNvZGVzIDQwOCwgNDI5LlxuICAgICAqIEBwYXJhbSBwYXJhbS5mZXRjaE9wdGlvbnMucmV0cnlEZWxheU9wdGlvbnMuYmFzZSAtIFRoZSBiYXNlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gdXNlIGluIHRoZSBleHBvbmVudGlhbCBiYWNrb2ZmIGZvciBvcGVyYXRpb24gcmV0cmllcy5cbiAgICAgKiBAcGFyYW0gcGFyYW0uZmV0Y2hPcHRpb25zLnJldHJ5RGVsYXlPcHRpb25zLmN1c3RvbUJhY2tvZmYgLSBBIGN1c3RvbSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYSByZXRyeSBjb3VudCBhbmQgZXJyb3IgYW5kIHJldHVybnMgdGhlIGFtb3VudCBvZiB0aW1lIHRvIGRlbGF5IGluIG1pbGxpc2Vjb25kcy5cbiAgICAgKiBAcGFyYW0gcGFyYW0uZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIgLSBBIGZ1bmN0aW9uIGZvciBsb2dnaW5nIG9mIHJlcXVlc3RzLCByZXNwb25zZXMgYW5kIGVycm9yc1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgU3RhY2sgPSBDb250ZW50c3RhY2suU3RhY2soe1xuICAgICAqICAgICAgJ2FwaV9rZXknOidhcGlfa2V5JyxcbiAgICAgKiAgICAgICdkZWxpdmVyeV90b2tlbic6J2RlbGl2ZXJ5X3Rva2VuJyxcbiAgICAgKiAgICAgICdlbnZpcm9ubWVudCc6J2Vudmlyb25tZW50X25hbWUnLFxuICAgICAqICAgICAgJ3JlZ2lvbic6ICd1cycsXG4gICAgICogICAgICAnZmV0Y2hPcHRpb25zJzoge1xuICAgICAqXG4gICAgICogICAgICB9XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RhY2t9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG52YXIgU3RhY2sgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YWNrKTtcbiAgICB0aGlzLmZldGNoT3B0aW9ucyA9IHtcbiAgICAgIHJldHJ5TGltaXQ6IDUsXG4gICAgICByZXRyeUNvbmRpdGlvbjogZnVuY3Rpb24gcmV0cnlDb25kaXRpb24oZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yUmV0cnkuaW5jbHVkZXMoZXJyb3Iuc3RhdHVzKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICBsb2dIYW5kbGVyOiBmdW5jdGlvbiBsb2dIYW5kbGVyKGxldmVsLCBkYXRhKSB7XG4gICAgICAgIGlmIChsZXZlbCA9PT0gJ2Vycm9yJyAmJiBkYXRhKSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yOiBcIi5jb25jYXQoZGF0YSkpO1xuICAgICAgICB9IGVsc2UgaWYgKGxldmVsID09PSAnd2FybmluZycgJiYgZGF0YSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIldhcm5pbmc6IFwiLmNvbmNhdChkYXRhKSk7XG4gICAgICAgIH0gZWxzZSBpZiAobGV2ZWwgPT09ICdpbmZvJyAmJiBkYXRhKSB7XG4gICAgICAgICAgY29uc29sZS5pbmZvKFwiSW5mbzogXCIuY29uY2F0KGRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5jb25maWcgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KF9jb25maWdbXCJkZWZhdWx0XCJdKSk7XG4gICAgdGhpcy5wbHVnaW5zID0gW107XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0YWNrX2FyZ3VtZW50cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIHN0YWNrX2FyZ3VtZW50c1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG4gICAgaWYgKHN0YWNrX2FyZ3VtZW50c1swXS5saXZlX3ByZXZpZXcgJiYgc3RhY2tfYXJndW1lbnRzWzBdLmxpdmVfcHJldmlldy5lbmFibGUgPT09IHRydWUgJiYgc3RhY2tfYXJndW1lbnRzWzBdLmxpdmVfcHJldmlldy5tYW5hZ2VtZW50X3Rva2VuICE9PSBudWxsKSB7XG4gICAgICBpZiAoc3RhY2tfYXJndW1lbnRzWzBdLmxpdmVfcHJldmlldy5tYW5hZ2VtZW50X3Rva2VuKSB7XG4gICAgICAgIHRoaXMuY29uZmlnLmxpdmVfcHJldmlldy5ob3N0ID0gJ2FwaS5jb250ZW50c3RhY2suaW8nO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2tfYXJndW1lbnRzWzBdLnJlZ2lvbiAmJiBzdGFja19hcmd1bWVudHNbMF0ucmVnaW9uICE9PSB1bmRlZmluZWQgJiYgc3RhY2tfYXJndW1lbnRzWzBdLnJlZ2lvbiAhPT0gJ3VzJykge1xuICAgICAgdGhpcy5jb25maWcuaG9zdCA9IHN0YWNrX2FyZ3VtZW50c1swXS5yZWdpb24gKyAnLScgKyAnY2RuLmNvbnRlbnRzdGFjay5jb20nO1xuICAgICAgaWYgKHN0YWNrX2FyZ3VtZW50c1swXS5saXZlX3ByZXZpZXcgJiYgc3RhY2tfYXJndW1lbnRzWzBdLmxpdmVfcHJldmlldy5lbmFibGUgPT09IHRydWUpIHtcbiAgICAgICAgaWYgKHN0YWNrX2FyZ3VtZW50c1swXS5saXZlX3ByZXZpZXcubWFuYWdlbWVudF90b2tlbikge1xuICAgICAgICAgIHRoaXMuY29uZmlnLmxpdmVfcHJldmlldy5ob3N0ID0gc3RhY2tfYXJndW1lbnRzWzBdLnJlZ2lvbiArICctJyArICdhcGkuY29udGVudHN0YWNrLmNvbSc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5jb25maWcubGl2ZV9wcmV2aWV3Lmhvc3QgPSBzdGFja19hcmd1bWVudHNbMF0ucmVnaW9uICsgJy0nICsgJ3Jlc3QtcHJldmlldy5jb250ZW50c3RhY2suY29tJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhY2tfYXJndW1lbnRzWzBdLmZldGNoT3B0aW9ucyAmJiBzdGFja19hcmd1bWVudHNbMF0uZmV0Y2hPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZmV0Y2hPcHRpb25zID0gVXRpbHMubWVyZ2VEZWVwKHRoaXMuZmV0Y2hPcHRpb25zLCBzdGFja19hcmd1bWVudHNbMF0uZmV0Y2hPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHN0YWNrX2FyZ3VtZW50c1swXS5wbHVnaW5zICYmIHN0YWNrX2FyZ3VtZW50c1swXS5wbHVnaW5zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0YWNrX2FyZ3VtZW50c1swXS5wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbk9iaikge1xuICAgICAgICBfdGhpcy5wbHVnaW5zLnB1c2gocGx1Z2luT2JqKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlUG9saWN5ID0gX2luZGV4W1wiZGVmYXVsdFwiXS5wb2xpY2llcy5JR05PUkVfQ0FDSEU7XG4gICAgdGhpcy5wcm92aWRlciA9IF9pbmRleFtcImRlZmF1bHRcIl0ucHJvdmlkZXJzKCdsb2NhbHN0b3JhZ2UnKTtcbiAgICBzd2l0Y2ggKHN0YWNrX2FyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKF90eXBlb2Yoc3RhY2tfYXJndW1lbnRzWzBdKSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHN0YWNrX2FyZ3VtZW50c1swXS5hcGlfa2V5ID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzBdLmRlbGl2ZXJ5X3Rva2VuID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzBdLmVudmlyb25tZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgIGFwaV9rZXk6IHN0YWNrX2FyZ3VtZW50c1swXS5hcGlfa2V5LFxuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdGFja19hcmd1bWVudHNbMF0uZGVsaXZlcnlfdG9rZW5cbiAgICAgICAgICB9O1xuICAgICAgICAgIGlmIChfdHlwZW9mKHN0YWNrX2FyZ3VtZW50c1swXS5saXZlX3ByZXZpZXcpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5saXZlX3ByZXZpZXcgPSBVdGlscy5tZXJnZURlZXAodGhpcy5jb25maWcubGl2ZV9wcmV2aWV3LCBzdGFja19hcmd1bWVudHNbMF0ubGl2ZV9wcmV2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuc2V0TGl2ZVByZXZpZXdUaW1lbGluZVByZXZpZXdGb3JDbGllbnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdGFja19hcmd1bWVudHNbMF0uYnJhbmNoID09PSAnc3RyaW5nJyAmJiBzdGFja19hcmd1bWVudHNbMF0uYnJhbmNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5icmFuY2ggPSBzdGFja19hcmd1bWVudHNbMF0uYnJhbmNoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3R5cGVvZihzdGFja19hcmd1bWVudHNbMF0uZWFybHlfYWNjZXNzKSA9PT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheShzdGFja19hcmd1bWVudHNbMF0uZWFybHlfYWNjZXNzKSAmJiBzdGFja19hcmd1bWVudHNbMF0uZWFybHlfYWNjZXNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVyc1sneC1oZWFkZXItZWEnXSA9IHN0YWNrX2FyZ3VtZW50c1swXS5lYXJseV9hY2Nlc3Muam9pbignLCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVudmlyb25tZW50ID0gc3RhY2tfYXJndW1lbnRzWzBdLmVudmlyb25tZW50O1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLlNUQUNLX0lOVkFMSURfUEFSQU1TX09CSkVDVCk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCd3YXJuaW5nJywgX21lc3NhZ2VzW1wiZGVmYXVsdFwiXS5TVEFDS19PQlNPTEVURV9GVU5DVElPTik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzFdID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzJdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgIGFwaV9rZXk6IHN0YWNrX2FyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3RhY2tfYXJndW1lbnRzWzFdXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmVudmlyb25tZW50ID0gc3RhY2tfYXJndW1lbnRzWzJdO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLlNUQUNLX0lOVkFMSURfUEFSQU1TX1NUUklORyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgNDpcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCd3YXJuaW5nJywgX21lc3NhZ2VzW1wiZGVmYXVsdFwiXS5TVEFDS19PQlNPTEVURV9GVU5DVElPTik7XG4gICAgICAgIGlmICh0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzFdID09PSAnc3RyaW5nJyAmJiB0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzJdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRoaXMuaGVhZGVycyA9IHtcbiAgICAgICAgICAgIGFwaV9rZXk6IHN0YWNrX2FyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGFjY2Vzc190b2tlbjogc3RhY2tfYXJndW1lbnRzWzFdXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmVudmlyb25tZW50ID0gc3RhY2tfYXJndW1lbnRzWzJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzLmZldGNoT3B0aW9ucy5kZWJ1ZykgdGhpcy5mZXRjaE9wdGlvbnMubG9nSGFuZGxlcignZXJyb3InLCBfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLlNUQUNLX0lOVkFMSURfUEFSQU1TX1NUUklORyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrX2FyZ3VtZW50c1szXSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RhY2tfYXJndW1lbnRzWzNdID09PSAnc3RyaW5nJyAmJiBzdGFja19hcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCAmJiBzdGFja19hcmd1bWVudHNbM10gIT09ICd1cycpIHtcbiAgICAgICAgICAgIHRoaXMuY29uZmlnLmhvc3QgPSBzdGFja19hcmd1bWVudHNbM10gKyAnLScgKyAnY2RuLmNvbnRlbnRzdGFjay5jb20nO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX3R5cGVvZihzdGFja19hcmd1bWVudHNbM10pID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBVdGlscy5tZXJnZURlZXAodGhpcy5mZXRjaE9wdGlvbnMsIHN0YWNrX2FyZ3VtZW50c1szXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgY2FzZSA1OlxuICAgICAgICBpZiAodGhpcy5mZXRjaE9wdGlvbnMuZGVidWcpIHRoaXMuZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ3dhcm5pbmcnLCBfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLlNUQUNLX09CU09MRVRFX0ZVTkNUSU9OKTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdGFja19hcmd1bWVudHNbMF0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzdGFja19hcmd1bWVudHNbMV0gPT09ICdzdHJpbmcnICYmIHR5cGVvZiBzdGFja19hcmd1bWVudHNbMl0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgICAgICAgYXBpX2tleTogc3RhY2tfYXJndW1lbnRzWzBdLFxuICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiBzdGFja19hcmd1bWVudHNbMV1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRoaXMuZW52aXJvbm1lbnQgPSBzdGFja19hcmd1bWVudHNbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsIF9tZXNzYWdlc1tcImRlZmF1bHRcIl0uU1RBQ0tfSU5WQUxJRF9QQVJBTVNfU1RSSU5HKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhY2tfYXJndW1lbnRzWzNdKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBzdGFja19hcmd1bWVudHNbM10gPT09ICdzdHJpbmcnICYmIHN0YWNrX2FyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkICYmIHN0YWNrX2FyZ3VtZW50c1szXSAhPT0gJ3VzJykge1xuICAgICAgICAgICAgdGhpcy5jb25maWcuaG9zdCA9IHN0YWNrX2FyZ3VtZW50c1szXSArICctJyArICdjZG4uY29udGVudHN0YWNrLmNvbSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChfdHlwZW9mKHN0YWNrX2FyZ3VtZW50c1szXSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoT3B0aW9ucyA9IFV0aWxzLm1lcmdlRGVlcCh0aGlzLmZldGNoT3B0aW9ucywgc3RhY2tfYXJndW1lbnRzWzNdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YWNrX2FyZ3VtZW50c1s0XSAmJiBfdHlwZW9mKHN0YWNrX2FyZ3VtZW50c1s0XSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdGhpcy5mZXRjaE9wdGlvbnMgPSBVdGlscy5tZXJnZURlZXAodGhpcy5mZXRjaE9wdGlvbnMsIHN0YWNrX2FyZ3VtZW50c1s0XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodGhpcy5mZXRjaE9wdGlvbnMuZGVidWcpIHRoaXMuZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywgX21lc3NhZ2VzW1wiZGVmYXVsdFwiXS5TVEFDS19JTlZBTElEX1BBUkFNU19HRU5FUklDKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICAgKiBAbWV0aG9kIHNldFBvcnRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgcG9ydCBvZiB0aGUgaG9zdFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwb3J0IC0gUG9ydCBOdW1iZXJcbiAgICAgKiBAcmV0dXJuIHtTdGFja31cbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiAqL1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKFN0YWNrLCBbe1xuICAgIGtleTogXCJzZXRQb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFBvcnQocG9ydCkge1xuICAgICAgaWYgKHR5cGVvZiBwb3J0ID09PSAnbnVtYmVyJykgdGhpcy5jb25maWcucG9ydCA9IHBvcnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2Qgc2V0UHJvdG9jb2xcbiAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIHByb3RvY29sIGZvciB0aGUgaG9zdFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIC0gaHR0cC9odHRwcyBwcm90b2NvbFxuICAgICAgICogQHJldHVybiB7U3RhY2t9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0UHJvdG9jb2xcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0UHJvdG9jb2wocHJvdG9jb2wpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2wgPT09ICdzdHJpbmcnICYmIH5bJ2h0dHBzJywgJ2h0dHAnXS5pbmRleE9mKHByb3RvY29sKSkgdGhpcy5jb25maWcucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBzZXRIb3N0XG4gICAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBob3N0IG9mIHRoZSBBUEkgc2VydmVyXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gaG9zdCAtIHZhbGlkIGlwIG9yIGhvc3RcbiAgICAgICAqIEByZXR1cm4ge1N0YWNrfVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKiAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEhvc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0SG9zdChob3N0KSB7XG4gICAgICBpZiAodHlwZW9mIGhvc3QgPT09ICdzdHJpbmcnICYmIGhvc3QpIHRoaXMuY29uZmlnLmhvc3QgPSBob3N0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIHNldENhY2hlUG9saWN5XG4gICAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBBbGxvd3MgeW91IHRvIHNldCBjYWNoZSBwb2xpY2llc1xuICAgICAgICogQHBhcmFtIHtDb25zdGFudH0gW2tleT1PTkxZX05FVFdPUktdIC0gQ2FjaGUgcG9saWN5IHRvIGJlIGFwcGxpZWQgb24gU3RhY2sgb3IgUXVlcnkuXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogU3RhY2suc2V0Q2FjaGVQb2xpY3koQ29udGVudHN0YWNrLkNhY2hlUG9saWN5LklHTk9SRV9DQUNIRSlcbiAgICAgICAqIFN0YWNrLnNldENhY2hlUG9saWN5KENvbnRlbnRzdGFjay5DYWNoZVBvbGljeS5PTkxZX05FVFdPUkspXG4gICAgICAgKiBTdGFjay5zZXRDYWNoZVBvbGljeShDb250ZW50c3RhY2suQ2FjaGVQb2xpY3kuQ0FDSEVfRUxTRV9ORVRXT1JLKVxuICAgICAgICogU3RhY2suc2V0Q2FjaGVQb2xpY3koQ29udGVudHN0YWNrLkNhY2hlUG9saWN5Lk5FVFdPUktfRUxTRV9DQUNIRSlcbiAgICAgICAqIFN0YWNrLnNldENhY2hlUG9saWN5KENvbnRlbnRzdGFjay5DYWNoZVBvbGljeS5DQUNIRV9USEVOX05FVFdPUkspXG4gICAgICAgKiBAcmV0dXJucyB7U3RhY2t9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldENhY2hlUG9saWN5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENhY2hlUG9saWN5KHBvbGljeSkge1xuICAgICAgaWYgKHR5cGVvZiBwb2xpY3kgPT09ICdudW1iZXInICYmIHBvbGljeSA+PSAtMSAmJiBwb2xpY3kgPCA0KSB7XG4gICAgICAgIGlmICghdGhpcy5fcXVlcnkpIHtcbiAgICAgICAgICB0aGlzLmNhY2hlUG9saWN5ID0gcG9saWN5O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnlDYWNoZVBvbGljeSA9IHBvbGljeTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuZmV0Y2hPcHRpb25zLmRlYnVnKSB0aGlzLmZldGNoT3B0aW9ucy5sb2dIYW5kbGVyKCdlcnJvcicsIF9tZXNzYWdlc1tcImRlZmF1bHRcIl0uQ0FDSEVfUE9MSUNZX0lOVkFMSUQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldExpdmVQcmV2aWV3VGltZWxpbmVQcmV2aWV3Rm9yQ2xpZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldExpdmVQcmV2aWV3VGltZWxpbmVQcmV2aWV3Rm9yQ2xpZW50KCkge1xuICAgICAgaWYgKFV0aWxzLmlzQnJvd3NlcigpKSB7XG4gICAgICAgIHZhciBwYXJhbXMgPSBuZXcgVVJMKGRvY3VtZW50LmxvY2F0aW9uLnRvU3RyaW5nKCkpLnNlYXJjaFBhcmFtcztcbiAgICAgICAgaWYgKHBhcmFtcy5oYXMoJ2xpdmVfcHJldmlldycpKSB7XG4gICAgICAgICAgdGhpcy5saXZlX3ByZXZpZXcubGl2ZV9wcmV2aWV3ID0gcGFyYW1zLmdldCgnbGl2ZV9wcmV2aWV3Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5oYXMoJ3JlbGVhc2VfaWQnKSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5yZWxlYXNlX2lkID0gcGFyYW1zLmdldCgncmVsZWFzZV9pZCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLmhlYWRlcnMucmVsZWFzZV9pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1zLmhhcygncHJldmlld190aW1lc3RhbXAnKSkge1xuICAgICAgICAgIHRoaXMuaGVhZGVycy5wcmV2aWV3X3RpbWVzdGFtcCA9IHBhcmFtcy5nZXQoJ3ByZXZpZXdfdGltZXN0YW1wJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuaGVhZGVycy5wcmV2aWV3X3RpbWVzdGFtcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJsaXZlUHJldmlld1F1ZXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxpdmVQcmV2aWV3UXVlcnkocXVlcnkpIHtcbiAgICAgIGlmICh0aGlzLmxpdmVfcHJldmlldykge1xuICAgICAgICB0aGlzLmxpdmVfcHJldmlldy5saXZlX3ByZXZpZXcgPSBxdWVyeS5saXZlX3ByZXZpZXcgfHwgJ2luaXQnO1xuICAgICAgICB0aGlzLmxpdmVfcHJldmlldy5jb250ZW50X3R5cGVfdWlkID0gcXVlcnkuY29udGVudF90eXBlX3VpZDtcbiAgICAgICAgdGhpcy5saXZlX3ByZXZpZXcuZW50cnlfdWlkID0gcXVlcnkuZW50cnlfdWlkO1xuICAgICAgfVxuICAgICAgaWYgKHF1ZXJ5Lmhhc093blByb3BlcnR5KCdyZWxlYXNlX2lkJykpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLnJlbGVhc2VfaWQgPSBxdWVyeS5yZWxlYXNlX2lkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGVhZGVycy5yZWxlYXNlX2lkO1xuICAgICAgfVxuICAgICAgaWYgKHF1ZXJ5Lmhhc093blByb3BlcnR5KCdwcmV2aWV3X3RpbWVzdGFtcCcpKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5wcmV2aWV3X3RpbWVzdGFtcCA9IHF1ZXJ5LnByZXZpZXdfdGltZXN0YW1wO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuaGVhZGVycy5wcmV2aWV3X3RpbWVzdGFtcDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2Qgc2V0Q2FjaGVQcm92aWRlclxuICAgICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICAgKiBAZGVzY3JpcHRpb24gQWxsb3dzIHlvdSB0byBzZXQgYW4gb2JqZWN0IG9mIHRoZSBjYWNoZSBwcm92aWRlclxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIFN0YWNrXG4gICAgICAgKiAgICAgIC5zZXRDYWNoZVByb3ZpZGVyKHtcbiAgICAgICAqICAgICAgICAgIGdldDogZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgICAgICAqICAgICAgICAgICAgICAvLyBjdXN0b20gbG9naWNcbiAgICAgICAqICAgICAgICAgIH0sXG4gICAgICAgKiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjYWxsYmFjaykge1xuICAgICAgICogICAgICAgICAgICAgIC8vIGN1c3RvbSBsb2dpY1xuICAgICAgICogICAgICAgICAgfVxuICAgICAgICogICAgICB9KTtcbiAgICAgICAqIEByZXR1cm5zIHtTdGFja31cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2FjaGVQcm92aWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDYWNoZVByb3ZpZGVyKHByb3ZpZGVyKSB7XG4gICAgICBpZiAocHJvdmlkZXIgJiYgX3R5cGVvZihwcm92aWRlcikgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBjbGVhckJ5UXVlcnlcbiAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICogQGRlc2NyaXB0aW9uICdjbGVhckJ5UXVlcnknIGZ1bmN0aW9uIHRvIGNsZWFyIHRoZSBxdWVyeSBmcm9tIHRoZSBjYWNoZS5cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBTdGFjay5jbGVhclF1ZXJ5KHF1ZXJ5LCBjYWxsYmFjayk7XG4gICAgICAgKiBAcmV0dXJucyB7U3RhY2t9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNsZWFyQnlRdWVyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckJ5UXVlcnkoKSB7XG4gICAgICBpZiAodGhpcy5wcm92aWRlciAmJiB0eXBlb2YgdGhpcy5wcm92aWRlci5jbGVhckJ5UXVlcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY2xlYXJCeVF1ZXJ5LmFwcGx5KHRoaXMucHJvdmlkZXIsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGNsZWFyQnlDb250ZW50VHlwZVxuICAgICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICAgKiBAZGVzY3JpcHRpb24gJ2NsZWFyQnlDb250ZW50VHlwZScgZnVuY3Rpb24gdG8gY2xlYXIgdGhlIHF1ZXJ5IGZyb20gdGhlIGNhY2hlIGJ5IHNwZWNpZmllZCBjb250ZW50IHR5cGUuXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogU3RhY2suY2xlYXJCeUNvbnRlbnRUeXBlKGNvbnRlbnRfdHlwZV91aWQsIGNhbGxiYWNrKTtcbiAgICAgICAqIFN0YWNrLmNsZWFyQnlDb250ZW50VHlwZShjb250ZW50X3R5cGVfdWlkLCBsYW5ndWFnZV91aWQsIGNhbGxiYWNrKTtcbiAgICAgICAqIEByZXR1cm5zIHtTdGFja31cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJCeUNvbnRlbnRUeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyQnlDb250ZW50VHlwZSgpIHtcbiAgICAgIGlmICh0aGlzLnByb3ZpZGVyICYmIHR5cGVvZiB0aGlzLnByb3ZpZGVyLmNsZWFyQnlDb250ZW50VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5jbGVhckJ5Q29udGVudFR5cGUuYXBwbHkodGhpcy5wcm92aWRlciwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgY2xlYXJBbGxcbiAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICogQGRlc2NyaXB0aW9uICdjbGVhckFsbCcgZnVuY3Rpb24gdG8gY2xlYXIgYWxsIHRoZSBxdWVyaWVzIGZyb20gY2FjaGUuXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogU3RhY2suY2xlYXJBbGwoY2FsbGJhY2spO1xuICAgICAgICogQHJldHVybnMge1N0YWNrfVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckFsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhckFsbCgpIHtcbiAgICAgIGlmICh0aGlzLnByb3ZpZGVyICYmIHR5cGVvZiB0aGlzLnByb3ZpZGVyLmNsZWFyQWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLmNsZWFyQWxsLmFwcGx5KHRoaXMucHJvdmlkZXIsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGdldENhY2hlUHJvdmlkZXJcbiAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGN1cnJlbnRseSBzZXQgb2JqZWN0IG9mICdDYWNoZVByb3ZpZGVyJ1xuICAgICAgICogQGV4YW1wbGUgU3RhY2suZ2V0Q2FjaGVQcm92aWRlcigpO1xuICAgICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FjaGVQcm92aWRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYWNoZVByb3ZpZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIENvbnRlbnRUeXBlXG4gICAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGNvbnRlbnQgdHlwZSBvZiB3aGljaCB5b3Ugd2FudCB0byByZXRyaWV2ZSB0aGUgZW50cmllc1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IFtjb250ZW50X3R5cGVfdWlkXSAtIHVpZCBvZiB0aGUgZXhpc3RpbmcgY29udGVudCB0eXBlXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogbGV0IGRhdGEgPSBTdGFjay5Db250ZW50VHlwZSgnYmxvZycpLlF1ZXJ5KCkudG9KU09OKCkuZmluZCgpXG4gICAgICAgKiAgICAgIGRhdGFcbiAgICAgICAqICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgKiAgICAgICAgICAgLy8gJ3Jlc3VsdCcgY29udGVudCB0aGUgbGlzdCBvZiBlbnRyaWVzIG9mIHBhcnRpY3VsYXIgY29udGVudCB0eXBlIGJsb2cuXG4gICAgICAgKiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgKiAgICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqICAgICAgfSlcbiAgICAgICAqIEByZXR1cm5zIHtTdGFja31cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiQ29udGVudFR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gQ29udGVudFR5cGUodWlkKSB7XG4gICAgICBpZiAodWlkICYmIHR5cGVvZiB1aWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuY29udGVudF90eXBlX3VpZCA9IHVpZDtcbiAgICAgICAgdGhpcy50eXBlID0gJ2NvbnRlbnRUeXBlJztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBUYXhvbm9taWVzXG4gICAgICAgKiBAbWVtYmVyb2YgU3RhY2tcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBBIG1ldGhvZCB0byBzZXQgYmFzZSB1cmwgdG8gdGF4b25vbWllcyBlbmRwb2ludFxuICAgICAgICogQHJldHVybnMge1N0YWNrfVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiVGF4b25vbWllc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBUYXhvbm9taWVzKCkge1xuICAgICAgdGhpcy50eXBlID0gJ3RheG9ub215JztcbiAgICAgIHJldHVybiBVdGlscy5tZXJnZShuZXcgX3RheG9ub215W1wiZGVmYXVsdFwiXSgpLCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgRW50cnlcbiAgICAgICAqIEBtZW1iZXJPZiBDb250ZW50VHlwZVxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVpZCAtIHVpZCBvZiB0aGUgZW50cnlcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBBbiBpbml0aWFsaXplciBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgRW50cnkgb2JqZWN0XG4gICAgICAgKiBAcmV0dXJucyB7RW50cnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIkVudHJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIEVudHJ5KHVpZCkge1xuICAgICAgdmFyIGVudHJ5ID0gbmV3IF9lbnRyeVtcImRlZmF1bHRcIl0oKTtcbiAgICAgIGlmICh1aWQgJiYgdHlwZW9mIHVpZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgZW50cnkuZW50cnlfdWlkID0gdWlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFV0aWxzLm1lcmdlKGVudHJ5LCB0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgZmV0Y2hcbiAgICAgICAqIEBtZW1iZXJPZiBDb250ZW50VHlwZVxuICAgICAgICogQGRlc2NyaXB0aW9uIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGNvbXBsZXRlIGluZm9ybWF0aW9uIG9mIGEgc3BlY2lmaWMgY29udGVudCB0eXBlLlxuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIGxldCBzaW5nbGVfY29udGVudHR5cGUgPSBTdGFjay5Db250ZW50VHlwZShjb250ZW50X3R5cGVfdWlkKS5mZXRjaCgpXG4gICAgICAgKiAgICBzaW5nbGVfY29udGVudHR5cGVcbiAgICAgICAqICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAvLyAncmVzdWx0JyBpcyBhIHNpbmdsZSBjb250ZW50VHlwZSBpbmZvcm1hdGlvbi5cbiAgICAgICAqICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAqICAgICAgICBjb25zb2xlLmVycm9yKE1FU1NBR0VTLlJFUVVFU1RfRVJST1JfT0NDVVJSRUQoZXJyb3IubWVzc2FnZSB8fCBlcnJvcikpXG4gICAgICAgKiAgfSk7XG4gICAgICAgKiBAcmV0dXJucyB7cHJvbWlzZX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2goZmV0Y2hPcHRpb25zKSB7XG4gICAgICB0aGlzLnJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiBVdGlscy5tZXJnZURlZXAoe30sIHRoaXMuaGVhZGVycyksXG4gICAgICAgIHBsdWdpbnM6IHRoaXMucGx1Z2lucyxcbiAgICAgICAgdXJsOiB0aGlzLmNvbmZpZy5wcm90b2NvbCArICc6Ly8nICsgdGhpcy5jb25maWcuaG9zdCArICc6JyArIHRoaXMuY29uZmlnLnBvcnQgKyAnLycgKyB0aGlzLmNvbmZpZy52ZXJzaW9uICsgdGhpcy5jb25maWcudXJscy5jb250ZW50X3R5cGVzICsgdGhpcy5jb250ZW50X3R5cGVfdWlkLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgX21ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuZW52aXJvbm1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBvcHRpb25zID0gVXRpbHMubWVyZ2VEZWVwKHRoaXMuZmV0Y2hPcHRpb25zLCBmZXRjaE9wdGlvbnMpO1xuICAgICAgcmV0dXJuICgwLCBfcmVxdWVzdFtcImRlZmF1bHRcIl0pKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBBc3NldHNcbiAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHVpZCAtIHVpZCBvZiB0aGUgYXNzZXRcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgYWxsIGFzc2V0cyBvZiBhIHN0YWNrIGJ5IGRlZmF1bHQuIFRvIHJldHJpZXZlIGEgc2luZ2xlIGFzc2V0LCBzcGVjaWZ5IGl0cyBVSUQuXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogLy8gUmV0cmlldmVzIGFsbCBhc3NldHNcbiAgICAgICAqIGxldCBkYXRhID0gU3RhY2suQXNzZXRzKCkuUXVlcnkoKS50b0pTT04oKS5maW5kKClcbiAgICAgICAqICAgICAgZGF0YVxuICAgICAgICogICAgICAudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAqICAgICAgICAgIC8vIEFsbCB0aGUgYXNzZXQgd2l0aCBsaW1pdCBvZiAxMDBcbiAgICAgICAqICAgICAgICAgIC8vIFVzZSBza2lwIGFuZCBsaW1pdCBmdW5jdGlvbnMgdG8gcGFnaW5hdGVcbiAgICAgICAqICAgICAgICAgIC8vIOKAmHJlc3VsdOKAmSB3aWxsIGRpc3BsYXkgYWxsIGFzc2V0cyBwcmVzZW50IGluIHN0YWNrXG4gICAgICAgKiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgKiAgICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgICAqICAgICAgfSlcbiAgICAgICAqXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogbGV0IGRhdGEgPSBTdGFjay5Bc3NldHMoJ2Fzc2V0X3VpZCcpLnRvSlNPTigpLmZldGNoKClcbiAgICAgICAqICAgICAgZGF0YVxuICAgICAgICogICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAgICAgIC8vIOKAmHJlc3VsdOKAmSBpcyBhIHNpbmdsZSBhc3NldCBvYmplY3Qgb2Ygc3BlY2lmaWVkIHVpZFxuICAgICAgICogICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICogICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge0Fzc2V0c31cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiQXNzZXRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIEFzc2V0cyh1aWQpIHtcbiAgICAgIHRoaXMudHlwZSA9ICdhc3NldCc7XG4gICAgICBpZiAodWlkICYmIHR5cGVvZiB1aWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciBhc3NldCA9IG5ldyBfYXNzZXRzW1wiZGVmYXVsdFwiXSgpO1xuICAgICAgICBhc3NldC5hc3NldF91aWQgPSB1aWQ7XG4gICAgICAgIHJldHVybiBVdGlscy5tZXJnZShhc3NldCwgdGhpcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgUXVlcnlcbiAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICogQGRlc2NyaXB0aW9uIEFuIGluaXRpYWxpemVyIGlzIHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyBRdWVyeSBvYmplY3QuUHJvdmlkZXMgc3VwcG9ydCBmb3IgYWxsIHNlYXJjaCBxdWVyaWVzXG4gICAgICAgKiBAcmV0dXJucyB7UXVlcnl9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIlF1ZXJ5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIFF1ZXJ5KCkge1xuICAgICAgLy8gVGF4b25vbXkgaXMgYSBjbGFzcyB0aGF0IGV4dGVuZHMgUXVlcnkgY2xhc3MgYW5kIGFkZHMgNCBtb3JlIGhlbHBlciBtZXRob2RzIHRoYXQgdXNlIGxldmVscy5cbiAgICAgIC8vIFRoZXNlIDQgbWV0aG9kcyBhbHNvIHdvcmsgb24gY29udGVudFR5cGUgYmFzZSB1cmwsIGhlbmNlIFRheG9ub215IGluc3RhbmNlIGlzIHJldHVybmVkXG4gICAgICAvLyBUYXhvbm9teSBpbnN0YW5jZSBpcyBSZWd1bGFyIFF1ZXJ5IGluc3RhbmNlICsgNCBhZGRpdGlvbmFsIG1ldGhvZHMgKGJlbG93LCBlcV9iZWxvdywgYWJvdmUsIGVxX2Fib3ZlKVxuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy50eXBlID09PSAnY29udGVudFR5cGUnID8gbmV3IF90YXhvbm9teVtcImRlZmF1bHRcIl0oKSA6IG5ldyBfcXVlcnlbXCJkZWZhdWx0XCJdKCk7XG4gICAgICByZXR1cm4gVXRpbHMubWVyZ2UocXVlcnksIHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAgICogQG1ldGhvZCBnZXRMYXN0QWN0aXZpdGllc1xuICAgICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICAgKiBAZGVzY3JpcHRpb24gZ2V0TGFzdEFjdGl2aXRpZXMgZ2V0IGFsbCB0aGUgQ29udGVudFR5cGVzIHdob3NlIGxhc3QgYWN0aXZpdHkgdXBkYXRlZC5cbiAgICAgICAqIEBleGFtcGxlIFN0YWNrLmdldExhc3RBY3Rpdml0aWVzKClcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBsZXQgZGF0YSA9IFN0YWNrLmdldExhc3RBY3Rpdml0aWVzKCkudG9KU09OKCkuZmV0Y2goKVxuICAgICAgICogICAgICBkYXRhXG4gICAgICAgKiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAgICAgIC8vICdyZXN1bHQnIGlzIGxpc3Qgb2YgY29udGVudFR5cGVzIHdob3NlIGxhc3QgYWN0aXZpdHkgdXBkYXRlZC5cbiAgICAgICAqICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAqICAgICAgICAgICAvLyBlcnJvciBmdW5jdGlvblxuICAgICAgICogICAgICB9KVxuICAgICAgICogQHJldHVybnMge3Byb21pc2V9XG4gICAgICAgKiBAaW5zdGFuY2VcbiAgICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExhc3RBY3Rpdml0aWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhc3RBY3Rpdml0aWVzKCkge1xuICAgICAgdGhpcy5yZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczogVXRpbHMubWVyZ2VEZWVwKHt9LCB0aGlzLmhlYWRlcnMpLFxuICAgICAgICB1cmw6IHRoaXMuY29uZmlnLnByb3RvY29sICsgJzovLycgKyB0aGlzLmNvbmZpZy5ob3N0ICsgJzonICsgdGhpcy5jb25maWcucG9ydCArICcvJyArIHRoaXMuY29uZmlnLnZlcnNpb24gKyB0aGlzLmNvbmZpZy51cmxzLmNvbnRlbnRfdHlwZXMsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICBfbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICBvbmx5X2xhc3RfYWN0aXZpdHk6IHRydWUsXG4gICAgICAgICAgZW52aXJvbm1lbnQ6IHRoaXMuZW52aXJvbm1lbnRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiAoMCwgX3JlcXVlc3RbXCJkZWZhdWx0XCJdKSh0aGlzLCB0aGlzLmZldGNoT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIGdldENvbnRlbnRUeXBlc1xuICAgICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW0gLSBRdWVyeSBvbiBjb250ZW50VHlwZXNcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBUaGlzIG1ldGhvZCByZXR1cm5zIGNvbXByZWhlbnNpdmUgaW5mb3JtYXRpb24gb2YgYWxsIHRoZSBjb250ZW50IHR5cGVzIG9mIGEgcGFydGljdWxhciBzdGFjayBpbiB5b3VyIGFjY291bnQuXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogbGV0IGRhdGEgPSBTdGFjay5nZXRDb250ZW50VHlwZXMoe1wiaW5jbHVkZV9nbG9iYWxfZmllbGRfc2NoZW1hXCI6IHRydWV9KVxuICAgICAgICogICAgICBkYXRhXG4gICAgICAgKiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICogICAgICAgICAgIC8vICdyZXN1bHQnIGlzIGxpc3Qgb2YgY29udGVudFR5cGVzLlxuICAgICAgICogICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICogICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7cHJvbWlzZX1cbiAgICAgICAqIEBpbnN0YW5jZVxuICAgICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29udGVudFR5cGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvbnRlbnRUeXBlcygpIHtcbiAgICAgIHZhciBwYXJhbSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICB0aGlzLnJlcXVlc3RQYXJhbXMgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzOiBVdGlscy5tZXJnZURlZXAoe30sIHRoaXMuaGVhZGVycyksXG4gICAgICAgIHVybDogdGhpcy5jb25maWcucHJvdG9jb2wgKyAnOi8vJyArIHRoaXMuY29uZmlnLmhvc3QgKyAnOicgKyB0aGlzLmNvbmZpZy5wb3J0ICsgJy8nICsgdGhpcy5jb25maWcudmVyc2lvbiArIHRoaXMuY29uZmlnLnVybHMuY29udGVudF90eXBlcyxcbiAgICAgICAgYm9keToge1xuICAgICAgICAgIF9tZXRob2Q6ICdHRVQnLFxuICAgICAgICAgIGVudmlyb25tZW50OiB0aGlzLmVudmlyb25tZW50XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAocGFyYW0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtKSB7XG4gICAgICAgICAgdGhpcy5yZXF1ZXN0UGFyYW1zLmJvZHlba2V5XSA9IHBhcmFtW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAoMCwgX3JlcXVlc3RbXCJkZWZhdWx0XCJdKSh0aGlzLCB0aGlzLmZldGNoT3B0aW9ucyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICAgKiBAbWV0aG9kIHN5bmNcbiAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICogQGRlc2NyaXB0aW9uIFN5bmNzIHlvdXIgQ29udGVudHN0YWNrIGRhdGEgd2l0aCB5b3VyIGFwcCBhbmQgZW5zdXJlcyB0aGF0IHRoZSBkYXRhIGlzIGFsd2F5cyB1cC10by1kYXRlIGJ5IHByb3ZpZGluZyBkZWx0YSB1cGRhdGVzXG4gICAgICAgKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gcGFyYW1zIGlzIGFuIG9iamVjdCB0aGF0IHN1cHBvcnRzIOKAmGxvY2FsZeKAmSwg4oCYc3RhcnRfZGF0ZeKAmSwg4oCYY29udGVudF90eXBlX3VpZOKAmSwgYW5kIOKAmHR5cGXigJkgcXVlcmllcy5cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBTdGFjay5zeW5jKHsnaW5pdCc6IHRydWV9KSAgICAgICAgLy8gRm9yIGluaXRpYWxpemluZyBzeW5jXG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogU3RhY2suc3luYyh7J2luaXQnOiB0cnVlLCAnbG9jYWxlJzogJ2VuLXVzJ30pICAgICAvL0ZvciBpbml0aWFsaXppbmcgc3luYyB3aXRoIGVudHJpZXMgb2YgYSBzcGVjaWZpYyBsb2NhbGVcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBTdGFjay5zeW5jKHsnaW5pdCc6IHRydWUsICdzdGFydF9kYXRlJzogJzIwMTgtMTAtMjInfSkgICAgLy9Gb3IgaW5pdGlhbGl6aW5nIHN5bmMgd2l0aCBlbnRyaWVzIHB1Ymxpc2hlZCBhZnRlciBhIHNwZWNpZmljIGRhdGVcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBTdGFjay5zeW5jKHsnaW5pdCc6IHRydWUsICdjb250ZW50X3R5cGVfdWlkJzogJ3Nlc3Npb24nfSkgICAvL0ZvciBpbml0aWFsaXppbmcgc3luYyB3aXRoIGVudHJpZXMgb2YgYSBzcGVjaWZpYyBjb250ZW50IHR5cGVcbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBTdGFjay5zeW5jKHsnaW5pdCc6IHRydWUsICd0eXBlJzogJ2VudHJ5X3B1Ymxpc2hlZCd9KSAgIC8vVXNlIHRoZSB0eXBlIHBhcmFtZXRlciB0byBnZXQgYSBzcGVjaWZpYyB0eXBlIG9mIGNvbnRlbnQuU3VwcG9ydHMgJ2Fzc2V0X3B1Ymxpc2hlZCcsICdlbnRyeV9wdWJsaXNoZWQnLCAnYXNzZXRfdW5wdWJsaXNoZWQnLCAnZW50cnlfdW5wdWJsaXNoZWQnLCAnYXNzZXRfZGVsZXRlZCcsICdlbnRyeV9kZWxldGVkJywgJ2NvbnRlbnRfdHlwZV9kZWxldGVkJy5cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBTdGFjay5zeW5jKHsncGFnaW5hdGlvbl90b2tlbic6ICc8cGFnZV90a24+J30pICAgIC8vIEZvciBmZXRjaGluZyB0aGUgbmV4dCBiYXRjaCBvZiBlbnRyaWVzIHVzaW5nIHBhZ2luYXRpb24gdG9rZW5cbiAgICAgICAqIEBleGFtcGxlXG4gICAgICAgKiBTdGFjay5zeW5jKHsnc3luY190b2tlbic6ICc8c3luY190a24+J30pICAgIC8vIEZvciBwZXJmb3JtaW5nIHN1YnNlcXVlbnQgc3luYyBhZnRlciBpbml0aWFsIHN5bmNcbiAgICAgICAqIEByZXR1cm5zIHtwcm9taXNlfVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHN5bmMocGFyYW1zLCBmZXRjaE9wdGlvbnMpIHtcbiAgICAgIGlmIChwYXJhbXMgJiYgX3R5cGVvZihwYXJhbXMpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcGFyYW1ldGVyczogcGFyYW1zIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICAgICAgfVxuICAgICAgdGhpcy5fcXVlcnkgPSB7fTtcbiAgICAgIGlmIChwYXJhbXMpIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHBhcmFtc1trZXldO1xuICAgICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJyAmJiAhKHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSAmJiAoX3R5cGVvZih2YWx1ZSkgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHBhcmFtZXRlciB2YWx1ZSBmb3Iga2V5IFxcXCJcIi5jb25jYXQoa2V5LCBcIlxcXCI6IG11c3QgYmUgYSBzdHJpbmcsIG51bWJlciwgb2JqZWN0LCBib29sZWFuLCBvciBSZWdFeHAuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3F1ZXJ5W2tleV0gPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucmVxdWVzdFBhcmFtcyA9IHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IFV0aWxzLm1lcmdlRGVlcCh7fSwgdGhpcy5oZWFkZXJzKSxcbiAgICAgICAgdXJsOiB0aGlzLmNvbmZpZy5wcm90b2NvbCArICc6Ly8nICsgdGhpcy5jb25maWcuaG9zdCArICc6JyArIHRoaXMuY29uZmlnLnBvcnQgKyAnLycgKyB0aGlzLmNvbmZpZy52ZXJzaW9uICsgdGhpcy5jb25maWcudXJscy5zeW5jLFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgX21ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgcXVlcnk6IHRoaXMuX3F1ZXJ5XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgb3B0aW9ucyA9IFV0aWxzLm1lcmdlRGVlcCh0aGlzLmZldGNoT3B0aW9ucywgZmV0Y2hPcHRpb25zKTtcbiAgICAgIHJldHVybiBVdGlscy5zZW5kUmVxdWVzdChVdGlscy5tZXJnZURlZXAoe30sIHRoaXMpLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgaW1hZ2VUcmFuc2Zvcm1cbiAgICAgICAqIEBtZW1iZXJPZiBTdGFja1xuICAgICAgICogQGRlc2NyaXB0aW9uIFBlcmZvcm1zIHRyYW5zZm9ybWF0aW9ucyBvbiBpbWFnZXMgb2YgbWVudGlvbmVkIHVybCBiYXNlZCBvbiB0cmFuc2Zvcm1hdGlvbiBwYXJhbWV0ZXJzXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIC0gSW1hZ2UgdXJsIG9uIHdoaWNoIHRyYW5zZm9ybWF0aW9ucyBuZWVkIHRvIGJlIGFwcGxpZWQuXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1zIC0gT2JqZWN0IHdpdGggdHJhbnNmb3JtYXRpb24gcGFyYW1ldGVyc1xuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIFN0YWNrLmltYWdlVHJhbnNmb3JtKGltYWdlVVJMLCB7aGVpZ2h0OiAxMDAsIHdpZHRoOiAyMDAsIGRpc2FibGU6IFwidXBzY2FsZVwifSk7XG4gICAgICAgKiBAZXhhbXBsZVxuICAgICAgICogU3RhY2suaW1hZ2VUcmFuc2Zvcm0oaW1hZ2VVUkwsIHtjcm9wOiBcIjE1MCwxMDBcIn0pO1xuICAgICAgICogQGV4YW1wbGVcbiAgICAgICAqIFN0YWNrLmltYWdlVHJhbnNmb3JtKGltYWdlVVJMLCB7Zm9ybWF0OiBcInBuZ1wiLCBjcm9wOiBcIjE1MCwxMDBcIn0pO1xuICAgICAgICogQHJldHVybnMge3N0cmluZ30gW0ltYWdlIHVybCB3aXRoIHRyYW5zZm9ybWF0aW9uIHBhcmFtZXRlcnMuXVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbWFnZVRyYW5zZm9ybVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbWFnZVRyYW5zZm9ybSh1cmwsIHBhcmFtcykge1xuICAgICAgaWYgKHVybCAmJiB0eXBlb2YgdXJsID09PSAnc3RyaW5nJyAmJiBfdHlwZW9mKHBhcmFtcykgPT09ICdvYmplY3QnICYmIHBhcmFtcy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgcXVlcnlQYXJhbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgb3BlcmF0aW9uIGluIHBhcmFtcykge1xuICAgICAgICAgIHZhciBlbmNvZGVkS2V5ID0gZW5jb2RlVVJJQ29tcG9uZW50KG9wZXJhdGlvbik7XG4gICAgICAgICAgdmFyIGVuY29kZWRWYWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNbb3BlcmF0aW9uXSk7XG4gICAgICAgICAgcXVlcnlQYXJhbXMucHVzaChlbmNvZGVkS2V5ICsgJz0nICsgZW5jb2RlZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB1cmwgKz0gdXJsLmluZGV4T2YoJz8nKSA8PSAtMSA/ICc/JyArIHF1ZXJ5UGFyYW1zLmpvaW4oJyYnKSA6ICcmJyArIHF1ZXJ5UGFyYW1zLmpvaW4oJyYnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA1Mzc6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IHZvaWQgMDtcbnZhciBVdGlscyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9fd2VicGFja19yZXF1aXJlX18oOTI1KSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFdlYWtNYXApIHZhciByID0gbmV3IFdlYWtNYXAoKSxcbiAgICBuID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIChfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHtcbiAgICBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBvLFxuICAgICAgaSxcbiAgICAgIGYgPSB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgXCJkZWZhdWx0XCI6IGVcbiAgICAgIH07XG4gICAgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIGY7XG4gICAgaWYgKG8gPSB0ID8gbiA6IHIpIHtcbiAgICAgIGlmIChvLmhhcyhlKSkgcmV0dXJuIG8uZ2V0KGUpO1xuICAgICAgby5zZXQoZSwgZik7XG4gICAgfVxuICAgIGZvciAodmFyIF90IGluIGUpIFwiZGVmYXVsdFwiICE9PSBfdCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIF90KSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBfdCkpICYmIChpLmdldCB8fCBpLnNldCkgPyBvKGYsIF90LCBpKSA6IGZbX3RdID0gZVtfdF0pO1xuICAgIHJldHVybiBmO1xuICB9KShlLCB0KTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbi8qKlxuICogQGNsYXNzXG4gIEFzc2V0c1xuKiBAc3VtbWFyeSBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGBBc3NldHNgLlxuKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIGFsbCBhc3NldHMgb2YgYSBzdGFjayBieSBkZWZhdWx0LiBUbyByZXRyaWV2ZSBhIHNpbmdsZSBhc3NldCwgc3BlY2lmeSBpdHMgVUlELlxuKiBAcGFyYW0ge1N0cmluZ30gdWlkIC0gdWlkIG9mIGFzc2V0IHlvdSB3YW50IHRvIHJldHJpZXZlXG4qIEBleGFtcGxlXG4qIGxldCBkYXRhID0gU3RhY2suQXNzZXRzKCdhc3NldF91aWQnKS50b0pTT04oKS5mZXRjaCgpXG4qICAgICAgZGF0YVxuKiAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuKiAgICAgICAgICAgLy8g4oCYcmVzdWx04oCZIGlzIGEgc2luZ2xlIGFzc2V0IG9iamVjdCBvZiBzcGVjaWZpZWQgdWlkXG4qICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiogICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4qICAgICAgfSlcbiogQGV4YW1wbGVcbiogLy8gUmV0cmlldmVzIGFsbCBhc3NldHMqXG4qIGxldCBkYXRhID0gU3RhY2suQXNzZXRzKCkuUXVlcnkoKS50b0pTT04oKS5maW5kKClcbiogICAgICBkYXRhXG4qICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4qICAgICAgICAgIC8vIEFsbCB0aGUgYXNzZXQgd2l0aCBsaW1pdCBvZiAxMDBcbiogICAgICAgICAgLy8gVXNlIHNraXAgYW5kIGxpbWl0IGZ1bmN0aW9ucyB0byBwYWdpbmF0ZVxuKiAgICAgICAgICAvLyDigJhyZXN1bHTigJkgd2lsbCBkaXNwbGF5IGFsbCBhc3NldHMgcHJlc2VudCBpbiBzdGFja1xuKiAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4qICAgICAgICAgICAvLyBlcnJvciBmdW5jdGlvblxuKiAgICAgIH0pXG4qIEByZXR1cm5zIHtBc3NldHN9XG4qIEBpbnN0YW5jZVxuKi9cbnZhciBBc3NldHMgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEFzc2V0cygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQXNzZXRzKTtcbiAgICB0aGlzLl9xdWVyeSA9IHt9O1xuICAgIHRoaXMub25seSA9IFV0aWxzLnRyYW5zZm9ybSgnb25seScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHlvdXIgcmVzcG9uc2UgaW50byBwbGFpbiBKYXZhc1NjcmlwdCBvYmplY3RcbiAgICogQG1lbWJlck9mIEFzc2V0c1xuICAgKiBAZXhhbXBsZSB2YXIgUXVlcnkgPSBTdGFjay5Db250ZW50VHlwZSgnYmxvZycpLlF1ZXJ5KClcbiAgICBRdWVyeVxuICAgICAgICAgLnRvSlNPTigpXG4gICAgICAgICAuZmluZCgpXG4gICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgLy8gJ3Jlc3VsdCcgaXMgYW4gb2JqZWN0IHdoaWNoIGNvbnRlbnQgdGhlIGRhdGEgaW4ganNvbiBvYmplY3QgZm9ybVxuICAgICAgICAgIH0sZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgLy8gZXJyb3IgZnVuY3Rpb25cbiAgICAgfSlcbiAgICogQHJldHVybnMge0Fzc2V0c31cbiAgICogQGluc3RhbmNlXG4gICAqL1xuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFzc2V0cywgW3tcbiAgICBrZXk6IFwidG9KU09OXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICAgIHRoaXMudG9qc29uID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluY2x1ZGVzIHF1ZXJ5IHBhcmFtZXRlcnMgaW4geW91ciBxdWVyaWVzLlxuICAgICAqIEBtZW1iZXJPZiBBc3NldHNcbiAgICAgKiBAZXhhbXBsZSB2YXIgZGF0YSA9IFN0YWNrLkFzc2V0cyhhc3NldFVpZCkuYWRkUGFyYW0oJ2luY2x1ZGVfZGltZW5zaW9uJywgJ3RydWUnKS50b0pTT04oKS5mZXRjaCgpXG4gICAgICAgKiAgICAgIGRhdGEudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgKiAgICAgICAgICAvLyAncmVzdWx0JyBpcyBhbiBvYmplY3Qgd2hpY2ggY29udGVudCB0aGUgZGF0YSBpbmNsdWRpbmcgY291bnQgaW4ganNvbiBvYmplY3QgZm9ybVxuICAgICAgICogICAgICAgfSxmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAqICAgICAgICAgIC8vIGVycm9yIGZ1bmN0aW9uXG4gICAgICAgKiAgICAgIH0pXG4gICAgICAgKiBAcmV0dXJucyB7QXNzZXRzfVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkUGFyYW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkUGFyYW0oa2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSAmJiB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyAmJiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuX3F1ZXJ5W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5mZXRjaE9wdGlvbnMuZGVidWcpIHRoaXMuZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywgJ0tpbmRseSBwcm92aWRlIGEgdmFsaWQgcGFyYW1ldGVycy4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgaW5jbHVkZUZhbGxiYWNrXG4gICAgICAgKiBAbWVtYmVyT2YgQXNzZXRcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBJbmNsdWRlIHRoZSBmYWxsYmFjayBsb2NhbGUgcHVibGlzaCBjb250ZW50LCBpZiBzcGVjaWZpZWQgbG9jYWxlIGNvbnRlbnQgaXMgbm90IHB1Ymxpc2guXG4gICAgICAgKiBAZXhhbXBsZSBzdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZV91aWQpLkFzc2V0cyhhc3NldFVpZCkuaW5jbHVkZUZhbGxiYWNrKCkuZmV0Y2goKVxuICAgICAgICogQHJldHVybnMge0Fzc2V0fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbmNsdWRlRmFsbGJhY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jbHVkZUZhbGxiYWNrKCkge1xuICAgICAgdGhpcy5fcXVlcnkuaW5jbHVkZV9mYWxsYmFjayA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIEBtZXRob2QgaW5jbHVkZU1ldGFkYXRhXG4gICAgICAgKiBAbWVtYmVyT2YgQXNzZXRcbiAgICAgICAqIEBkZXNjcmlwdGlvbiBJbmNsdWRlIHRoZSBtZXRhZGF0YSBmb3IgZ2V0dGluZyBtZXRhZGF0YSBjb250ZW50IGZvciB0aGUgYXNzZXQuXG4gICAgICAgKiBAZXhhbXBsZSBzdGFjay5Db250ZW50VHlwZShjb250ZW50VHlwZV91aWQpLkFzc2V0cyhhc3NldFVpZCkuaW5jbHVkZU1ldGFkYXRhKCkuZmV0Y2goKVxuICAgICAgICogQHJldHVybnMge0Fzc2V0fVxuICAgICAgICogQGluc3RhbmNlXG4gICAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJpbmNsdWRlTWV0YWRhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5jbHVkZU1ldGFkYXRhKCkge1xuICAgICAgdGhpcy5fcXVlcnkuaW5jbHVkZV9tZXRhZGF0YSA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmV0Y2hlcyBhIHBhcnRpY3VsYXIgYXNzZXQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGFzc2V0IFVJRC5cbiAgICAgKiBAbWVtYmVyT2YgQXNzZXRzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBTdGFjay5Bc3NldHMoJ2Fzc2V0c191aWQnKS50b0pTT04oKS5mZXRjaCgpXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBTdGFjay5Bc3NldHMoJ2Fzc2V0c191aWQnKS50b0pTT04oKS5mZXRjaCh7XG4gICAgICpcbiAgICAgKiAgICAgIH0pXG4gICAgICogQHJldHVybnMge3Byb21pc2V9XG4gICAgICogQGluc3RhbmNlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZmV0Y2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmV0Y2goZmV0Y2hPcHRpb25zKSB7XG4gICAgICBpZiAodGhpcy5hc3NldF91aWQpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0UGFyYW1zID0ge1xuICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgIGhlYWRlcnM6IFV0aWxzLm1lcmdlRGVlcCh7fSwgdGhpcy5oZWFkZXJzKSxcbiAgICAgICAgICB1cmw6IHRoaXMuY29uZmlnLnByb3RvY29sICsgJzovLycgKyB0aGlzLmNvbmZpZy5ob3N0ICsgJzonICsgdGhpcy5jb25maWcucG9ydCArICcvJyArIHRoaXMuY29uZmlnLnZlcnNpb24gKyB0aGlzLmNvbmZpZy51cmxzLmFzc2V0cyArIHRoaXMuYXNzZXRfdWlkLFxuICAgICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAgIF9tZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgcXVlcnk6IHRoaXMuX3F1ZXJ5XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IFV0aWxzLm1lcmdlRGVlcCh0aGlzLmZldGNoT3B0aW9ucywgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIFV0aWxzLnNlbmRSZXF1ZXN0KFV0aWxzLm1lcmdlRGVlcCh7fSwgdGhpcyksIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZldGNoT3B0aW9ucy5kZWJ1ZykgZmV0Y2hPcHRpb25zLmxvZ0hhbmRsZXIoJ2Vycm9yJywgXCJLaW5kbHkgcHJvdmlkZSBhbiBhc3NldCB1aWQuIGUuZy4gLkFzc2V0cygnYXNzZXRfdWlkJylcIik7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2NDE6XG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5mdW5jdGlvbiBfdHlwZW9mKG8pIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHtcbiAgICByZXR1cm4gdHlwZW9mIG87XG4gIH0gOiBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvO1xuICB9LCBfdHlwZW9mKG8pO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgY2FjaGUgPSBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChfX3dlYnBhY2tfcmVxdWlyZV9fKDk0KSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChlLCB0KSB7XG4gIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFdlYWtNYXApIHZhciByID0gbmV3IFdlYWtNYXAoKSxcbiAgICBuID0gbmV3IFdlYWtNYXAoKTtcbiAgcmV0dXJuIChfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZCA9IGZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKGUsIHQpIHtcbiAgICBpZiAoIXQgJiYgZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBvLFxuICAgICAgaSxcbiAgICAgIGYgPSB7XG4gICAgICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICAgICAgXCJkZWZhdWx0XCI6IGVcbiAgICAgIH07XG4gICAgaWYgKG51bGwgPT09IGUgfHwgXCJvYmplY3RcIiAhPSBfdHlwZW9mKGUpICYmIFwiZnVuY3Rpb25cIiAhPSB0eXBlb2YgZSkgcmV0dXJuIGY7XG4gICAgaWYgKG8gPSB0ID8gbiA6IHIpIHtcbiAgICAgIGlmIChvLmhhcyhlKSkgcmV0dXJuIG8uZ2V0KGUpO1xuICAgICAgby5zZXQoZSwgZik7XG4gICAgfVxuICAgIGZvciAodmFyIF90IGluIGUpIFwiZGVmYXVsdFwiICE9PSBfdCAmJiB7fS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsIF90KSAmJiAoKGkgPSAobyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihlLCBfdCkpICYmIChpLmdldCB8fCBpLnNldCkgPyBvKGYsIF90LCBpKSA6IGZbX3RdID0gZVtfdF0pO1xuICAgIHJldHVybiBmO1xuICB9KShlLCB0KTtcbn1cbnZhciBsb2NhbFN0b3JhZ2UgPSB7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG5sb2NhbFN0b3JhZ2UuZ2V0ID0gZnVuY3Rpb24gKGtleSwgY2FsbGJhY2spIHtcbiAgdHJ5IHtcbiAgICBjYWxsYmFjayhudWxsLCBjYWNoZS5nZXQoa2V5KSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWxsYmFjayhlKTtcbiAgfVxufTtcbmxvY2FsU3RvcmFnZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgdHJ5IHtcbiAgICBpZiAoa2V5ICYmIHZhbHVlKSBjYWNoZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgY2FsbGJhY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNhbGxiYWNrKGUpO1xuICB9XG59O1xuZnVuY3Rpb24gY2xlYXJWYWx1ZXNGb3JLZXkoa2V5QXJyYXksIGFwcGVuZCkge1xuICBpZiAoIWFwcGVuZCAmJiBrZXlBcnJheSAmJiBrZXlBcnJheS5sZW5ndGgpIGtleUFycmF5LnB1c2goJycpO1xuICB2YXIgX2tleTtcbiAgdmFyIGtleXMgPSBjYWNoZS5nZXRLZXlzKCk7XG4gIHZhciBzdG9yYWdlID0gY2FjaGUuZ2V0U3RvcmFnZSgpO1xuICBpZiAoIWtleUFycmF5IHx8ICFrZXlBcnJheS5sZW5ndGgpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgX2kgPSBrZXlzLmxlbmd0aDsgaSA8IF9pOyBpKyspIHtcbiAgICAgIGRlbGV0ZSBzdG9yYWdlW2tleXNbaV1dO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBfa2V5ID0ga2V5QXJyYXkuam9pbignLicpO1xuICAgIGZvciAodmFyIF9pMiA9IDAsIF9pMyA9IGtleXMubGVuZ3RoOyBfaTIgPCBfaTM7IF9pMisrKSB7XG4gICAgICBpZiAoa2V5c1tfaTJdICYmIGtleXNbX2kyXS5pbmRleE9mKF9rZXkpID09PSAwKSBkZWxldGUgc3RvcmFnZVtrZXlzW19pMl1dO1xuICAgIH1cbiAgfVxufVxubG9jYWxTdG9yYWdlLmNsZWFyQnlDb250ZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMiB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICB2YXIgX2NhbGxiYWNrID0gYXJncy5zcGxpY2UoLTEsIDEpLnBvcCgpO1xuICAgICAgdmFyIHZhbHVlQXJyYXkgPSBbXTtcbiAgICAgIHZhbHVlQXJyYXkucHVzaC5hcHBseSh2YWx1ZUFycmF5LCBhcmdzKTtcbiAgICAgIGNsZWFyVmFsdWVzRm9yS2V5KHZhbHVlQXJyYXkpO1xuICAgICAgX2NhbGxiYWNrKCk7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgY2FsbGJhY2soZSk7XG4gIH1cbn07XG5sb2NhbFN0b3JhZ2UuY2xlYXJCeVF1ZXJ5ID0gZnVuY3Rpb24gKHF1ZXJ5LCBjYWxsYmFjaykge1xuICB0cnkge1xuICAgIHZhciBrZXlzID0gY2FjaGUuZ2V0S2V5cygpO1xuICAgIHZhciBzdG9yYWdlID0gY2FjaGUuZ2V0U3RvcmFnZSgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBfaSA9IGtleXMubGVuZ3RoOyBpIDwgX2k7IGkrKykge1xuICAgICAgaWYgKGtleXNbaV0gJiYgfmtleXNbaV0uaW5kZXhPZihxdWVyeSkpIGRlbGV0ZSBzdG9yYWdlW2tleXNbaV1dO1xuICAgIH1cbiAgICBjYWxsYmFjaygpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgY2FsbGJhY2soZSk7XG4gIH1cbn07XG5sb2NhbFN0b3JhZ2UuY2xlYXJBbGwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdHJ5IHtcbiAgICBjbGVhclZhbHVlc0ZvcktleSgpO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjYWxsYmFjayhlKTtcbiAgfVxufTtcbnZhciBfZGVmYXVsdCA9IGV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbG9jYWxTdG9yYWdlO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjk2OlxuLyoqKi8gKChtb2R1bGUpID0+IHtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwibG9jYWxTdG9yYWdlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gNjk3OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgQ29udGVudHN0YWNrUmVnaW9uID0ge1xuICBFVTogJ2V1JyxcbiAgVVM6ICd1cycsXG4gIEFVOiAnYXUnLFxuICBBWlVSRV9OQTogJ2F6dXJlLW5hJyxcbiAgQVpVUkVfRVU6ICdhenVyZS1ldScsXG4gIEdDUF9OQTogJ2djcC1uYScsXG4gIEdDUF9FVTogJ2djcC1ldSdcbn07XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IENvbnRlbnRzdGFja1JlZ2lvbjtcblxuLyoqKi8gfSksXG5cbi8qKiovIDcyMjpcbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVzNi1wcm9taXNlXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODgwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgX2xvY2FsU3RvcmFnZSA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2OTYpKTtcbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoZSkge1xuICByZXR1cm4gZSAmJiBlLl9fZXNNb2R1bGUgPyBlIDoge1xuICAgIFwiZGVmYXVsdFwiOiBlXG4gIH07XG59XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IF9sb2NhbFN0b3JhZ2VbXCJkZWZhdWx0XCJdO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gOTI1OlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5fdHlwZSA9IF90eXBlO1xuZXhwb3J0cy5nZW5lcmF0ZUhhc2ggPSBnZW5lcmF0ZUhhc2g7XG5leHBvcnRzLmdldEhhc2ggPSBnZXRIYXNoO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5leHBvcnRzLm1lcmdlID0gbWVyZ2U7XG5leHBvcnRzLm1lcmdlRGVlcCA9IG1lcmdlRGVlcDtcbmV4cG9ydHMucGFyc2VRdWVyeUZyb21QYXJhbXMgPSBwYXJzZVF1ZXJ5RnJvbVBhcmFtcztcbmV4cG9ydHMucmVzdWx0V3JhcHBlciA9IHJlc3VsdFdyYXBwZXI7XG5leHBvcnRzLnNlbmRSZXF1ZXN0ID0gc2VuZFJlcXVlc3Q7XG5leHBvcnRzLnNwcmVhZFJlc3VsdCA9IHNwcmVhZFJlc3VsdDtcbmV4cG9ydHMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xudmFyIF9yZXF1ZXN0ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE4NSkpO1xudmFyIF9yZXN1bHQgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjA5KSk7XG52YXIgX21lc3NhZ2VzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3NCkpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7XG4gIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgXCJkZWZhdWx0XCI6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvcigpIHtcbiAgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9iYWJlbC9iYWJlbC9ibG9iL21haW4vcGFja2FnZXMvYmFiZWwtaGVscGVycy9MSUNFTlNFICovdmFyIGUsXG4gICAgdCxcbiAgICByID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICBuID0gci5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICBvID0gci50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcbiAgZnVuY3Rpb24gaShyLCBuLCBvLCBpKSB7XG4gICAgdmFyIGMgPSBuICYmIG4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gbiA6IEdlbmVyYXRvcixcbiAgICAgIHUgPSBPYmplY3QuY3JlYXRlKGMucHJvdG90eXBlKTtcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBcIl9pbnZva2VcIiwgZnVuY3Rpb24gKHIsIG4sIG8pIHtcbiAgICAgIHZhciBpLFxuICAgICAgICBjLFxuICAgICAgICB1LFxuICAgICAgICBmID0gMCxcbiAgICAgICAgcCA9IG8gfHwgW10sXG4gICAgICAgIHkgPSAhMSxcbiAgICAgICAgRyA9IHtcbiAgICAgICAgICBwOiAwLFxuICAgICAgICAgIG46IDAsXG4gICAgICAgICAgdjogZSxcbiAgICAgICAgICBhOiBkLFxuICAgICAgICAgIGY6IGQuYmluZChlLCA0KSxcbiAgICAgICAgICBkOiBmdW5jdGlvbiBkKHQsIHIpIHtcbiAgICAgICAgICAgIHJldHVybiBpID0gdCwgYyA9IDAsIHUgPSBlLCBHLm4gPSByLCBhO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIGQociwgbikge1xuICAgICAgICBmb3IgKGMgPSByLCB1ID0gbiwgdCA9IDA7ICF5ICYmIGYgJiYgIW8gJiYgdCA8IHAubGVuZ3RoOyB0KyspIHtcbiAgICAgICAgICB2YXIgbyxcbiAgICAgICAgICAgIGkgPSBwW3RdLFxuICAgICAgICAgICAgZCA9IEcucCxcbiAgICAgICAgICAgIGwgPSBpWzJdO1xuICAgICAgICAgIHIgPiAzID8gKG8gPSBsID09PSBuKSAmJiAodSA9IGlbKGMgPSBpWzRdKSA/IDUgOiAoYyA9IDMsIDMpXSwgaVs0XSA9IGlbNV0gPSBlKSA6IGlbMF0gPD0gZCAmJiAoKG8gPSByIDwgMiAmJiBkIDwgaVsxXSkgPyAoYyA9IDAsIEcudiA9IG4sIEcubiA9IGlbMV0pIDogZCA8IGwgJiYgKG8gPSByIDwgMyB8fCBpWzBdID4gbiB8fCBuID4gbCkgJiYgKGlbNF0gPSByLCBpWzVdID0gbiwgRy5uID0gbCwgYyA9IDApKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobyB8fCByID4gMSkgcmV0dXJuIGE7XG4gICAgICAgIHRocm93IHkgPSAhMCwgbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jdGlvbiAobywgcCwgbCkge1xuICAgICAgICBpZiAoZiA+IDEpIHRocm93IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICAgIGZvciAoeSAmJiAxID09PSBwICYmIGQocCwgbCksIGMgPSBwLCB1ID0gbDsgKHQgPSBjIDwgMiA/IGUgOiB1KSB8fCAheTspIHtcbiAgICAgICAgICBpIHx8IChjID8gYyA8IDMgPyAoYyA+IDEgJiYgKEcubiA9IC0xKSwgZChjLCB1KSkgOiBHLm4gPSB1IDogRy52ID0gdSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMiwgaSkge1xuICAgICAgICAgICAgICBpZiAoYyB8fCAobyA9IFwibmV4dFwiKSwgdCA9IGlbb10pIHtcbiAgICAgICAgICAgICAgICBpZiAoISh0ID0gdC5jYWxsKGksIHUpKSkgdGhyb3cgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF0LmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIHUgPSB0LnZhbHVlLCBjIDwgMiAmJiAoYyA9IDApO1xuICAgICAgICAgICAgICB9IGVsc2UgMSA9PT0gYyAmJiAodCA9IGlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbChpKSwgYyA8IDIgJiYgKHUgPSBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG8gKyBcIicgbWV0aG9kXCIpLCBjID0gMSk7XG4gICAgICAgICAgICAgIGkgPSBlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgodCA9ICh5ID0gRy5uIDwgMCkgPyB1IDogci5jYWxsKG4sIEcpKSAhPT0gYSkgYnJlYWs7XG4gICAgICAgICAgfSBjYXRjaCAodCkge1xuICAgICAgICAgICAgaSA9IGUsIGMgPSAxLCB1ID0gdDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZiA9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHQsXG4gICAgICAgICAgZG9uZTogeVxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9KHIsIG8sIGkpLCAhMCksIHU7XG4gIH1cbiAgdmFyIGEgPSB7fTtcbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG4gIHQgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG4gIHZhciBjID0gW11bbl0gPyB0KHQoW11bbl0oKSkpIDogKF9yZWdlbmVyYXRvckRlZmluZTIodCA9IHt9LCBuLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9KSwgdCksXG4gICAgdSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGMpO1xuICBmdW5jdGlvbiBmKGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChlLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBfcmVnZW5lcmF0b3JEZWZpbmUyKGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUodSksIGU7XG4gIH1cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBfcmVnZW5lcmF0b3JEZWZpbmUyKHUsIFwiY29uc3RydWN0b3JcIiwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpLCBfcmVnZW5lcmF0b3JEZWZpbmUyKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBcIkdlbmVyYXRvckZ1bmN0aW9uXCIsIF9yZWdlbmVyYXRvckRlZmluZTIoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIG8sIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIF9yZWdlbmVyYXRvckRlZmluZTIodSksIF9yZWdlbmVyYXRvckRlZmluZTIodSwgbywgXCJHZW5lcmF0b3JcIiksIF9yZWdlbmVyYXRvckRlZmluZTIodSwgbiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgX3JlZ2VuZXJhdG9yRGVmaW5lMih1LCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSksIChfcmVnZW5lcmF0b3IgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHc6IGksXG4gICAgICBtOiBmXG4gICAgfTtcbiAgfSkoKTtcbn1cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvckRlZmluZTIoZSwgciwgbiwgdCkge1xuICB2YXIgaSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbiAgdHJ5IHtcbiAgICBpKHt9LCBcIlwiLCB7fSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpID0gMDtcbiAgfVxuICBfcmVnZW5lcmF0b3JEZWZpbmUyID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yRGVmaW5lKGUsIHIsIG4sIHQpIHtcbiAgICBpZiAocikgaSA/IGkoZSwgciwge1xuICAgICAgdmFsdWU6IG4sXG4gICAgICBlbnVtZXJhYmxlOiAhdCxcbiAgICAgIGNvbmZpZ3VyYWJsZTogIXQsXG4gICAgICB3cml0YWJsZTogIXRcbiAgICB9KSA6IGVbcl0gPSBuO2Vsc2Uge1xuICAgICAgdmFyIG8gPSBmdW5jdGlvbiBvKHIsIG4pIHtcbiAgICAgICAgX3JlZ2VuZXJhdG9yRGVmaW5lMihlLCByLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UociwgbiwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIG8oXCJuZXh0XCIsIDApLCBvKFwidGhyb3dcIiwgMSksIG8oXCJyZXR1cm5cIiwgMik7XG4gICAgfVxuICB9LCBfcmVnZW5lcmF0b3JEZWZpbmUyKGUsIHIsIG4sIHQpO1xufVxuZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKG4sIHQsIGUsIHIsIG8sIGEsIGMpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaSA9IG5bYV0oYyksXG4gICAgICB1ID0gaS52YWx1ZTtcbiAgfSBjYXRjaCAobikge1xuICAgIHJldHVybiB2b2lkIGUobik7XG4gIH1cbiAgaS5kb25lID8gdCh1KSA6IFByb21pc2UucmVzb2x2ZSh1KS50aGVuKHIsIG8pO1xufVxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3Iobikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ID0gdGhpcyxcbiAgICAgIGUgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyLCBvKSB7XG4gICAgICB2YXIgYSA9IG4uYXBwbHkodCwgZSk7XG4gICAgICBmdW5jdGlvbiBfbmV4dChuKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChhLCByLCBvLCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgbik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdGhyb3cobikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoYSwgciwgbywgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBuKTtcbiAgICAgIH1cbiAgICAgIF9uZXh0KHZvaWQgMCk7XG4gICAgfSk7XG4gIH07XG59XG5mdW5jdGlvbiBfdHlwZW9mMihvKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZjIgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2YyKG8pO1xufVxuLyoqXG4gKiBAbWV0aG9kIGFkZFNwcmVhZFxuICogQGRlc2NyaXB0aW9uIG1ldGhvZCB0byBhZGQgdGhlIHNwcmVhZC5cbiAqL1xuKGZ1bmN0aW9uIGFkZFNwcmVhZCgpIHtcbiAgaWYgKFByb21pc2UucHJvdG90eXBlLnNwcmVhZCkgcmV0dXJuO1xuICBQcm9taXNlLnByb3RvdHlwZS5zcHJlYWQgPSBmdW5jdGlvbiAoZm4sIGVyckZ1bmMpIHtcbiAgICBlcnJGdW5jID0gZXJyRnVuYyB8fCBmdW5jdGlvbiAoZXJyKSB7fTtcbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoZm4sIGFyZ3MpO1xuICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGVycikge1xuICAgICAgZXJyRnVuYyhlcnIpO1xuICAgIH0pO1xuICB9O1xufSkoKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybSh0eXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcXVlcnlbdHlwZV0gPSB0aGlzLl9xdWVyeVt0eXBlXSB8fCB7fTtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzBdKSB8fCB0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMuX3F1ZXJ5W3R5cGVdLkJBU0UgfHwgW107XG4gICAgICAgICAgcXVlcnkgPSBxdWVyeS5jb25jYXQoYXJndW1lbnRzWzBdKTtcbiAgICAgICAgICB0aGlzLl9xdWVyeVt0eXBlXS5CQVNFID0gcXVlcnk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihfbWVzc2FnZXNbXCJkZWZhdWx0XCJdLlRSQU5TRk9STV9JTlZBTElEX1NJTkdMRV9QQVJBTSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzBdID09PSAnc3RyaW5nJyAmJiAoQXJyYXkuaXNBcnJheShhcmd1bWVudHNbMV0pIHx8IHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgIHZhciBfcXVlcnkyID0gdGhpcy5fcXVlcnlbdHlwZV1bYXJndW1lbnRzWzBdXSB8fCBbXTtcbiAgICAgICAgICBfcXVlcnkyID0gX3F1ZXJ5Mi5jb25jYXQoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgICB0aGlzLl9xdWVyeVt0eXBlXVthcmd1bWVudHNbMF1dID0gX3F1ZXJ5MjtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKF9tZXNzYWdlc1tcImRlZmF1bHRcIl0uVFJBTlNGT1JNX0lOVkFMSURfRE9VQkxFX1BBUkFNKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoX21lc3NhZ2VzW1wiZGVmYXVsdFwiXS5UUkFOU0ZPUk1fSU5WQUxJRF9QQVJBTV9DT1VOVCk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gX3R5cGUodmFsKSB7XG4gIHZhciBfdHlwZW9mO1xuICB2YXIgX190eXBlb2YgPSBfdHlwZW9mMih2YWwpO1xuICBpZiAoX190eXBlb2YgPT09ICdvYmplY3QnKSB7XG4gICAgX3R5cGVvZiA9IF9fdHlwZW9mO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgIF9fdHlwZW9mID0gJ2FycmF5JztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgX3R5cGVvZiA9IF9fdHlwZW9mO1xuICB9XG4gIHJldHVybiBfX3R5cGVvZjtcbn1cblxuLy8gbWVyZ2UgdHdvIG9iamVjdHNcbmZ1bmN0aW9uIG1lcmdlRGVlcChkZXN0aW5hdGlvbiwgc291cmNlVmFyKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIF9tZXJnZV9yZWN1cnNpdmUyID0gZnVuY3Rpb24gX21lcmdlX3JlY3Vyc2l2ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChzZWxmLl90eXBlKHNvdXJjZVtrZXldKSA9PSAnb2JqZWN0JyAmJiBzZWxmLl90eXBlKHRhcmdldFtrZXldKSA9PSBzZWxmLl90eXBlKHNvdXJjZVtrZXldKSkge1xuICAgICAgICBfbWVyZ2VfcmVjdXJzaXZlMih0YXJnZXRba2V5XSwgc291cmNlW2tleV0pO1xuICAgICAgfSBlbHNlIGlmIChzZWxmLl90eXBlKHNvdXJjZVtrZXldKSA9PSAnYXJyYXknICYmIHNlbGYuX3R5cGUodGFyZ2V0W2tleV0pID09IHNlbGYuX3R5cGUoc291cmNlW2tleV0pKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gdGFyZ2V0W2tleV0uY29uY2F0KHNvdXJjZVtrZXldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBfbWVyZ2VfcmVjdXJzaXZlMihkZXN0aW5hdGlvbiwgc291cmNlVmFyKTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufVxuXG4vLyBtZXJnZSB0d28gb2JqZWN0c1xuZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgaWYgKHRhcmdldCAmJiBzb3VyY2UpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyByZXR1cm4gdHJ1ZSBpZiBwcm9jZXNzIGlzIHJ1bm5pbmcgaW4gYnJvd3NlciBlbHNlIGZhbHNlXG5mdW5jdGlvbiBpc0Jyb3dzZXIoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcbn1cblxuLy8gcmV0dXJuIHRoZSBxdWVyeSBmcm9tIHRoZSBwYXJhbXNcbmZ1bmN0aW9uIHBhcnNlUXVlcnlGcm9tUGFyYW1zKHF1ZXJ5T2JqZWN0LCBzaW5nbGUsIHRvSlNPTikge1xuICBpZiAocXVlcnlPYmplY3QgJiYgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcykge1xuICAgIHZhciBfcXVlcnkgPSBtZXJnZSh7fSwgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5ib2R5ID8gcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5ib2R5LnF1ZXJ5IHx8IHt9IDoge30pO1xuICAgIGlmIChfcXVlcnkuZW52aXJvbm1lbnRfdWlkKSB7XG4gICAgICBkZWxldGUgX3F1ZXJ5LmVudmlyb25tZW50X3VpZDtcbiAgICAgIF9xdWVyeS5lbnZpcm9ubWVudCA9IHF1ZXJ5T2JqZWN0LmVudmlyb25tZW50O1xuICAgIH1cbiAgICBfcXVlcnkuZW52aXJvbm1lbnQgPSBxdWVyeU9iamVjdC5lbnZpcm9ubWVudDtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudF90eXBlX3VpZDogcXVlcnlPYmplY3QuY29udGVudF90eXBlX3VpZCxcbiAgICAgIGxvY2FsZTogX3F1ZXJ5LmxvY2FsZSB8fCAnZW4tdXMnLFxuICAgICAgcXVlcnk6IF9xdWVyeSxcbiAgICAgIGVudHJ5X3VpZDogcXVlcnlPYmplY3QuZW50cnlfdWlkLFxuICAgICAgYXNzZXRfdWlkOiBxdWVyeU9iamVjdC5hc3NldF91aWQsXG4gICAgICBzaW5nbGU6IHNpbmdsZSB8fCAnZmFsc2UnLFxuICAgICAgdG9KU09OOiB0b0pTT04gfHwgJ2ZhbHNlJyxcbiAgICAgIGFwaV9rZXk6IHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuaGVhZGVycyA/IHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuaGVhZGVycy5hcGlfa2V5IDogJydcbiAgICB9O1xuICB9XG59XG5cbi8vIHJldHVybiB0aGUgaGFzaCB2YWx1ZSBvZiB0aGUgcXVlcnlcbmZ1bmN0aW9uIGdldEhhc2gocXVlcnkpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaGFzaFZhbHVlID0gZ2VuZXJhdGVIYXNoKEpTT04uc3RyaW5naWZ5KHF1ZXJ5KSk7XG4gICAgdmFyIGtleUFycmF5ID0gW107XG4gICAga2V5QXJyYXkucHVzaChxdWVyeS5jb250ZW50X3R5cGVfdWlkKTtcbiAgICBrZXlBcnJheS5wdXNoKHF1ZXJ5LmxvY2FsZSk7XG4gICAgaWYgKHF1ZXJ5LmVudHJ5X3VpZCkga2V5QXJyYXkucHVzaChxdWVyeS5lbnRyeV91aWQpO1xuICAgIGlmIChxdWVyeS5hc3NldF91aWQpIGtleUFycmF5LnB1c2gocXVlcnkuYXNzZXRfdWlkKTtcbiAgICBrZXlBcnJheS5wdXNoKGhhc2hWYWx1ZSk7XG4gICAgcmV0dXJuIGtleUFycmF5LmpvaW4oJy4nKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxuLy8gcmV0dXJuIHRoZSBoYXNoIHZhbHVlIG9mIHRoZSBzdHJpbmdcbmZ1bmN0aW9uIGdlbmVyYXRlSGFzaChzdHIpIHtcbiAgdmFyIGhhc2ggPSAwO1xuICB2YXIgaTtcbiAgdmFyIGNocjtcbiAgdmFyIGxlbjtcbiAgaWYgKHN0ci5sZW5ndGggPT09IDApIHJldHVybiBoYXNoO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBzdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjaHIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgY2hyO1xuICAgIGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG4gIH1cbiAgcmV0dXJuIGhhc2ggPCAtMSA/IGhhc2ggKiAtMSA6IGhhc2g7XG59XG5cbi8vIGdlbmVyYXRlIHRoZSBSZXN1bHQgb2JqZWN0XG5mdW5jdGlvbiByZXN1bHRXcmFwcGVyKHJlc3VsdCkge1xuICBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQuZW50cmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAocmVzdWx0LmVudHJpZXMgJiYgcmVzdWx0LmVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgX2kgPSByZXN1bHQuZW50cmllcy5sZW5ndGg7IGkgPCBfaTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5lbnRyaWVzW2ldID0gKDAsIF9yZXN1bHRbXCJkZWZhdWx0XCJdKShyZXN1bHQuZW50cmllc1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5lbnRyaWVzID0gW107XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlc3VsdCAmJiByZXN1bHQuYXNzZXRzICYmIHR5cGVvZiByZXN1bHQuYXNzZXRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChyZXN1bHQuYXNzZXRzICYmIHJlc3VsdC5hc3NldHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBqID0gMCwgX2ogPSByZXN1bHQuYXNzZXRzLmxlbmd0aDsgaiA8IF9qOyBqKyspIHtcbiAgICAgICAgcmVzdWx0LmFzc2V0c1tqXSA9ICgwLCBfcmVzdWx0W1wiZGVmYXVsdFwiXSkocmVzdWx0LmFzc2V0c1tqXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5hc3NldHMgPSBbXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmVzdWx0ICYmIHR5cGVvZiByZXN1bHQuZW50cnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmVzdWx0LmVudHJ5ID0gKDAsIF9yZXN1bHRbXCJkZWZhdWx0XCJdKShyZXN1bHQuZW50cnkpO1xuICB9IGVsc2UgaWYgKHJlc3VsdCAmJiB0eXBlb2YgcmVzdWx0LmFzc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJlc3VsdC5hc3NldCA9ICgwLCBfcmVzdWx0W1wiZGVmYXVsdFwiXSkocmVzdWx0LmFzc2V0KTtcbiAgfSBlbHNlIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC5pdGVtcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXN1bHQuaXRlbXMgPSAoMCwgX3Jlc3VsdFtcImRlZmF1bHRcIl0pKHJlc3VsdC5pdGVtcykudG9KU09OKCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3ByZWFkIHRoZSByZXN1bHQgb2JqZWN0XG5mdW5jdGlvbiBzcHJlYWRSZXN1bHQocmVzdWx0KSB7XG4gIHZhciBfcmVzdWx0cyA9IFtdO1xuICBpZiAocmVzdWx0ICYmIE9iamVjdC5rZXlzKHJlc3VsdCkubGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiByZXN1bHQuZW50cmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIF9yZXN1bHRzLnB1c2gocmVzdWx0LmVudHJpZXMpO1xuICAgICAgaWYgKHJlc3VsdC5jb250ZW50X3R5cGUpIHtcbiAgICAgICAgX3Jlc3VsdHMuc2NoZW1hID0gcmVzdWx0LmNvbnRlbnRfdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQuYXNzZXRzICE9PSAndW5kZWZpbmVkJykgX3Jlc3VsdHMucHVzaChyZXN1bHQuYXNzZXRzKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdC5jb250ZW50X3R5cGUgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiByZXN1bHQuc2NoZW1hICE9PSAndW5kZWZpbmVkJykgX3Jlc3VsdHMucHVzaChyZXN1bHQuY29udGVudF90eXBlIHx8IHJlc3VsdC5zY2hlbWEpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0LmNvdW50ICE9PSAndW5kZWZpbmVkJykgX3Jlc3VsdHMucHVzaChyZXN1bHQuY291bnQpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0LmVudHJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgX3Jlc3VsdHMgPSByZXN1bHQuZW50cnk7XG4gICAgICBpZiAocmVzdWx0LnNjaGVtYSkge1xuICAgICAgICBfcmVzdWx0cy5zY2hlbWEgPSByZXN1bHQuc2NoZW1hO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdC5jb250ZW50X3R5cGUpIHtcbiAgICAgICAgX3Jlc3VsdHMuY29udGVudF90eXBlID0gcmVzdWx0LmNvbnRlbnRfdHlwZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiByZXN1bHQuYXNzZXQgIT09ICd1bmRlZmluZWQnKSBfcmVzdWx0cyA9IHJlc3VsdC5hc3NldDtcbiAgICBpZiAodHlwZW9mIHJlc3VsdC5pdGVtcyAhPT0gJ3VuZGVmaW5lZCcpIF9yZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgfVxuICByZXR1cm4gX3Jlc3VsdHM7XG59XG5mdW5jdGlvbiBzZW5kUmVxdWVzdChxdWVyeU9iamVjdCwgb3B0aW9ucykge1xuICB2YXIgZW52X3VpZCA9IHF1ZXJ5T2JqZWN0LmVudmlyb25tZW50X3VpZDtcbiAgaWYgKGVudl91aWQpIHtcbiAgICBxdWVyeU9iamVjdC5fcXVlcnkuZW52aXJvbm1lbnRfdWlkID0gZW52X3VpZDtcbiAgfSBlbHNlIHtcbiAgICBpZiAocXVlcnlPYmplY3QuX3F1ZXJ5KSB7XG4gICAgICBxdWVyeU9iamVjdC5fcXVlcnkuZW52aXJvbm1lbnQgPSBxdWVyeU9iamVjdC5lbnZpcm9ubWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnlPYmplY3QuX3F1ZXJ5ID0ge307XG4gICAgICBxdWVyeU9iamVjdC5fcXVlcnkuZW52aXJvbm1lbnQgPSBxdWVyeU9iamVjdC5lbnZpcm9ubWVudDtcbiAgICB9XG4gIH1cbiAgdmFyIHNlbGYgPSBxdWVyeU9iamVjdDtcbiAgdmFyIGNhY2hlUG9saWN5ID0gdHlwZW9mIHNlbGYucXVlcnlDYWNoZVBvbGljeSAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmLnF1ZXJ5Q2FjaGVQb2xpY3kgOiBzZWxmLmNhY2hlUG9saWN5O1xuICB2YXIgdG9qc29uID0gdHlwZW9mIHNlbGYudG9qc29uICE9PSAndW5kZWZpbmVkJyA/IHNlbGYudG9qc29uIDogZmFsc2U7XG4gIHZhciBpc1NpbmdsZSA9ICEhKHNlbGYuZW50cnlfdWlkIHx8IHNlbGYuc2luZ2xlRW50cnkgfHwgc2VsZi5hc3NldF91aWQpO1xuICB2YXIgaGFzaFF1ZXJ5ID0gZ2V0SGFzaChwYXJzZVF1ZXJ5RnJvbVBhcmFtcyhzZWxmLCBpc1NpbmdsZSwgdG9qc29uKSk7XG5cbiAgLyoqXG4gICAgZm9yIG5ldyBhcGkgdjNcbiAgICAqL1xuICBpZiAocXVlcnlPYmplY3QgJiYgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcyAmJiBxdWVyeU9iamVjdC5yZXF1ZXN0UGFyYW1zLmJvZHkgJiYgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5ib2R5LnF1ZXJ5KSB7XG4gICAgdmFyIGNsb25lUXVlcnlPYmogPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuYm9keS5xdWVyeSkpO1xuICAgIGlmIChfdHlwZW9mMihjbG9uZVF1ZXJ5T2JqKSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGNsb25lUXVlcnlPYmogPSBKU09OLnBhcnNlKGNsb25lUXVlcnlPYmopO1xuICAgIH1cbiAgICBkZWxldGUgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5ib2R5LnF1ZXJ5O1xuICAgIHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuYm9keSA9IG1lcmdlKHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuYm9keSwgY2xvbmVRdWVyeU9iaik7XG4gICAgaWYgKHF1ZXJ5T2JqZWN0LmxpdmVfcHJldmlldyAmJiBxdWVyeU9iamVjdC5saXZlX3ByZXZpZXcuZW5hYmxlID09PSB0cnVlICYmIHF1ZXJ5T2JqZWN0LmxpdmVfcHJldmlldy5saXZlX3ByZXZpZXcgJiYgcXVlcnlPYmplY3QubGl2ZV9wcmV2aWV3LmxpdmVfcHJldmlldyAhPT0gJ2luaXQnKSB7XG4gICAgICBxdWVyeU9iamVjdC5yZXF1ZXN0UGFyYW1zLmJvZHkgPSBtZXJnZShxdWVyeU9iamVjdC5yZXF1ZXN0UGFyYW1zLmJvZHksIHtcbiAgICAgICAgbGl2ZV9wcmV2aWV3OiBxdWVyeU9iamVjdC5saXZlX3ByZXZpZXcubGl2ZV9wcmV2aWV3IHx8ICdpbml0J1xuICAgICAgfSk7XG4gICAgICBjYWNoZVBvbGljeSA9IDI7IC8vIG5ldHdvcmsgZWxzZSBjYWNoZVxuICAgICAgaWYgKHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuYm9keS5lbnZpcm9ubWVudCkge1xuICAgICAgICBkZWxldGUgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5ib2R5LmVudmlyb25tZW50O1xuICAgICAgfVxuICAgICAgaWYgKHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuaGVhZGVycy5hY2Nlc3NfdG9rZW4pIHtcbiAgICAgICAgZGVsZXRlIHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuaGVhZGVycy5hY2Nlc3NfdG9rZW47XG4gICAgICB9XG4gICAgICBkZWxldGUgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICBkZWxldGUgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5oZWFkZXJzLnByZXZpZXdfdG9rZW47XG4gICAgICBpZiAocXVlcnlPYmplY3QubGl2ZV9wcmV2aWV3LnByZXZpZXdfdG9rZW4pIHtcbiAgICAgICAgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5oZWFkZXJzLnByZXZpZXdfdG9rZW4gPSBxdWVyeU9iamVjdC5saXZlX3ByZXZpZXcucHJldmlld190b2tlbjtcbiAgICAgICAgcXVlcnlPYmplY3QucmVxdWVzdFBhcmFtcy5oZWFkZXJzLmxpdmVfcHJldmlldyA9IHF1ZXJ5T2JqZWN0LmxpdmVfcHJldmlldy5saXZlX3ByZXZpZXc7XG4gICAgICB9IGVsc2UgaWYgKHF1ZXJ5T2JqZWN0LmxpdmVfcHJldmlldy5tYW5hZ2VtZW50X3Rva2VuKSB7XG4gICAgICAgIHF1ZXJ5T2JqZWN0LnJlcXVlc3RQYXJhbXMuaGVhZGVycy5hdXRob3JpemF0aW9uID0gcXVlcnlPYmplY3QubGl2ZV9wcmV2aWV3Lm1hbmFnZW1lbnRfdG9rZW47XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBnZXRDYWNoZUNhbGxiYWNrID0gZnVuY3Rpb24gZ2V0Q2FjaGVDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgZW50cmllcykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiByZWplY3QoZXJyKTsgLy8gUHJvcGFnYXRlIHRoZSBlcnJvciB0byB0aGUgcGFyZW50IHByb21pc2VcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRvanNvbikgZW50cmllcyA9IHJlc3VsdFdyYXBwZXIoZW50cmllcyk7XG4gICAgICAgIHJlc29sdmUoc3ByZWFkUmVzdWx0KGVudHJpZXMpKTsgLy8gUHJvcGFnYXRlIHRoZSByZXN1bHQgdG8gdGhlIHBhcmVudCBwcm9taXNlXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlamVjdChlKTsgLy8gSGFuZGxlIGFueSBzeW5jaHJvbm91cyBlcnJvcnNcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhjb250aW51ZUZsYWcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgIGlmIChjb250aW51ZUZsYWcpIHtcbiAgICAgICgwLCBfcmVxdWVzdFtcImRlZmF1bHRcIl0pKHF1ZXJ5T2JqZWN0LCBvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2VsZi5lbnRyeV91aWQgPSBzZWxmLmFzc2V0X3VpZCA9IHNlbGYudG9qc29uID0gc2VsZi5xdWVyeUNhY2hlUG9saWN5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIHZhciBlbnRyaWVzID0ge307XG4gICAgICAgICAgdmFyIHN5bmNzdGFjayA9IHt9O1xuICAgICAgICAgIGlmIChxdWVyeU9iamVjdC5zaW5nbGVFbnRyeSkge1xuICAgICAgICAgICAgcXVlcnlPYmplY3Quc2luZ2xlRW50cnkgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChkYXRhLnNjaGVtYSkgZW50cmllcy5zY2hlbWEgPSBkYXRhLnNjaGVtYTtcbiAgICAgICAgICAgIGlmIChkYXRhLmNvbnRlbnRfdHlwZSkge1xuICAgICAgICAgICAgICBlbnRyaWVzLmNvbnRlbnRfdHlwZSA9IGRhdGEuY29udGVudF90eXBlO1xuICAgICAgICAgICAgICBkZWxldGUgZW50cmllcy5zY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5lbnRyaWVzICYmIGRhdGEuZW50cmllcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgZW50cmllcy5lbnRyeSA9IGRhdGEuZW50cmllc1swXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5hc3NldHMgJiYgZGF0YS5hc3NldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGVudHJpZXMuYXNzZXRzID0gZGF0YS5hc3NldHNbMF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoY2FjaGVQb2xpY3kgPT09IDIgJiYgc2VsZi5wcm92aWRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJvdmlkZXIuZ2V0KGhhc2hRdWVyeSwgZnVuY3Rpb24gKGVyciwgX2RhdGEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgIV9kYXRhIHx8IF9kYXRhLmVudHJpZXMubGVuZ3RoID09PSAwICYmIF9kYXRhLmFzc2V0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3JfY29kZTogMTQxLFxuICAgICAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIGVudHJ5IGRvZXNuXFwndCBleGlzdC4nXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZ2V0Q2FjaGVDYWxsYmFjayhyZXNvbHZlLCByZWplY3QpKGVyciwgX2RhdGEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KHtcbiAgICAgICAgICAgICAgICAgIGVycm9yX2NvZGU6IDE0MSxcbiAgICAgICAgICAgICAgICAgIGVycm9yX21lc3NhZ2U6ICdUaGUgcmVxdWVzdGVkIGVudHJ5IGRvZXNuXFwndCBleGlzdC4nXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGRhdGEuaXRlbXMpIHtcbiAgICAgICAgICAgIHN5bmNzdGFjayA9IHtcbiAgICAgICAgICAgICAgaXRlbXM6IGRhdGEuaXRlbXMsXG4gICAgICAgICAgICAgIHBhZ2luYXRpb25fdG9rZW46IGRhdGEucGFnaW5hdGlvbl90b2tlbixcbiAgICAgICAgICAgICAgc3luY190b2tlbjogZGF0YS5zeW5jX3Rva2VuLFxuICAgICAgICAgICAgICB0b3RhbF9jb3VudDogZGF0YS50b3RhbF9jb3VudFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZW50cmllcyA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjYWNoZVBvbGljeSAhPT0gLTEgJiYgc2VsZi5wcm92aWRlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2VsZi5wcm92aWRlci5zZXQoaGFzaFF1ZXJ5LCBlbnRyaWVzLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2pzb24pIGVudHJpZXMgPSByZXN1bHRXcmFwcGVyKGVudHJpZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHNwcmVhZFJlc3VsdChlbnRyaWVzKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHNwcmVhZFJlc3VsdChlbnRyaWVzKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzeW5jc3RhY2spLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoc3luY3N0YWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0b2pzb24pIHtcbiAgICAgICAgICAgIGVudHJpZXMgPSByZXN1bHRXcmFwcGVyKGVudHJpZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZShzcHJlYWRSZXN1bHQoZW50cmllcykpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIHJlamVjdCh7XG4gICAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChjYWNoZVBvbGljeSA9PT0gMiAmJiBzZWxmLnByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc2VsZi5wcm92aWRlci5nZXQoaGFzaFF1ZXJ5LCBnZXRDYWNoZUNhbGxiYWNrKHJlc29sdmUsIHJlamVjdCkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIHN3aXRjaCAoY2FjaGVQb2xpY3kpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvcigvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yKCkubShmdW5jdGlvbiBfY2FsbGVlMihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yKCkudyhmdW5jdGlvbiAoX2NvbnRleHQyKSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIubikge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKCEoc2VsZi5wcm92aWRlciAhPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uID0gMjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucHJvdmlkZXIuZ2V0KGhhc2hRdWVyeSwgLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBfcmVmMiA9IF9hc3luY1RvR2VuZXJhdG9yKC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3IoKS5tKGZ1bmN0aW9uIF9jYWxsZWUoZXJyLCBfZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX3Q7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3IoKS53KGZ1bmN0aW9uIChfY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnAgPSBfY29udGV4dC5uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnAgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShlcnIgfHwgIV9kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm4gPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0b2pzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZGF0YSA9IHJlc3VsdFdyYXBwZXIoX2RhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hKDIsIHJlc29sdmUoc3ByZWFkUmVzdWx0KF9kYXRhKSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uID0gNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnAgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfdCA9IF9jb250ZXh0LnY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hKDIsIHJlamVjdChfdCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYSgyKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUsIG51bGwsIFtbMCwgM11dKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3gzLCBfeDQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBfY29udGV4dDIubiA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICBjYWxsYmFjayh0cnVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWUyKTtcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKF94LCBfeDIpIHtcbiAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfSgpKTtcbiAgICBjYXNlIDI6XG4gICAgY2FzZSAwOlxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgIGNhc2UgLTE6XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBjYWxsYmFjayh0cnVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gIH1cbiAgaWYgKGNhY2hlUG9saWN5ID09PSAzKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBpZiAoc2VsZi5wcm92aWRlciAhPT0gbnVsbCkge1xuICAgICAgICBzZWxmLnByb3ZpZGVyLmdldChoYXNoUXVlcnksIGZ1bmN0aW9uIChlcnIsIF9kYXRhKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChlcnIgfHwgIV9kYXRhKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKCF0b2pzb24pIHtcbiAgICAgICAgICAgICAgICBfZGF0YSA9IHJlc3VsdFdyYXBwZXIoX2RhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoc3ByZWFkUmVzdWx0KF9kYXRhKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBjYWxsYmFjayh0cnVlLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSlbXCJjYXRjaFwiXShmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGNhbGxiYWNrKHRydWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKioqLyB9KSxcblxuLyoqKi8gOTQwOlxuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSB2b2lkIDA7XG52YXIgX2VzNlByb21pc2UgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNzIyKSk7XG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5fX2VzTW9kdWxlID8gZSA6IHtcbiAgICBcImRlZmF1bHRcIjogZVxuICB9O1xufVxuX2VzNlByb21pc2VbXCJkZWZhdWx0XCJdLnBvbHlmaWxsKCk7XG52YXIgX2RlZmF1bHQgPSBleHBvcnRzW1wiZGVmYXVsdFwiXSA9IGZldGNoOyAvLyBmZXRjaCBBUEkgYXZhaWxhYmxlIGluIE5vZGUuanMgMTggYW5kIGxhdGVyXG5cbi8qKiovIH0pLFxuXG4vKioqLyA5NDk6XG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG52YXIgX3N0YWNrID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM0OCkpO1xudmFyIF9pbmRleCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyODUpKTtcbnZhciBfY29udGVudHN0YWNrcmVnaW9uID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY5NykpO1xuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChlKSB7XG4gIHJldHVybiBlICYmIGUuX19lc01vZHVsZSA/IGUgOiB7XG4gICAgXCJkZWZhdWx0XCI6IGVcbiAgfTtcbn1cbmZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihyLCBlKSB7XG4gIHZhciB0ID0gXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKCF0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocikgfHwgKHQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkocikpIHx8IGUgJiYgciAmJiBcIm51bWJlclwiID09IHR5cGVvZiByLmxlbmd0aCkge1xuICAgICAgdCAmJiAociA9IHQpO1xuICAgICAgdmFyIF9uID0gMCxcbiAgICAgICAgRiA9IGZ1bmN0aW9uIEYoKSB7fTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHM6IEYsXG4gICAgICAgIG46IGZ1bmN0aW9uIG4oKSB7XG4gICAgICAgICAgcmV0dXJuIF9uID49IHIubGVuZ3RoID8ge1xuICAgICAgICAgICAgZG9uZTogITBcbiAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgZG9uZTogITEsXG4gICAgICAgICAgICB2YWx1ZTogcltfbisrXVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGU6IGZ1bmN0aW9uIGUocikge1xuICAgICAgICAgIHRocm93IHI7XG4gICAgICAgIH0sXG4gICAgICAgIGY6IEZcbiAgICAgIH07XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbiAgfVxuICB2YXIgbyxcbiAgICBhID0gITAsXG4gICAgdSA9ICExO1xuICByZXR1cm4ge1xuICAgIHM6IGZ1bmN0aW9uIHMoKSB7XG4gICAgICB0ID0gdC5jYWxsKHIpO1xuICAgIH0sXG4gICAgbjogZnVuY3Rpb24gbigpIHtcbiAgICAgIHZhciByID0gdC5uZXh0KCk7XG4gICAgICByZXR1cm4gYSA9IHIuZG9uZSwgcjtcbiAgICB9LFxuICAgIGU6IGZ1bmN0aW9uIGUocikge1xuICAgICAgdSA9ICEwLCBvID0gcjtcbiAgICB9LFxuICAgIGY6IGZ1bmN0aW9uIGYoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhIHx8IG51bGwgPT0gdFtcInJldHVyblwiXSB8fCB0W1wicmV0dXJuXCJdKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAodSkgdGhyb3cgbztcbiAgICAgIH1cbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkociwgYSkge1xuICBpZiAocikge1xuICAgIGlmIChcInN0cmluZ1wiID09IHR5cGVvZiByKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkociwgYSk7XG4gICAgdmFyIHQgPSB7fS50b1N0cmluZy5jYWxsKHIpLnNsaWNlKDgsIC0xKTtcbiAgICByZXR1cm4gXCJPYmplY3RcIiA9PT0gdCAmJiByLmNvbnN0cnVjdG9yICYmICh0ID0gci5jb25zdHJ1Y3Rvci5uYW1lKSwgXCJNYXBcIiA9PT0gdCB8fCBcIlNldFwiID09PSB0ID8gQXJyYXkuZnJvbShyKSA6IFwiQXJndW1lbnRzXCIgPT09IHQgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QodCkgPyBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSA6IHZvaWQgMDtcbiAgfVxufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkociwgYSkge1xuICAobnVsbCA9PSBhIHx8IGEgPiByLmxlbmd0aCkgJiYgKGEgPSByLmxlbmd0aCk7XG4gIGZvciAodmFyIGUgPSAwLCBuID0gQXJyYXkoYSk7IGUgPCBhOyBlKyspIG5bZV0gPSByW2VdO1xuICByZXR1cm4gbjtcbn1cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgITApLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0W3JdKTtcbiAgICB9KSA6IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCkpIDogb3duS2V5cyhPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24gKHIpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCByLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsIHIpKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiAhMCxcbiAgICBjb25maWd1cmFibGU6ICEwLFxuICAgIHdyaXRhYmxlOiAhMFxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX2NvbnN0cnVjdCh0LCBlLCByKSB7XG4gIGlmIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkpIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICB2YXIgbyA9IFtudWxsXTtcbiAgby5wdXNoLmFwcGx5KG8sIGUpO1xuICB2YXIgcCA9IG5ldyAodC5iaW5kLmFwcGx5KHQsIG8pKSgpO1xuICByZXR1cm4gciAmJiBfc2V0UHJvdG90eXBlT2YocCwgci5wcm90b3R5cGUpLCBwO1xufVxuZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKHQsIGUpIHtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiAodCwgZSkge1xuICAgIHJldHVybiB0Ll9fcHJvdG9fXyA9IGUsIHQ7XG4gIH0sIF9zZXRQcm90b3R5cGVPZih0LCBlKTtcbn1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0pKCk7XG59XG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soYSwgbikge1xuICBpZiAoIShhIGluc3RhbmNlb2YgbikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyhlLCByKSB7XG4gIGZvciAodmFyIHQgPSAwOyB0IDwgci5sZW5ndGg7IHQrKykge1xuICAgIHZhciBvID0gclt0XTtcbiAgICBvLmVudW1lcmFibGUgPSBvLmVudW1lcmFibGUgfHwgITEsIG8uY29uZmlndXJhYmxlID0gITAsIFwidmFsdWVcIiBpbiBvICYmIChvLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgX3RvUHJvcGVydHlLZXkoby5rZXkpLCBvKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKGUsIHIsIHQpIHtcbiAgcmV0dXJuIHIgJiYgX2RlZmluZVByb3BlcnRpZXMoZS5wcm90b3R5cGUsIHIpLCB0ICYmIF9kZWZpbmVQcm9wZXJ0aWVzKGUsIHQpLCBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiAhMVxuICB9KSwgZTtcbn1cbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSBfdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IF90eXBlb2YoaSkgPyBpIDogaSArIFwiXCI7XG59XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKHQpIHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByIHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSBfdHlwZW9mKGkpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cbi8qKlxuICogQGNsYXNzIENvbnRlbnRzdGFja1xuICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYENvbnRlbnRzdGFja2AuXG4gKiBAaW5zdGFuY2VcbiAqL1xudmFyIENvbnRlbnRzdGFjayA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIENvbnRlbnRzdGFjaygpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29udGVudHN0YWNrKTtcbiAgICAvKipcbiAgICAqIEBtZW1iZXJPZiBDb250ZW50c3RhY2tcbiAgICAqIEBkZXNjcmlwdGlvbiBDYWNoZVBvbGljeSBjb250YWlucyBkaWZmZXJlbnQgY2FjaGUgcG9saWNpZXMgY29uc3RhbnRzLlxuICAgICogQGV4YW1wbGVcbiAgICAqIENvbnRlbnRzdGFjay5DYWNoZVBvbGljeS5JR05PUkVfQ0FDSEVcbiAgICAqIENvbnRlbnRzdGFjay5DYWNoZVBvbGljeS5PTkxZX05FVFdPUktcbiAgICAqIENvbnRlbnRzdGFjay5DYWNoZVBvbGljeS5DQUNIRV9FTFNFX05FVFdPUktcbiAgICAqIENvbnRlbnRzdGFjay5DYWNoZVBvbGljeS5ORVRXT1JLX0VMU0VfQ0FDSEVcbiAgICAqIENvbnRlbnRzdGFjay5DYWNoZVBvbGljeS5DQUNIRV9USEVOX05FVFdPUktcbiAgICAqL1xuICAgIHRoaXMuQ2FjaGVQb2xpY3kgPSBfaW5kZXhbXCJkZWZhdWx0XCJdLnBvbGljaWVzO1xuICAgIHRoaXMuUmVnaW9uID0gX2NvbnRlbnRzdGFja3JlZ2lvbltcImRlZmF1bHRcIl07XG4gICAgdGhpcy5VdGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMjUzKTtcbiAgfVxuXG4gIC8qKlxuICAqIEBtZW1iZXJPZiBDb250ZW50c3RhY2tcbiAgKi9cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhDb250ZW50c3RhY2ssIFt7XG4gICAga2V5OiBcIlN0YWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIFN0YWNrKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0YWNrX2FyZ3VtZW50cyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc3RhY2tfYXJndW1lbnRzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9jb25zdHJ1Y3QoX3N0YWNrW1wiZGVmYXVsdFwiXSwgc3RhY2tfYXJndW1lbnRzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlQXNzZXRVUkxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlQXNzZXRVUkwoZW50cnkpIHtcbiAgICAgIC8vIGNoZWNrIGlmIGVudHJ5IGNvbnNpc3Qgb2YgX2VtYmVkZGVkX2l0ZW1zIG9iamVjdFxuICAgICAgaWYgKGVudHJ5Ll9lbWJlZGRlZF9pdGVtcyA9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfZW1iZWRkZWRfaXRlbXMgbm90IHByZXNlbnQgaW4gZW50cnkuIENhbGwgaW5jbHVkZUVtYmVkZGVkSXRlbXMoKSBiZWZvcmUgZmV0Y2hpbmcgZW50cnkuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIG9iamVjdCBpbiBfZW1iZWRkZWRfaXRlbXMgYW5kIHVwZGF0ZSB0aGUgYXNzZXQgbGlua1xuICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3Aoa2V5KSB7XG4gICAgICAgIHZhciBlbWJlZGRlZF9pdGVtID0gZW50cnkuX2VtYmVkZGVkX2l0ZW1zW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGVtYmVkZGVkX2l0ZW0pKSB7XG4gICAgICAgICAgZW1iZWRkZWRfaXRlbS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICBpZiAoaXRlbS5fY29udGVudF90eXBlX3VpZCA9PSAnc3lzX2Fzc2V0cycgJiYgaXRlbS5maWxlbmFtZSkge1xuICAgICAgICAgICAgICB2YXIgY29ycmVzcG9uZGluZ0Fzc2V0O1xuICAgICAgICAgICAgICB2YXIgX3ggPSBmdW5jdGlvbiB4KGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkcmVuW2ldLmNoaWxkcmVuICYmIGNoaWxkcmVuW2ldLmNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBfeChjaGlsZHJlbltpXS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0uYXR0cnMgJiYgY2hpbGRyZW5baV0uYXR0cnNbJ2Fzc2V0LXVpZCddID09PSBpdGVtLnVpZCkge1xuICAgICAgICAgICAgICAgICAgICBjb3JyZXNwb25kaW5nQXNzZXQgPSBjaGlsZHJlbltpXS5hdHRycztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIF9lbnRyeSA9IF9vYmplY3RTcHJlYWQoe30sIGVudHJ5KTtcbiAgICAgICAgICAgICAgdmFyIGtleXMgPSBrZXkuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgICAgdmFyIHVuc2FmZUtleXMgPSBuZXcgU2V0KFsnX19wcm90b19fJywgJ2NvbnN0cnVjdG9yJywgJ3Byb3RvdHlwZSddKTtcbiAgICAgICAgICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKGtleXMpLFxuICAgICAgICAgICAgICAgIF9zdGVwO1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgayA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGtleSBpcyBzYWZlIGJlZm9yZSBhY2Nlc3NpbmcgaXRcbiAgICAgICAgICAgICAgICAgIGlmICh1bnNhZmVLZXlzLmhhcyhrKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICBpZiAoX2VudHJ5ICYmIF90eXBlb2YoX2VudHJ5KSA9PT0gJ29iamVjdCcgJiYgX2VudHJ5ICE9PSBudWxsICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfZW50cnksIGspKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdFbnRyeSA9IF9lbnRyeVtrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90eXBlb2YobmV3RW50cnkpID09PSAnb2JqZWN0JyAmJiBuZXdFbnRyeSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIF9lbnRyeSA9IG5ld0VudHJ5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoX2VudHJ5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKF9lbnRyeSksXG4gICAgICAgICAgICAgICAgICAgICAgX3N0ZXAyO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2sgPSBfc3RlcDIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgJiYgX3R5cGVvZihibG9jaykgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChibG9jaywgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2VudHJ5ID0gYmxvY2tba107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChfZW50cnkuY2hpbGRyZW4pIF94KF9lbnRyeS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgIGlmIChjb3JyZXNwb25kaW5nQXNzZXQpIHtcbiAgICAgICAgICAgICAgICBjb3JyZXNwb25kaW5nQXNzZXQuaHJlZiA9IGl0ZW0udXJsO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBmb3IgKHZhciBrZXkgaW4gZW50cnkuX2VtYmVkZGVkX2l0ZW1zKSB7XG4gICAgICAgIF9sb29wKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG59KCk7XG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBDb250ZW50c3RhY2soKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gXHR9KTtcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuLyoqKioqKi8gXHRcdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuLyoqKioqKi8gXHRcdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdGV4cG9ydHM6IHt9XG4vKioqKioqLyBcdFx0fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuLyoqKioqKi8gXHR9XG4vKioqKioqLyBcdFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIHN0YXJ0dXBcbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdC8vIFRoaXMgZW50cnkgbW9kdWxlIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgbW9kdWxlcyBzbyBpdCBjYW4ndCBiZSBpbmxpbmVkXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfZXhwb3J0c19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5NDkpO1xuLyoqKioqKi8gXHRtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyBcdFxuLyoqKioqKi8gfSkoKVxuOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/contentstack/dist/node/contentstack.js\n");

/***/ })

};
;